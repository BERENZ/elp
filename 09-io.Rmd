# Wczytywanie i zapisywanie plików {#io}

<!-- A flat file can be a plain text file or a binary file. In the former case, the files usually contain one record per line -->
<!-- csv better than many! -->
<!-- folder roboczy -->

## Folder roboczy

Folder roboczy (ang. *working directory*) to miejsce na dysku, w którym aktualnie pracujemy.
Folder roboczy można sprawdzić korzystając z funkcji `getwd()`:

```{r}
getwd()
```

Zmienić folder roboczy można za pomocą skrótu *Ctrl+Shift+H* w RStudio (inaczej *Session -> Set Working Directory -> Choose Directory..*) lub też funkcji `setwd()`:

```{r, eval=FALSE}
setwd("home/jakub/Documents/elp/") #unix
setwd("C:/Users/jakub/Documenty/elp/") #windows
```

```{block2 type="rmdinfo"}
Ustawienie folderu roboczego ma też miejsce przy tworzeniu nowego lub otwieraniu istniejącego projektu RStudio.
```

Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki.
Ścieżka względna oznacza określanie ścieżki pliku w odniesieniu do istniejącego folderu roboczego, podczas, gdy ścieżka bezwzględna opisuje pełne położenie pliku.
Przykładowo, mamy plik `dane_meteo.csv`, którego pełna ścieżka to `home/jakub/Documents/elp/pliki/dane_meteo.csv`.
Z poziomu R ten plik jest widoczny zarówno jako `home/jakub/Documents/elp/pliki/dane_meteo.csv`, ale też w postaci `pliki/dane_meteo.csv`^[Jeżeli poprawnie ustawiliśmy folder roboczy.].
Używanie ścieżek względnych jest rekomendowane, ponieważ znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami.
Ścieżki względne są też używane w połączeniu z systemami kontroli wersji (rozdział \@ref(kontrola-wersji)).

```{block2 type="rmdinfo"}
Ścieżki folderów w systemach Windows są domyślnie rozdzielane ukośnikiem wstecznym (`\`, ang. *backslash*), jednak R pozwala także na użycie prawego ukośnika (`/`, ang. *slash*).
Prawy ukośnik jest rekomendowany, ponieważ działa on zarówno na Windowsach, jak i komputerach z systemami MacOS czy Linux.
```

<!-- footnote with fs and here pacakges -->

## Wczytywanie plików tekstowych

Podstawowym sposobem przechowywania informacji są pliki tekstowe.
Przykładowo, mogą one przechowywać dane w postaci tabelarycznej.
Jednym z najczęściej używanych formatów tekstowych jest CSV (ang. *comma-separated values*).

Wyobraźmy sobie, że otrzymaliśmy plik tekstowy zawierający wybrane pomiary meteorologiczne dla Poznania oraz Zakopanego w roku 2017.

```{r, echo=FALSE}
m = readLines("pliki/dane_meteo.csv", n = 5)
m
```

Zapisaliśmy ten plik jako `dane_meteo.csv` w podfolderze `pliki`, więc jego ścieżka względna to `"pliki/dane_meteo.csv"`.
Po otworzeniu tego pliku w edytorze tekstu widzimy, że pierwszy jego wiersz zawiera nazwy kolumn, a następne wiersze to kolejne obserwacje.
Dodatkowo można zobaczyć, że kolumny rozdzielane są przecinkami (`,`), natomiast wartości zmiennoprzecinkowe kropkami (`.`).

Do wczytania tego pliku możemy użyć wbudowanej w R funkcji `read.csv()`, podając w niej bezwzględną lub względną ścieżkę do pliku.
W poniższych przykładzie dodatkowo ustalono argument `stringsAsFactors` na `FALSE`, dzięki czemu kolumny z tekstem nie będą zamieniane na klasę czynnikową^[Takie defensywne zachowanie może oszczędzić pewnych problemów w przyszłości.].

```{r}
meteo = read.csv("pliki/dane_meteo.csv", 
                 stringsAsFactors = FALSE)
str(meteo)
```

Oprócz funkcji `read.csv()` istnieje również funkcja o nazwie `read.csv2()`. 
Pierwsza z nich jest przystosowana do wczytania danych dla których separator kolumn to `,` a separator dziesiętny to `.`, druga natomiast jest używana gdy wejściowe dane mają `;` jak separator kolumn i `,` jako separator dziesiętny.

Czasem dane tekstowe posiadają inne znaki służące jako separatory, czy też nie posiadają nazw kolumn.
W takich sytuacjach można użyć funkcji `read.table()`, która zawiera cały szereg argumentów, które można dopasować, aby poprawnie wczytać dane tekstowe.

```{r}
meteo = read.table("pliki/dane_meteo.csv", 
                   sep = ",",
                   header = TRUE)
str(meteo)
```

```{block2 type="rmdinfo"}
R posiada kilka dodatkowych funkcji pozwalających na odczytywanie plików tekstowych, tj. `read.delim()`, `read.delim2()`, `read.fwf()`, czy `readLines()`.
Funkcje `read.delim()` oraz `read.delim2()` są odpowiednikami `read.csv()` i `read.csv2()` dla plików, gdzie kolejne zmienne są oddzielane tabulatorami.
Funkcja `read.fwf()` służy do odczytywania danych o ustalonej długości kolejnych zmiennych.
Funkcja `readLines()` wczytuje kolejne linie z pliku tekstowego.
Efektem jej działania w przeciwieństwie do poprzednich funkcji nie jest ramka danych, ale wektor tekstowy, gdzie każdy kolejny element wektora to tekst z kolejnych linii.
```

## Zapisywanie plików tekstowych

```{r}
meteo_pzn = subset(meteo, nazwa_stacji == "POZNAŃ")
str(meteo_pzn)
```

```{r, eval=FALSE}
write.csv(meteo, "pliki/dane_meteo_pzn.csv",
          row.names = FALSE)
```

```{block2 type="rmdinfo"}
Funkcje `read.csv()` czy `write.csv()` są domyślnie dostępne w języku R.
Ich wydajność nie jest niestety najlepsza w przypadku plików tekstowych o dużej wielkości.
W takich przypadkach warto użyć alternatywnych funkcji, np. `read_csv()` i `write_csv()` z pakietu **readr** [@R-readr] lub `fread()` i `fwrite()` z pakietu **data.table** [@R-data.table].
```

## Formaty R

<!-- info about binary -->

```{r}
meteo$nazwa_stacji = as.factor(meteo$nazwa_stacji)
str(meteo)
```

```{r, eval=FALSE}
saveRDS(meteo, "pliki/dane_meteo.rds")
```

```{r}
meteo_rds = readRDS("pliki/dane_meteo.rds")
str(meteo_rds)
```

```{block2 type="rmdinfo"}
Dodatkowo możliwe jest zapisywanie wielu obiektów do jednego pliku w formacie `.rda` a następnie ich odczytanie używając wbudowanych funkcji `save()` i `load()`.
```

```{r, eval=FALSE}
data(package = "datasets")
```

```{r}
data("faithful", package = "datasets")
head(faithful)
```

## Arkusze kalkulacyjne

[@R-readxl]

```{r}
library(readxl)
meteo_z_xl = read_excel("pliki/dane_meteo.xlsx")
meteo_z_xl
```

```{r, echo=FALSE, eval=FALSE}
writexl::write_xlsx(meteo, "pliki/dane_meteo.xlsx")
```

`write_xlsx()` z pakietu **writexl** [@R-writexl]

## Dane internetowe

```{r, eval=FALSE}
download.file("https://raw.githubusercontent.com/Nowosad/elp/master/pliki/dane_meteo.csv", 
              destfile = "dane_meteo.csv")
```

```{block2 type="rmdinfo"}
`download.file()` `mode`
```

## Inne formaty

Powyżej można było zobaczyć jaki sposób można wczytać dane z różnorodnych plików tekstowych, R, czy arkuszy kalkulacyjnych.
R pozwala jednocześnie na otworzenie wielu innych formatów plików używając dodatkowych pakietów.
Przykładowo, hierarchiczne formaty danych można wczytać używając pakietu **jsonline** (format `.json`) [@R-jsonlite] czy **xml2** (format `.xml`) [@R-xml2], a formaty danych przestrzennych używając pakietu **sf** (dane wektorowe) [@R-sf] czy **raster** (dane rastrowe) [@R-raster].
Zestawienie zawierające dodatkowe przykłady można znaleźć pod adresem https://github.com/leeper/rio.

Powszechną sytuacją jest przechowywanie danych w różnego rodzaju bazach danych.
Ma to miejsce, kiedy dane są znacznej wielkości, mają złożone relacje, czy też muszą być jednocześnie dostępne dla wielu osób.
Dostęp do baz danych w R możliwy jest używając pakietu **DBI** [@R-DBI] wraz z dodatkowym pakietem dla konkretnego systemu bazodanowego (np. **RPostgreSQL** dla baz PostgreSQL [@R-RPostgreSQL] czy **RSQLite** dla baz SQLite [@R-RSQLite]). ^[Więcej informacji o łączeniu się z bazami danych można znaleść na stronie https://db.rstudio.com/getting-started/connect-to-database.]

## Działania na plikach i folderach

Z poziomu R możliwe jest również zarządzanie folderami i plikami na dysku.
Do tworzenia nowych folderów służy funkcja `dir.create()`, np. `dir.create("dane")` stworzy nowy podfolder o nazwie `"dane"`.
Sprawdzenie czy folder już istnieje możliwe jest używając funkcji `dir.exists()`, np. `dir.exists("dane")`, która zwraca wartość `TRUE` gdy folder o tej nazwie istnieje lub `FALSE` gdy takiego folderu nie ma.
Do usuwania istniejących folderów służy funkcja `unlink()`.
W jej przypadku konieczne jest podanie, oprócz nazwy folder do usunięcia, argumentu `recursive = TRUE`.
Przykładowo, aby usunąć folder `"dane"` należy wpisać `unlink("dane", recursive = TRUE)`.

Sprawdzenie czy plik istnieje na dysku można wykonać używając `file.exist()`, a usunąć go za pomocą `file.remove()`.
Obie funkcje przyjmują jako wejście wektor znakowy zawierający nazwy plików do sprawdzenia czy usunięcia.

W przypadkach, gdy konieczne jest stworzenie nowego archiwum ZIP lub rozpakowanie istniejącego pliku w tym formacie można użyć funkcji `zip()` oraz `unzip()`^[Na komputerach z systemem Windows wymagane jest posiadanie zainstalowanego programu do rozpakowywania plików ZIP.].

## Zadania

<!-- wczytaj jeden format, zapisz inny -->
<!-- automatycznie wczytaj dwa pliki -->
<!-- wczytaj, zamien, zapisz -->
<!-- napisz funkcje do zamiany -->
<!-- pobierz, zamien, zapisz, usun stary plik -->
