# Łącznik {#lacznik}

<!-- intro o r jako jezyku laczacym inne -->
<!-- intro o innych łącznikach -->
R ma bezpośrednio wbudowane mechanizmy łączenia kodu R z kodem napisanym w językach C i Fortan.
W tym rozdziale skupimy się jednak na przykładach łączenia R z innymi, popularniejszymi współcześnie językami programowania C++ i Pythonem (sekcje \@ref(cpp) i \@ref(python)) oraz z systemową linią komend (sekcja \@ref(powloka-systemowa)).

<!-- rust, java, javascript, ?? -->

## C++ {#cpp}

C++ jest jednym z najczęściej używanych kompilowanych języków programowania. Jest to spowodowane kilkoma zaletami tego języka, w tym jego wysoką wydajnością, niezależnością od konkretnej platformy systemowej, czy uniwersalnością.

Język C++ posiada zarówno wiele podobnych do R konstrukcji i koncepcji, ale też różni się w pewnych kluczowych koncepcjach. 
Najważniejsze cechy C++, które wyróżniają go od R i które warto znać na początku:

- Jest językiem kompilowanym
- Pozwala na używanie tylko `=` jako operatora przypisania
- Zakłada głównie statyczną kontrolę typów 
- Posiada typ skalarny
- Domyślnie nie używa wektoryzacji
- Większość linii kodu należy kończyć znakiem średnika `;`
- Konieczne jest zwracanie wartości używając `return`

Przykładowy kod R do przeliczania temperatury ze stopnii Fahrenheita na Celsjusza wygląda w poniższy sposób (sekcja \@ref(budowanie-funkcji)):

```{r}
konwersja_temp = function(temperatura_f){
    (temperatura_f - 32) / 1.8
}
```

To samo obliczenie wykonane w języku C++ może wyglądać w ten sposób:

```{Rcpp, eval = FALSE}
double konwersja_temp_cpp(double temperatura_f){
  double temperatura_c = (temperatura_f - 32) / 1.8;
  return temperatura_c;
}
```

Odnosząc się do punktów z wcześniej wymienionej listy:

- Jest językiem kompilowanym - gdybyśmy chcieli użyć powyższą funkcję jako program C++ musielibyśmy stworzyć kolejną funkcję `main()`, a następnie skompilować kod. 
Nie jest możliwe wykonywanie tego kodu linia po linii
- Pozwala na używanie tylko `=` jako operatora przypisania - nie możemy w nim użyć operatora `<-` czy `->`
- Zakłada głównie statyczną kontrolę typów - w powyższym przykładzie musieliśmy zadeklarować, że nasza funkcja `konwersja_temp_cpp`, nasz argument `temperatura_f` oraz zmienna `temperatura_c` będzie typu `double`. Zrobiliśmy to poprzez dodanie nazwy typu przed nazwą funkcji/argumentu/zmiennej. 
Co ważne, w tym języku też typy (zazwyczaj) nie są automatycznie konwertowane do innych typów jak ma to miejsce w R (sekcja \@ref(#lpto-vector)). 
- Posiada typ skalarny - `double` może przechowywać tylko jedną wartość. 
- Domyślnie nie używa wektoryzacji - powyższa funkcja `konwersja_temp_cpp()` zwróci błąd `Expecting a single value` w przypadku podania wektora numerycznego jako obiekt wejściowy.
Aby użyć wektor wartości na wejściu konieczne jest napisane pętli lub użycie innych podobnych konstrukcji.
- Większość linii kodu należy kończyć znakiem średnika `;`. 
Nie dotyczy to linii definujących powstanie funkcji, rozpoczynających i kończących pętle czy wyrażenia warunkowe
- Konieczne jest zwracanie wartości używając `return`. 
W R użycie funkcji `return()` było opcjonalne.

Obecnie ponad dwa tysiące pakietów R łączy się z językiem C++ używając pakietu **Rcpp** [@R-Rcpp].
Często dodanie języka C++ do pakietu R ma na celu przyspieszenie pewnych  wymagających obliczeniowo zadań.

```{r}
library(Rcpp)
```

<!-- https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-introduction.pdf  -->

Pakiet **Rcpp** pozwala na zarówno wywoływanie kodu C++ wewnątrz skryptów R (sekcja \@ref(cppFunction)), jak używając zewnętrznych plików o rozszerzeniu `.cpp` (sekcja \@ref(sourceCpp)).

### Wywoływanie kodu C++ wewnątrz skryptu R {#cppFunction}

W przypadku krótkich fragmentów kodu C++ możliwe jest umieszczenie ich wewnątrz skryptu R jako obiekt tekstowy.
Poniższej stworzono nowy obiekt `rcpp_fun1`, który zawiera wcześniejszą funkcję C++.

```{r}
rcpp_fun1 = "
double konwersja_temp_cpp(double temperatura_f){
  double temperatura_c = (temperatura_f - 32) / 1.8;
  return temperatura_c;
}
"
```

W kolejnym kroku konieczne jest skompilowanie powyższego kodu i stworzenie połączenia pomiędzy nim a R za pomocą funkcji `cppFunction()`.

```{r}
cppFunction(rcpp_fun1)
```

Od tego momentu możliwe jest korzystanie z funkcji `konwersja_temp_cpp()`.
Możemy sprawdzić jej działanie poprzez podanie wybranej przez nas wartości, na przykład `75`.

```{r}
konwersja_temp_cpp(75)
```

Warto jednak nadal pamiętać, że powyższa funkcja nie jest zwektoryzowana - możliwe jest podanie w niej tylko obiektu o długości 1.
W przypadku zadeklarowania dłuższego obiektu wejściowego otrzymamy błąd:

```{r, error=TRUE}
konwersja_temp_cpp(c(0, 75, 110))
```

W sekcji \@ref(zastosowanie-w-funkcjach) stworzyliśmy funkcję `mile_na_km()`, która przyjmuje i zwraca obiekt o klasie lista i zamienia wartości elementów tej listy z mil lądowych na kilometry. 

```{r}
mile_na_km = function(odl_mile) {
  odl_km = vector("list", length = length(odl_mile))
  for (i in seq_along(odl_mile)) {
    odl_km[[i]] = odl_mile[[i]] * 1.609
  }
  odl_km
}
```

Ta sama funkcja w języku C++ może wyglądać w ten sposób:

```{r}
rcpp_fun2 = "List mile_na_km_cpp(List odl_mile){
  int odl_mile_len = odl_mile.size();
  List result(odl_mile_len);
  for (int i = 0; i < odl_mile_len; i++){
    result[i] = odl_mile[i] * 1.609;
  }
  return result;
}"
```

Zawiera ona szereg różnic od kodu R.
Oprócz definicji typów, używania średnika i operatora `return`, widać tutaj także inną metodę wywołania funkcji oraz inny sposób definiowania pętli `for`.

Zadaniem linii `int odl_mile_len = odl_mile.size();` jest stworzenie nowej zmiennej skalarnej (`odl_mile_len`) o typie integer (`int`).
Ta nowa zmienna jest wynikiem działania funkcji `size()`, która jest odpowiednikiem używanej w R `length()`.
W przypadku używania R wywołanie funkcji ma jednak postać, w której podajemy nazwę funkcji, a następnie w nawiasie okrągłym obiekt wejściowy.
C++ pozwala też na inny sposób wywoływania funkcji - używając wbudowanych metod.
Odbywa się to poprzez podanie nazwy obiektu (`odl_mile`), a następnie po kropce (`.`) podania nazwy funkcji (`size()`).

W C++ pętle można definiować używając poniższej składni:

```{Rcpp, eval = FALSE}
for (inicjalizacja zmiennej; warunek zakończenia; aktualizacja zmiennej) {
  // Kod do wykonania
}
```

Po pierwsze należy przekazać w miejscu `inicjalizacja zmiennej` stworzenie zmiennej, na podstawie której będzie oparta pętla.
`int i = 0` oznacza, że tworzymy zmienną o typie integer `i`, która przyjmuje wartość 0.
Jest to spowodowane ważną różnicą między C++ a R - w tym pierwszym języku liczenie rozpoczynamy od 0.
Przykładowo w C++, `a[0]` pozwoli na wybranie pierwszego elementu z wektora `a`.
Drugim elementem jest `warunek trwania`, czyli określenie do kiedy pęlta trwa.
`i < odl_mile_len` oznacza, że pętla będzie działała tak długo aż `i` będzie mniejsze niż `odl_mile_len`.
Ostatni element, `aktualizacja zmiennej`, mówi co ma się stać ze stworzoną zmienną po każdym przebiegu pętli.
`i++` to skrót w języku C++ mówiący, że z każdą pętlą wartość `i` będzie rosła o 1.
Jest to odpowiednik kodu `i = i + 1`.

W powyższej składni też widać sposób definiowania komentarzy w języku C++ używając operatora `//`.

```{r}
Rcpp::cppFunction(rcpp_fun2)
```

```{r}
odl_mile = list(142, 63, 121)
mile_na_km_cpp(odl_mile)
```

```{r}
odl_mile2 = as.list(0:10000)
wynik = bench::mark(
  mile_na_km(odl_mile2),
  mile_na_km_cpp(odl_mile2)
)
wynik
```



### Wywoływanie kodu z plików .cpp {#sourceCpp}

<!--  -->
<!-- ref to \@ref(tworzenie-pakietow) -->

<!-- header file -->

```{Rcpp, eval = FALSE}
#include <Rcpp.h>
```

```{Rcpp, eval = FALSE}
using namespace Rcpp;
```

```{Rcpp, eval = FALSE}
// [[Rcpp::export]]
```

<!-- internal vs exported functions -->

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
List mi_do_km3(List odl_mile){
  int odl_mile_len = odl_mile.size();
  List result(odl_mile_len);
  for (int i = 0; i < odl_mile_len; i++){
    result[i] = odl_mile[i] * 1.609;
  }
  return(result);
}
```

```{r}
library(Rcpp)
sourceCpp("mi_do_km3.cpp")

odl_mile = list(142, 63, 121)
mi_do_km3(odl_mile)
```

<!-- note - packages -->
<!-- indexing starts at 0 -->

<!-- https://adv-r.hadley.nz/rcpp.html -->
<!-- https://csgillespie.github.io/efficientR/performance.html#rcpp -->
<!-- http://thecoatlessprofessor.com/programming/unofficial-rcpp-api-documentation/#minmax -->

## Python
<!-- reticulate -->

[@R-reticulate]

```{r}
library(reticulate)
```

<!-- setting Python version -->
<!-- four types of connections with Python -->

<!-- Type Conversions -->
<!-- Importing Modules -->
<!-- Getting Help -->

https://rstudio.github.io/reticulate/

## Powłoka systemowa {#powloka-systemowa}


<!-- https://stackoverflow.com/questions/48605776/difference-between-system-and-system2-in-r-capture-file-names-in-variable -->
<!-- https://stackoverflow.com/questions/5745886/r-and-system-calls -->
<!-- https://tomaztsql.wordpress.com/2020/01/06/working-with-system-commands-in-r/ -->
<!-- https://joongsup.rbind.io/post/2018/02/05/run-system-commands-or-shell-sripts-from-an-interactive-r-session/ -->

<!-- grep -->
<!-- cat -->
<!-- find -->
<!-- head/tail -->
<!-- awk -->
<!-- man -->

<!-- https://github.com/microsoft/terminal -->
<!-- http://www.makoweabc.pl/2009/12/os-x-terminal-jak-go-uruchomic-krok-po-kroku/ -->
<!-- https://ubuntu.com/tutorials/command-line-for-beginners#1-overview -->
<!-- https://neowaylabs.github.io/programming/unix-shell-for-data-scientists/?utm_source=hackernewsletter&utm_medium=email&utm_term=data -->
<!-- https://missing.csail.mit.edu/ -->

## Zadania