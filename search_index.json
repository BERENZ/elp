[
["index.html", "Elementarz programisty Wstęp do programowania używając R O książce Wymagania wstępne Styl książki Podziękowania", " Elementarz programisty Wstęp do programowania używając R Jakub Nowosad 2019-02-26 O książce Aktualna wersja książki znajduje się pod adresem https://nowosad.github.io/elp/. Jeżeli używasz tej książki, zacytuj ją jako: Nowosad, J., (2019). Elementarz programisty: wstęp do programowania używając R. Poznań: Space A. Online: https://nowosad.github.io/elp/ Zachęcam również do zgłaszania wszelkich uwag, błędów, pomysłów oraz komentarzy na stronie https://github.com/nowosad/elp/issues. Ta książka jest dostępna na licencji Creative Commons Uznanie autorstwa - Użycie niekomercyjne - Bez utworów zależnych 4.0 Międzynarodowe. Wymagania wstępne Do odtworzenia przykładów oraz do wykonania zadań zawartych w tej książce konieczne jest posiadanie aktualnej wersji R. Pod adresem https://cloud.r-project.org/ można znaleźć instrukcje instalacji R dla systemów Windows, Mac OS i Linux. W niektórych rodziałach użyte zostanie zintegrowane środowisko programistyczne RStudio. Można je zainstalować korzystając ze strony https://www.rstudio.com/products/rstudio/download/#download. Aspekty dotyczące kontroli wersji zostaną omówione używając oprogramowania Git. Zalecanym sposobem installacji Git na Windows jest wersja ze strony https://gitforwindows.org/. Instrukcja instalacji na system Mac OS znajduje się pod adresem https://happygitwithr.com/install-git.html#macos. Wersję Linuxową można zainstalować używając poniższej linii kodu: # Ubuntu sudo apt install git # Fedora sudo dnf install git Dodatkowo, warto stworzyć konto na stronie GitHub poprzez adres https://github.com/join. GitHub jest serwisem internetowym wspierającym tworzenie oraz współpracę przy tworzeniu programów komputerowych. Styl książki W całej książce stosowana jest konwencja, w której fun() oznacza funkcje, obi oznacza nazwy obiektów, nazwy zmiennych oraz argumentów funkcji, a sci/ oznacza ścieżki do plików. Wszystkie pakiety użyte w tej książce oznaczane są pogrubioną czcionką - pak. Tekst na szarym tle przedstawia blok kodu. Może on zawierać komentarze (rozpoczynające się of znaku #), kod oraz wynik jego użycia (rozpoczynające się od znaków #&gt;). # komentarz kod #&gt; wynik użycia kodu Dodatkowo, ikona kompasu na szarym tle przedstawia dodatkowe informacje, alternatywne sposoby użycia funkcji, czy też wskazówki. Tutaj może znaleźć się dodatkowa informacja, alternatywny sposób użycia funkcji, czy też wskazówka. Podziękowania Książka została stworzona w R (R Core Team 2017) z wykorzystaniem pakietów bookdown (Xie 2018a), rmarkdown (Allaire et al. 2018), knitr (Xie 2018b) oraz programu Pandoc. Użyte ikony zostały stworzone przez Freepik z www.flaticon.com na licencji CC 3.0 BY. Bibliografia "],
["wprowadzenie.html", "1 Wprowadzenie 1.1 Mity programistyczne 1.2 Języki programowania 1.3 R 1.4 Zadania", " 1 Wprowadzenie Żyjemy obecnie w epoce trzeciej rewolucji przemysłowej1, zwanej inaczej rewolucją cyfrową. Jest ona powiązana z przejściem z technologii mechanicznych i analogowych na technologie elektroniczne i cyfrowe. W tej epoce nastąpiło stworzenie i rozpowszechnieniem się komputerów, co w efekcie spowodowało szerokie zmiany społeczno-ekonomiczne. Wiele z tych zmian jest pozytywnych, ale istnieją również zmiany negatywne, bądź też takie które trudno jednoznacznie ocenić. Przykładowo, wyraźną korzyścią społeczną jest znacznie ułatwiony dostęp do informacji. Jednocześnie taki dostęp powoduje sytuację określaną jako przeciążenie informacją (ang. information overload), w której występuje zbyt wielka ilość informacji aby podjąć właściwą decyzję lub zrozumieć sens danego tematu. Rozwój technologiczny spowodował też transformację produkcji przemysłowej i zmiany gospodarcze. Firmy zajmujące się technologiami informacyjnymi, tj. Microsoft, Apple, czy Google, są obecnie jednymi z najbardziej dochodowych przedsiębiorstw, a twórca platformy Amazon, Jeff Bezos, jest najbogatszym człowiekiem świata2. Wiele z tych technologii nie byłoby możliwych bez programowania. Programowanie, w znacznym uproszczeniu, to proces tworzenia serii instrukcji, które informują komputer jak wykonać pewne zadanie. Ta seria instrukcji jest zazwyczaj zapisywana na komputerze w postaci tekstu w wybranym języku programowania. Co w takim razie powoduje, że programowanie ma tak istotny wpływ na wiele elementów codziennego życia? Programowanie cechuje kilka unikatowych możliwości. Po pierwsze, programowanie i jego efekty można w prosty sposób powielać niemal w nieskończoność. Wcześniej stworzenie pewnego towaru opierało się o ograniczone zasoby, np. ziemia czy surowce naturalne. Nie możliwe było wykucie zbroi raz, a następnie natychmiastowe powielenie jej wiele razy i sprzedanie jej wielu kopii. We współczesnym świecie, jedna aplikacja może być sprzedana (lub rozpowszechniona) wiele razy, a często większy nacisk kładzie się na rozbudowę i ulepszanie istniejących popularnych aplikacji niż tworzenie nowych3. Ułatwia to też budowę nowych rozwiązań na podstawie już istniejących4. Współcześnie programowanie pozwala na wykonywanie trylionów (1018) operacji arytmetycznych na sekundę5. Pozwala to na znaczne zwiększenie wydajności dostępnych rozwiązań, otwiera możliwość praktycznego wykorzystania istniejących idei, lub też tworzenia nowych pomysłów. Inną cechą programowania jest też jego prosta możliwość automatyzacji powtarzanych czynnośći oraz ułatwiona powtarzalność (ang. reproducibility) Posiadając kod źródłowy danego oprogramowania lub skrypt wykonujący analizę danych, możliwe jest odtworzenie tego wyniku przez inną osobę na drugim końcu świata, lub też przez siebie samego po paru miesiącach. Ostatnią cechą programowania jest jego uniwersalność. Jest ono wykorzystywane w transporcie, przemyśle, nauce, rozrywce i wielu innych strefach życia. W efekcie zrozumienie i znajomość języków programowania jest cenną umiejętnością we współczesnym świecie. 1.1 Mity programistyczne Programowanie komputerowe ma obecnie już długą historię - pierwszy język programowania Plankalkül powstał w latach 1943-19456. Fortran, stworzony w roku 1957, jest nadal używany współcześnie do wielu celów, między innymi wymagających dużej wydajności obliczeń hydrologicznych, prognozowania pogody czy modelowania klimatu. Programowanie ewoluowało i nadal ewoluuje wraz z rozwojem dostępności i możliwości komputerów. Pojawiły się nowe pradygmaty programowania oraz wiele nowych języków. W tym samym czasie narosło również wiele mitów dotyczących programowania7. Jednym z mitów jest to, że programowanie polega tylko siedzeniu przed ekranem komputera i wpisywaniu do niego kolejnych linii kodu. Jest to oczywiście istotna część pracy programistycznej, ale prawdopodobnie nie jest ona nawet dominująca w przeciętym dniu programisty. Wcześniej konieczne jest zastanowienie się jaki problem rozwiązujemy oraz zaprojektowanie możliwego rozwiązania tego problemu. Stworzony kod może okazać się być nieprzystępny dla użytkownika, słabo zoptymalizowany, lub nawet błędny. Dlatego też innym ważnym elementem jest testowanie kodu w celu wyłapania potencjalnych problemów. Innym aspektem programowania jest tworzenie dokumentacji. Żaden program nie może zachęcić do siebie użytkowników, jeżeli nie będą oni w stanie zrozumieć jak on działa. Dokumentacja jest też cenna dla twórców programu, szczególnie kiedy konieczne jest użycie czy modyfikacja programu kilka miesięcy po jego ostatnim użyciu. Programy komputerowe są też zazwyczaj w dużej sieci powiązań z już istniejącymi bibliotekami czy oprogramowaniem. Zmiana w tych bibliotekach czy oprogramowaniu może skutkować nie zawsze oczekiwanymi zmianami w stworzonym programie. Częścią programowania jest też utrzymywanie istniejącego kodu źródłowego oraz jego ulepszanie. Programiści do swojej pracy wykorzystują też odpowiednie wspierające ich narzędzia, takie jak edytory kodu źródłowego, debugery, zintegrowane środowiska programistyczne czy systemy kontroli wersji. Mitem również jest przekonanie, że programowanie to męskie zajęcie. Bierze się ono z obecnej na rynku pracy struktury, w której około 75% programistów to mężczyźni a tylko 25% to kobiety. Ta struktura jednak nie jest odzwierciedleniem jakichś wrodzonych umiejętności. Za pierwszego programistę często uważa się Adę Lovelace, angielskiego matematyka i poetkę8. To ona w 1843 opublikowała pierwszy program komputerowy. Jej algorytm do obliczenia liczb Bernoulliego nie został jednak przetestowany, ponieważ urządzenie do tych obliczeń (zwane maszyną analityczną9) nie zostało skonstruowane. Ponad wiek później, gdy istniały już techniczne możliwości tworzenia komputerów, programowanie było uważane za kobiecy zawód10 (Rycina 1.1). Z uwagi na szereg czynników społecznych i historycznych11, w latach 1970 nastąpiło odwrócenie proporcji w tym zawodzie. Obecnie podejmowanych jest szereg inicjatyw, które mają na celu zachęcić kobiety do programowania. Wsród nich można wymienić działania organizacji R-Ladies, PyLadies, czy girls.js. Mit programisty mężczyzny jest też powiązany z wymienionym kilka akapitów niżej mitem samotnego programisty. Rycina 1.1: Margaret Hamilton stojąca w 1969 roku obok wydruków oprogramowania, które on i jej zespół stworzył na potrzeby misji Apollo. Kolejny jest mit wielkiego produktu. Oznacza on, że po nauczeniu się podstaw danego języka programowanie, jest się od razu w stanie stworzyć bardzo złożony program, np. nowy system operacyjny, skomplikowaną aplikację na telefon, czy grę komputerową. W rzeczywistości takie produkty opierają się o tysiące godzin pracy wielu programistów. Dodatkowo, nie są one tworzone od podstaw, ale używając szeregu dostępnych narzędzi, bibliotek i innych rozwiązań. Celem pisania kodu, więc nie powinno być stworzenie od zera bardzo złożonej aplikacji, lecz odpowiednie użycie istniejących rozwiązań. Jednocześnie pisanie złożonego oprogramowania wymaga uzyskania niezbędnego doświadczenia. Mit wielkiego produktu wiąże się również z wymienionym w kolejnym akapicie mitem samotnego programisty. W popkulturze osoba, która potrafi programować spędza czas samotnie, gwałtownie wpisując kolejne linie kodu do komputera w ciemnym pokoju. W rzeczywistości jednak większość profesjonalnych programistów pracuje w zespołach, których członkowie pracują nad różnymi aspektami tego samego problemu. Pisanie programów często wymaga współpracy różnych osób, dlatego też umiejętność pracy w grupie jest coraz istotniejsza. Warto dodać, że współpraca nad pisaniem programów nie musi odbywać się w jednym pokoju czy budynku. Ze względu na charakter takiej pracy i możliwości technologiczne, wiele formalnych i nieformalnych grup pracuje zdalnie nad projektami. Wiele przykładów takich zachowań można znaleźć przyglądając się otwartemu oprogramowaniu (ang. open-source software) na platformie GitHub (np. https://github.com/trending/r). W poprzednim akapicie celowo użyłem stwierdzenia “osoba, która potrafi programować” zamiast “programista”. Jest to kolejny powszechny mit, że każda osoba która potrafi stworzyć program musi od razu zostać pełnoetatowym programistą. Pisanie programów jest narzędziem, które ma wspomóc twórcę w pewnym celu. Jednym z celów może być zostanie profesjonalnym deweloperem stron internetowych, aplikacji mobilnych, gier komputerowych, itd. Nie jest to jednak jedyny cel - programowanie może być, na przykład przydatnym narzędziem w analizie danych12. Umiejętności programistyczne są wykorzystywane przez ekonomistów, biologów, geografów i osób z wielu innych dziedzin. Dodatkowo, podstawowe aspekty programowania są bardzo cenne w zawodach, w których ważna jest częsta współpraca z programistami. Kolejny mitem jest mit programisty geniusza. W tym micie programują tylko osoby, która ma nadludzką pamięć oraz wyróżniającą wiedzę matematyczną. Oczywiście, takie cechy przydają się w programowaniu, ale nie są one wymagane do programowania. W programowaniu częściej od dobrej pamięci przydaje się umiejętność szybkiego znalezienia rozwiązania czy odpowiedzi na problem w internecie. Programista nie musi znać na pamięć setek różnych poleceń i funkcji, ważne że umie je zidentyfikować. Natomiast zamiast głębokiej wiedzy matematycznej do większości zadań programistycznych wystarczy podstawowa znajomość algebry. Z tym mitem wiąże się też inna kwestia - założenia że ten programista geniusz posiadł całą wiedzę programistyczną. Podobnie jak nauka języka obcego, nauka języka programowania wymaga dużo pracy i czasu. Dodatkowo, języki programowania czy techniki programowania zmieniają się znacznie częściej niż języki naturalne, dlatego też częścią programowania jest ciągłe uczenie się. Ostatni mit natomiast mówi o tym, że dla każdego problemu programistycznego istnieje tylko jedno najlepsze rozwiązanie. Jeden problem można zazwyczaj rozwiązać na dziesiątki różnych sposobów. Wynika to z tego, że wiele aspektów programowania opiera się o personalne preferencje, np. wybór danego języka programowania, używanych bibliotek, czy stylu pisania kodu. W efekcie zazwyczaj nie możliwe jest jednoznaczne określenie, które rozwiązanie jest lepsze, szczególnie jeżeli wiele rozwiązań ma podobną wydajność. Istnieje jednak kilka reguł, z którymi zgadza się większość programistów. Pierwsza z nich mówi, że wolny działający kod jest lepszy niż szybki niedziałający kod13. Kolejna opiera się o zasadę DRY (nie powtarzaj się, ang. Don’t Repeat Yourself), zalecającą unikanie różnego rodzaju powtórzeń wykonywanych przy programowaniu, np. używania tych samych fragmentów kodu w wielu miejscach. Ostatnia reguła mówi, żeby tworzyć pisać programy w sposób modularny, czyli taki w którym każda funkcja spełnia tylko jedno i nie więcej zadanie, a złożone funkcje składają się z szeregu prostych funkcji. 1.2 Języki programowania Głównym sposobem przekazywania instrukcji do komputera jest użycie języków programowania. Pozwalają one na precyzyjny zapis zadań, które następnie mają zostać wykonane przez komputer. Języki programowania składają się ze zbioru reguł syntaktycznych (składni) oraz semantyki. Składnia (forma) mówi o tym jakie symbole są dostępne w danym języku oraz jak te symbole mogą być łączone w większe struktury. Semantyka (treść) natomiast definiuje znaczenie poszczególnych symboli. W przeciwieństwie do języków naturalnych, języki programowania wymagają wysokiej precyzji. Mówiąc w języku naturalnym możemy popełnić jakiś błąd (np. gramatyczny czy składniowy) i nadal być łatwo zrozumianym przez otoczenie. Języki programowania nie akceptują takich błędów i nie są w stanie wykonać danego polecenia. Obecnie istnieją tysiące14 języków programowania i każdego roku powstają nowe. Nie ma wśród nich jednego najlepszego, uniwersalnego języka programowania i w najbliższej przyszłości ten stan się nie zmieni. Jest to związane z bardzo szerokim zastosowaniem programowania w wielu dziedzinach czy problemach, które mają od siebie zupełnie różne wymagania. Przykładowe wymagania mogą dotyczyć np. szybkości wykonywanych obliczeń, łatwości pisania kodu, stabilności języka programowania, czy celu obliczeń. Do tego dochodzą również rożne kwestie historyczne i społeczne, jak na przykład preferowanie danego języka programowania przez osoby w danej branży. Obecnie wśród najpopularniejszych języków programowania można wymienić takie języki jak Java, C, Python, C++, Visual Basic .NET, JavaScript, C#, PHP, SQL, Objective-C, język asemblera, Perl, czy R. Języki programowania można podzielić na wiele różnych grup w zależności od przyjętych kryteriów. Poniżej wyjaśnionych jest kilka możliwych podziałów języków programowania. Jednym z nich jest sposób wykonywania kodu - to czy kod w danym języku jest kompilowany czy też interpretowany. Kompilacja kodu (np. C czy Java) polega na jego tłumaczeniu do postaci języka maszynowego. W efekcie zapewnia to wysoką wydajność programu, ale za to kod jest ściśle powiązany z daną platformą sprzętową. Programowanie w językach kompilowanych jest zazwyczaj bardziej złożone i trudniejsze w nich jest odnajdywanie błędów (tzw. debugging). Interpretowane języki programowania, często również nazywane językami skryptowymi, (np. R czy Python) charakteryzuje to, że w momencie uruchomienia kod jest zamieniany na postać zrozumiałą dla komputera i od razu wykonywany. W efekcie można szybko zobaczyć efekt zmian. Wadą tego typu języków jest ich zmniejszona wydajność w porównany do języków kompilowanych. Innym powszechnym podziałem języków programowania jest ich rozróżnianie na podstawie poziomu. Tutaj można wyróżnić języki od niskiego poziomu do wysokiego poziomu. Na najniższym poziomie jest język maszynowy, czyli taki w którym zapis programu wyrażony jest w postaci liczb binarnych. Powyżej są umieszczony jest język asemblera, w którym program jest zapisany poprzez serię instrukcji. Na najwyższym poziomie stawia się języki, które są wspomagane przez kompilator albo interpreter. Języki programowania można też rozróżnić ze względu na paradygmat programowania. Definiuje on w jaki sposób w danym języku wykonywany jest przepływ sterowania czy też jak kod jest organizowany. Dwa podstawowe paradygmaty programowania to programowanie imperatywne i deklaratywne. Programowanie imperatywne (np. Fortran, C) opisuje proces wykonywania kodu jako sekwencję instrukcji zmieniających stan programu. Obejmuje ono inne paradygmaty, jak na przykład programowanie proceduralne czy obiektowe . Programowanie deklaratywne skupia się natomiast na warunkach jakie musi spełniać końcowe rozwiązanie, a nie na sekwencji kroków do jego stworzenia. W skład tej grupy wchodzi, między innymi, programowanie funkcyjne czy matematyczne. Niektóre języki mogą być zaklasyfikowane do kilku paradygmatów. Przykładowo R wspiera zarówno paradygmat funkcyjny, ale zawiera też możliwości programowania obiektowego. 1.3 R W tej książce wprowadzenie do programowania opiera się o język R (Rycina 1.2). Rycina 1.2: Logo języka programowania R. Wynika to z szeregu zalet tego języka: R jest bezpłatnym, otwartym oprogramowaniem, który można uruchomić na różnych systemach operacyjnych (Windows, Mac OS i Linux), zarówno na komputerach osobistych jak i na dużych klastrach obliczeniowych. W efekcie nie ma on finansowej bariery rozpoczęcia pracy, a kod napisany na jednym komputerze można również przenieść i uruchomić na innym sprzęcie. R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. Ten aspekt ułatwia szybsze zrozumienie działania tego języka. R posiada wiele wbudowanych narzędzi analizy i wizualizacji danych. Pozwala to na relatywnie szybkie osiąganie wymiernych efektów z korzystania z tego języka. R posiada tysiące dodatkowych rozszerzeń (zwanych pakietami) pozwalających na, między innymi, przetwarzanie różnorodnych danych, ich wizualizację, czy zaawansowane modelowanie. Oficjalnym portalem zawierającym dodatkowe pakiety R jest CRAN. R ma przyjazną społeczność użytkowników tego języka, zarówno online jak i spotykających się na żywo na tzw. meetupach. W celu ułatwienia pracy z R powstało również zintegrowane środowisko programistyczne RStudio, które wspomaga pisanie i analizę kodu w R. R został zaprojektowany jako narzędzie ułatwiające komunikację między różnymi językami programowania, głównie C oraz Fortran15. Obecnie R pozwala na łatwe łączenie kodu pochodzącego również z takich języków jak C++, Python, JavaScript, itd. R jest używany przez wiele małych firm, jak i wielkich korporacji, wliczając w to BBC, Facebook, Google, Microsoft, Mozilla, Netflix, T-Mobile, czy Uber16. Oczywiście, uniwersalny i idealny język nie istnieje: R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. W efekcie R nie jest najszybszym językiem programowania. Podobnie jak wiele innych języków, również R zawiera wiele niekonsekwencji, wynikających z wieloletniej ewolucji tego języka. W efekcie istnieje wiele specjalnych przypadków czy wyjątków, które warto znać (???). Ta książka skupia się na prezentacji głównym konceptów programistycznych używając języka R. W sekcji 2.4 można znaleźć listę różnorodnych materiałów, książek, blogów, kursów, czy serwisów ułatwiających i wspomagających naukę R. Istnieje także wiele wprowadzających materiałów do nauki innych języków. Przykładowo, osoby zainteresowane nauką Pythona mogą skorzystać z książek Gries, Campbell, and Montojo (2017) oraz Guzdial and Ericson (2016), czy też kursów Software Carpentry oraz Python Course. W pracy programistycznej przydaje się również często znajomość linii komend. Tutaj również można użyć materiałów z kursu Software Carpentry lub książki The Unix Workbench (Kross 2017). 1.4 Zadania Pomyśl do czego jesteś w stanie wykorzystać programowanie w swoim życiu zawodowym lub prywatnym? Zastanów się nad mitami związanymi z programowaniem. Czy jesteś w stanie wskazać jakieś mity nie wymienione powyżej? Wybierz trzy języki programowania z listy wymienionej w tym rozdziale i poszukaj informacji o nich. Do czego są one stosowane? Jakie mają wady i zalety? Bibliografia "],
["ergosum.html", "2 R ergo sum 2.1 Wyrażenia 2.2 Obiekty 2.3 IDE 2.4 Dodatkowe materiały 2.5 Styl 2.6 Zadania", " 2 R ergo sum 2.1 Wyrażenia 2 + 2 #&gt; [1] 4 1 - 3 #&gt; [1] -2 5 * 5 #&gt; [1] 25 42 / 5 #&gt; [1] 8.4 2.2 Obiekty 2.2.1 Operator przypisania Operator przypisania służy do nadania wartości do obiektu. R posiada trzy operatory przypisania, które mają niemal identyczne działanie17: =, &lt;-, -&gt;. x = 7 x #&gt; [1] 7 y = x y #&gt; [1] 7 2.2.2 Działania na obiektach z1 = x + 3 z1 #&gt; [1] 10 z2 = x - 5 z2 #&gt; [1] 2 z3 = x * 2 z3 #&gt; [1] 14 z4 = x / 4.4 z4 #&gt; [1] 1.59 z5 = x %% 3 z5 #&gt; [1] 1 z6 = x %/% 3 z6 #&gt; [1] 2 z7 = x ^ 2 z7 #&gt; [1] 49 z8 = sqrt(x) z8 #&gt; [1] 2.65 z9 = c(z2, z4, z8) z9 #&gt; [1] 2.00 1.59 2.65 2.3 IDE Rstudio to zintegorwane środowsko programistyczne (ang. Integrated Development Environment, IDE) dla R. Zawiera ono bardzo wiele użytecznych funkcjonalności, tj. wbudowany edytor, podświetlanie składni, automatyczne uzupełnianie kodu i wiele innych. Tabela 2.1: Podstawowe skróty klawiaturowe w RStudio Skrót Wyjaśnienie Ctrl+Enter wykonuje wybraną linię kodu w skrypcie R Tab uzupełnia kod (podaje pasujące mozliwości) F1 wyświetla plik pomocy dla wybranej funkcji Ctrl+Shift+C ustawia wybrane linie jako komentarz/odkomentuj fragment kodu strzałka Góra/Dół (w oknie konsoli) wybiera wcześniej wpisany kod Esc przerywa niedokończoną operację Shift+Alt+K wyświetla listę skrótów klawiaturowych use r projects 2.4 Dodatkowe materiały Polskie książki: http://www.biecek.pl/R/ (Biecek 2014) http://www.gagolewski.com/publications/programowanier/ (Gagolewski 2016) https://helion.pl/ksiazki/jezyk-r-kompletny-zestaw-narzedzi-dla-analitykow-danych-hadley-wickham-garrett-grolemund,jezrko.htm#format/d (Wickham and Grolemund 2016) https://helion.pl/ksiazki/wydajne-programowanie-w-r-praktyczny-przewodnik-po-lepszym-programowaniu-gillespie-colin-lovelace-robin,a_0491.htm#format/d (Gillespie and Lovelace 2016) https://bookdown.org/nowosad/Geostatystyka/ (Nowosad 2019) Angielskie książki: https://rstudio-education.github.io/hopr/ (Grolemund 2014) https://r4ds.had.co.nz/ (Wickham and Grolemund 2016) https://csgillespie.github.io/efficientR/ (Gillespie and Lovelace 2016) https://adv-r.hadley.nz (Wickham 2014) https://geocompr.robinlovelace.net/ (Lovelace, Nowosad, and Meunchow 2019) Blogi: Agregator blogów dotyczących R - https://www.r-bloggers.com/ Polski blog opisujący kwestie analizy danych w R, wizualizacji, oraz edukacji - http://smarterpoland.pl/ Polski blog pokazujący zastosowanie R do analizy i wizualizacji danych - http://szychtawdanych.pl/ Kursy: Lista kursów dotyczących R na platformie DataCamp (część z nich jest dostępna bezpłatnie) - https://www.datacamp.com/search?q=r Polskie tłumaczenie pakietu R służącego do nauki tego języka - https://github.com/dabrze/swirl Lista kursów dotyczących R na platformie Coursera - https://www.coursera.org/courses?query=r Lista kursów dotyczących R na platformie edX - https://www.edx.org/course?search_query=r typing https://www.typingclub.com/ Serwisy internetowe: Wyszukiwarki internetowe są nieocenionym narzędziem wspierającym programowanie - https://rseek.org/, https://duckduckgo.com/, https://www.google.com/, https://www.bing.com/, itd. Serwis społecznościowy zawierający pytania i odpowiedzi dotyczące różnych języków programowania w tym R - https://stackoverflow.com. Pytania dotyczące R można znaleźć pod adresem https://stackoverflow.com/questions/tagged/r. Przed zadaniem nowego pytania warto wyszukać czy nie zostało ono zadane wcześniej a następnie przeczytać wątek dotyczący tworzenia nowych pytań - https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example Twitter jest miejscem, w którym można znaleźć zarówno nowości z języka R, jak również odpowiedzi na pytania dotyczące tego języka - https://twitter.com/. Kwestie związane z R są opatrzone hasztagiem #rstats, natomiast kwestie przestrzenne w R są opisywane hasztagami #rspatial oraz #geocompr Elektroniczny biuletyn R Weekly zbierający co tydzień nowości związane z r - https://rweekly.org/ Lista emailowa dotycząca R - https://stat.ethz.ch/mailman/listinfo/r-help Lista emailowa dotycząca kwestii przestrzennych w R - https://stat.ethz.ch/mailman/listinfo/r-sig-geo Forum dotyczące kwestii R i RStudio - https://community.rstudio.com/ Meetups (spotkania początkujących i zaawansowanych użytkowników R): Poznań - https://www.meetup.com/pl-PL/Poznan-R-User-Group-PAZUR/ Warszawa - https://www.meetup.com/pl-PL/Spotkania-Entuzjastow-R-Warsaw-R-Users-Group-Meetup/ Wrocław - https://www.meetup.com/Wroclaw-R-Users-Group/ Kraków - https://www.meetup.com/erkakrakow/ Trójmiasto - https://www.meetup.com/Trojmiejska-Grupa-Entuzjastow-R/ 2.5 Styl Poniżej znajdują się podstawowe porady dotyczące stylu pisania kodu. Więcej wskazówek można znaleźć na w poradniku stylu RStudio oraz poradniku stylu Google. Oba te poradniki nie są identyczne i czasami zawierają sprzeczne porady. Najważniejsze jest, aby wybrać jeden odpowiadający piszącemu kod styl i się go konsekwentnie trzymać. 2.5.1 Nazwy obiektów Istnieje wiele konwencji nazywania obiektów18. Najczęściej używaną konwencją w R jest tzw. “snake case”. Polega ona na tworzeniu nazw obiektów składających się ze słów połączonych znakiem podkreślenia (_), np. Ważne, żeby nazwy obiektów ułatwiały zrozumienie ich zawartości. # obiekt bok_a bok_b # funkcja pole_prostokata Dodatkowo należy uważać, żeby nowa nazwa obiektu nie nadpisała istniejącego obiektu lub funkcji. Nie powinno nazywać się obiektów, np. c, t, table, itd. 2.5.2 Odstępy Odstępy pełnią bardzo ważną funkcję przy pisaniu kodu, podobnie jak odstępy przy pisaniu tekstu. Wyobraź sobie czytanie powieści, w której nie ma żadnych odstępów między słowami czy rozdziałami. Często mówi się, że “kod musi oddychać” - odstępy zwiększają czytelność kodu i pozwalają na jego szybsze zrozumienie oraz ułatwiają naprawienie występujących błędów. Odstępy można uzyskać poprzez użycie spacji. Spacje powinny być użyte po przecinkach, ale nigdy przed nimi. Dodatkowo, większość operatorów (np. =, +, -, ==) powinna być otoczona przez spacje. # Zalecane srednia = mean(wartosc, na.rm = TRUE) pole = bok_a * bok_b # Niewskazane srednia=mean ( wartosc,na.rm=TRUE ) pole=bok_a*bok_b Spacje należy również używać do tworzenia wcięć - każde z nich powinno się składać z dwóch spacji. # Zalecane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } # Niewskazane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Warto także ograniczać długość każdej linii kodu, żeby nie przekraczała ona ok. 80 znaków. Dzięki temu możliwe jest szybkie przeczytanie kodu czy też jego wydrukowanie. # Zalecane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, b = &quot;drugi argument&quot;, c = &quot;trzeci argument&quot;) # Niewskazane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, &quot;drugi argument&quot;, &quot;trzeci argument&quot;) 2.5.3 Komentarze Komentarze służą do wyjaśniania istotnych elementów kodu. Do komentowania w języku R służy operator #. # Mój komentarz 2.5.4 Nazwy plików Nazwy plików powinny spełniać trzy wymagania - być łatwe (i) do odczytania przez komputer, (ii) do odczytania przez człowieka, (iii) do posortowania. Nazwy plików nie powinny zawierać spacji, znaków specjalnych (np. !, %, *), znaków diakrytycznych (np. ć, Ł, ź). Warto też aby nazwy plików składały się tylko z małych liter. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane Obliczanie Średniej.R pomiaryTemperatury!.csv Podobnie jak nazwy obiektów, również nazwy plików powinny opisywać ich zawartość. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane kod.R dane.csv Dodatkowo wskazane jest dodanie wartości numerycznych przed nazwą pliku, jeżeli pliki mają jakąś kolejność. # Zalecane 01_przygotowanie-danych.R 02_obliczanie-sredniej.R # Niewskazane przygotowanie-danych.R obliczanie-sredniej.R encodings 2.5.5 Daty Istnieje wiele sposóbów zapisu dat19, co może powodować różnorodne problemy przy programowaniu oraz analizie danych. Z ratunkiem w tej kwestii przychodzi norma ISO 8601, która definiuje daty kalendarzowe jako \\(YYYY-MM-DD\\), czyli \\(ROK-MIESIĄC-DZIEŃ\\). # Zalecane 2019-06-02 # Niewskazane wszelkie inne 2.6 Zadania Bibliografia "],
["funkcje.html", "3 Funkcje 3.1 Algorytmy 3.2 Struktura funkcji 3.3 Wbudowane funkcje 3.4 Dokumentacja funkcji 3.5 Pakiety 3.6 Tworzenie skryptów 3.7 Budowanie funkcji 3.8 Zadania", " 3 Funkcje 3.1 Algorytmy Algorytm to opis procedery prowadzącej do uzyskania określonego celu. 3.2 Struktura funkcji 3.3 Wbudowane funkcje x = c(8.2, 10.3, 12.0) (8.2 + 10.3 + 12.0) / 3 #&gt; [1] 10.2 sum(x) / length(x) #&gt; [1] 10.2 mean(x) #&gt; [1] 10.2 y = mean(x) 3.4 Dokumentacja funkcji Każda wbudowana funkcja w R posiada swoją dokumentację20. Można ją wyświetlić poprzez dodanie znaku zapytania przed nazwą funkcji, a następnie wykonanie tej linii kodu. ?mean Alternatywnie, w RStudio możliwe jest użycie skrótu F1 gdy kursor znajduje się na nazwie funkcji. Dokumentacja każdej funkcji, zwana inaczej plikiem pomocy, ma zazwyczaj podobną strukturę. W lewym górnym rogu znajduje się nazwa funkcji (mean) oraz nazwa pakietu z którego dana funkcja pochodzi (base) Poniżej znajduje się tytuł funkcji oraz jej krótki opis Kolejnym elementem jest budowa funkcji (Usage), która skrótowo opisuje z jakich argumentów składa się dana funkcja. Np. funkcja mean() przyjmuje argument x, trim, oraz na.rm. Dla argumentów trim oraz na.rm są także ustalone ich domyślne wartości. Dodatkowo, widoczny jest argument w postaci wielokropka (...). Argumenty funkcji są również wypisane oraz skrótowo wyjaśnione. Przykładowo, x musi być obiektem R o typie numerycznym (który łączy typ liczb całkowitych i zmiennoprzecinkowych), logicznym, date, date-time, lub time interval. Część Value (lub Details) opisuje szczegóły wykonywanej funkcji Inne możliwe elementy to np. References odnoszący się do artykułu czy książki opisującej daną funkcję lub metodę, czy też See also zawierający odnośniki do innych, podobnych funkcji Jeden z najważniejszych elementów pliku pomocy znajduje się na samym końcu - są to przykłady (Examples). Jeżeli nie jesteśmy pewni jak dana funkcja działa warto zacząć od skopiowania przykładów a następnie ich wykonania. Czytanie dokumentacji wymaga pewnej wprawy i doświadczenia. Nie bój się używać innych źródeł pomocy (zobacz sekcję 2.4), jeżli potrzebujesz zrozumieć działanie danej funkcji. 3.5 Pakiety Pakiet to zorganizowany zbiór funkcji, który rozszerza możliwości R. Pakiety oprócz kodu zawierają szereg dodatkowych istotnych elementów, takich jak: Informacja o wersji pakietu, jego twórcach, zależnościach, czy licencji Dokumentacja Przykładowe dane Testy kodu Pakiety R mogą być przechowywane i instalowane z wielu miejsc w internecie. Istnieje jednak jedno centralne repozytorium (CRAN, ang. the Comprehensive R Archive Network), które zawiera oficjalne wersje pakietów R. Wersje deweloperskie (rozwojowe) często można znaleźć na platformie GitHub. Do instalacji pakietu w R z repozytorium CRAN służy wbudowana funkcja install.packages(), np: install.packages(&quot;stringr&quot;) #instalacja pakietu stringr Zainstalowanie pakietu w R z platformy GitHub jest możliwe używając, np. funkcji install_github() z pakietu remotes. # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;r-lib/remotes&quot;) Podobnie jak instalowanie programów na komputerze - zainstalowanie pakietu odbywa się tylko jeden raz. Istnieją dwa główne formy, w których rozpowszechniane są pakiety R - postać źródłowa (ang. source packages) i postać binarna (ang. binary packages). Postać źródłowa zawiera kod źródłowy pakietu, który musi zostać następnie skompilowany na komputerze użytkownika. Skompilowanie pakietu na podstawie kodu źródłowego może wymagać posiadania odpowiednich bibliotek na komputerze, np. Rtools dla systemu Windows czy też narzędzia Xcode dla Mac OS. Dodatkowo, instalacja w ten sposób zabiera więcej czasu. Postać binarna została już wcześniej skompilowana na zewnętrznym komputerze (np. w repozytorium CRAN) Jest ona dostępna dla systemów Windows i Mac OS. Niestety, nie wszystkie pakiety (lub ich wersje) posiadają postać binarną i wymagana jest ich kompilacja. Użycie wybranego pakietu wymaga dołączenia go do R za pomocą funkcji library(). Dołączenie wybranych pakietów do R robimy po każdym uruchomieniu R. library(stringr) str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; Error in str_sub(&quot;chronologia&quot;, start = 1, end = 6) : #&gt; could not find function &quot;str_sub&quot; 3.6 Tworzenie skryptów Skrypt w R to plik testowy z rozszerzeniem .R, który zawiera szereg linii kodu w celu uzyskania konkretnego efektu. Może on zawierać zaledwie kilka jak i setki linii kodu w zależności od złożoności postawionego problemu. Zobaczmy jak wyglądają skrypty na prostym przykładzie - przeliczania wartości ze skali Fahrenheita na skalę Celsjusza. Otrzymaliśmy informację, że w “mieście A” temperatura w stopniach Fahrenheita wynosi 75. miasto_a = 75 Pierwszym naszym krokiem powinno być dowiedzenie się jaka jest relacja pomiędzy skalą Fahrenheita na skalą Celsjusza. \\[T_{Celsjusz} = \\frac{T_{Fahrenheit} - 32}{1.8}\\] Następnie powyższy wzór można przepisać do postaci kodu w języku R oraz podstawić do niego wartość temperatury w stopniach Fahrenheita w mieście A. Ostatnim etapem jest wyświetlenie uzyskanego wyniku - temperatura w mieście A wynosi ok. 24 stopnie Celsjusza. miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Powyższe kroki można również zapisać do pliku tekstowego. # plik przeliczanie-temp.R miasto_a = 75 miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Co można zrobić jeżeli mamy więcej podobnych pomiarów, które chcemy wykonać? Najprostszą opcją jest użycie kopiuj/wklej i powielenie tego samego kodu, a później naniesienie małych zmian, np. nazw obiektów. miasto_a = 75 miasto_b = 110 miasto_c = 0 miasto_a_c = (miasto_a - 32) / 1.8 miasto_b_c = (miasto_b - 32) / 1.8 miasto_c_c = (miasto_c - 32) / 1.8 Powyższe podejście jest poprawne, ale ma ono kilka wad: Łatwo jest o popełnie jakiegoś prostego błędu lub literówki podczas adaptacji kodu (np. można zapomnieć zmienić nazwę jakiejś zmiennej) Jeżeli obliczenia zajmują więcej niż kilka linii kodu - wówczas kopiowanie go znacznie powiększa tworzony skrypt i utrudnia jego czytelność Poprawienie kodu w przypadku zauważenia błędu w procedurze obliczeniowej jest czasochłonne To podejście jest też niezgodne z jedną z najważniejszych reguł w programowaniu - regułą DRY (Nie powtarzaj się, ang. Don’t Repeat Yourself). Zamiast tworzenia skryptu w oparciu o kopiuj/wklej lepiej pomyśleć nad zbudowaniem odpowiedniej funkcji21. 3.7 Budowanie funkcji Funkcje pozwalają na automatyzację często używanych obliczeń. Formalnie funkcje składają się z trzech elementów: listy argumentów (ang. formals), ciała funkcji (ang. body) oraz środowiska (ang. environment). Pierwsze dwa elementy ustala twórca funkcji, natomiast środowisko jest określane na podstawie tego, gdzie dana funkcja została zdefiniowana. Dodatkowo każda funkcja ma swoją nazwę. moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Lista argumentów wymienia obiekty wejściowe funkcji. formals(moja_funkcja) #&gt; $x #&gt; #&gt; #&gt; $y #&gt; #&gt; #&gt; $z Ciało zawiera kod danej funkcji. body(moja_funkcja) #&gt; { #&gt; pod = y/z #&gt; wynik = x * pod #&gt; wynik #&gt; } Środowisko określa, gdzie dana funkcja jest zlokalizowana. environment(moja_funkcja) #&gt; &lt;environment: R_GlobalEnv&gt; Przykładowa funkcja odpowiadająca problemowi z poprzedniej sekcji może wyglądać w poniższy sposób: konwersja_temp = function(temperatura_f){ (temperatura_f - 32) / 1.8 } Nowa funkcja nazywa się konwersja_temp() oraz posiada tylko jeden argument temperatura_f. Ciało funkcji zawiera natomiast wzór potrzebny do obliczeń przepisany do R. Ważne jest to, że obiekt użyty wewnątrz funkcji (temperatura_f) jest taki sam jak wejściowy argument. Po stworzeniu funkcji warto sprawdzić czy jej działanie odpowiada naszym oczekiwaniom. konwersja_temp(75) #&gt; [1] 23.9 konwersja_temp(110) #&gt; [1] 43.3 konwersja_temp(0) #&gt; [1] -17.8 konwersja_temp(c(0, 75, 110)) #&gt; [1] -17.8 23.9 43.3 3.7.1 Komunikaty Oprócz wyniku danej operacji R może wyświetlić kilka rodzajów wiadomości. 3.8 Zadania Zobacz jak wygląda plik pomocy funkcji mean(). Wykonaj zawarte w nim przykłady. Co zostało w nich wykonane? Niektóre zbiory danych również posiadają swoje pliki pomocy.↩ Grolemund and Wickham (2016) radzą używać funkcje, gdy ten sam kod potwarza się co najmniej trzy razy.↩ "],
["warunki.html", "4 Wyrażenia warunkowe 4.1 Warunki 4.2 Warunki zagnieżdzone 4.3 Operatory porównania 4.4 Wyrażenia warunkowe w funkcjach 4.5 Zadania", " 4 Wyrażenia warunkowe Języki programowania opierają się o dwa podstawowe narzędzia pozwalające na sterowanie przepływem operacji. Są to wyrażenia warunkowe oraz pętle. Wyrażenia warunkowe są głównym tematem tego rozdziału, natomiast pętle są omówione w rozdziale 8. Celem wyrażeń warunkowych jest wykonywanie różnego kodu w zależności od danych wejściowych. 4.1 Warunki Wyrażenie if opiera się o spełnienie (lub niespełnienie) danego warunku. if (warunek){ jeżeli warunek spełniony to wykonaj operację } temperatura = 5.4 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } #&gt; [1] &quot;Dodatnia&quot; temperatura = -11 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } Warunek if można też tworzyć w uproszczonej formie: if (warunek) spelniony else niespelniony 4.2 Warunki zagnieżdzone Działanie wyrażenia if może być połączone z dodatkowymi wyrażeniami else if oraz else. temperatura = 8.8 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } else if (temperatura &lt; 0) { &quot;Ujemna&quot; } else { &quot;Zero&quot; } #&gt; [1] &quot;Dodatnia&quot; 4.3 Operatory porównania Tabela 4.1: Operatory porównania Operator Wyjaśnienie == Równy != Nie równy %in% Zawiera się w &gt;, &lt; Większy/Mniejszy niż &gt;=, &lt;= Większy/Mniejszy niż lub równy Tabela 4.2: Operatory porównania Operator Wyjaśnienie ! Negacja (nie) &amp;&amp; Koniunkcja (i) || Alternatywa (lub) 4.4 Wyrażenia warunkowe w funkcjach pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.\\n&quot;)) if (temperatura &lt; 5){ cat(&quot;Ubierz się ciepło!&quot;) } } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. #&gt; Ubierz się ciepło! pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. 4.5 Zadania "],
["proste-obiekty.html", "5 Proste obiekty 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów 5.3 Wektory 5.4 Właściwości wektorów 5.5 Podstawowe funkcje 5.6 Brakujące wartości 5.7 Wydzielanie 5.8 Wydzielanie i przypisanie 5.9 Modyfikowanie obiektów 5.10 … 5.11 Zadania", " 5 Proste obiekty Więcej informacji na temat podstawowych typów obiektów można znaleźć w rozdziale “Vectors” książki Advanced R (Wickham 2014). 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów Obiekty w R można podzielić na proste (homogeniczne) i złożone (heterogeniczne). Do podstawowych prostych obiektów należą wektory (ang. vector) i macierze (ang. matrix), natomiast listy (ang. list) i ramki danych (ang. data frame) to obiekty złożone. W tym rozdziale skupimy się na wektorach. Pozostałe podstawowe typy obiektów są omówione w rozdziale 7. 5.3 Wektory Wektor może przyjmować jeden z czterech podstawowych typów22: logiczny (ang. logical) wek_log = c(TRUE, FALSE) wek_log #&gt; [1] TRUE FALSE liczba całkowita (ang. interger) wek_cal = c(5L, -7L) wek_cal #&gt; [1] 5 -7 liczba zmiennoprzecinkowa (ang. double)23 wek_zmi = c(5.3, -7.1) wek_zmi #&gt; [1] 5.3 -7.1 znakowy (ang. character) wek_zna = c(&quot;kot&quot;, &quot;pies&quot;) wek_zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; Dodatkowo, istnieją dwa dodatkowe, rzadziej spotykane typy wektorów - czynnikowy (ang. factor) i dat (ang. date). 5.4 Właściwości wektorów Każdy wektor ma trzy właściwości - typ, długość i atrybuty. # typ typeof(wek_zmi) #&gt; [1] &quot;double&quot; # długość length(wek_zmi) #&gt; [1] 2 # atrybuty attributes(wek_zmi) #&gt; NULL 5.5 Podstawowe funkcje str(wek_zmi) #&gt; num [1:2] 5.3 -7.1 names(wek_zmi) #&gt; NULL names(wek_zmi) = c(&quot;a&quot;, &quot;b&quot;) wek_zmi #&gt; a b #&gt; 5.3 -7.1 names(wek_zmi) #&gt; [1] &quot;a&quot; &quot;b&quot; rep(wek_zmi, 4) #&gt; a b a b a b a b #&gt; 5.3 -7.1 5.3 -7.1 5.3 -7.1 5.3 -7.1 seq(1, 12, by = 2) #&gt; [1] 1 3 5 7 9 11 5.6 Brakujące wartości Wyobraź sobie, że wykonujesz codziennie o 12:00 pomiar temperatury. temperatura = c(8.2, 10.3, 12.0) Czwartego dnia twój termometr się popsuł i nie można było wykonać pomiaru. Co należałoby w takim razie zrobić? Możnaby pominąć ten pomiar, naprawić termometr i wykonać pomiar kolejnego dnia. Wówczas jednak mielibyśmy cztery wartości dla pięciu dni. Inną możliwą opcją byłoby użycie wartości, która stałaby się kodem wartości brakujących, np. 999. Problemem tego rozwiązania jest to w jaki sposób należałoby, np. wyliczyć średnią w tym obiekcie. temperatura = c(8.2, 10.3, 12.0, 999) Najlepszą opcją byłoby wykorzystanie wbudowanego oznaczenia wartości brakujących w R - NA. temperatura = c(8.2, 10.3, 12.0, NA) 5.7 Wydzielanie R posiada trzy podstawowe operatory wydzielania (ang. subsetting) - [], [[]] oraz $, które działają w różny sposób w zależności od tego czy wydzielamy wektory, macierze, ramki danych czy listy. W tym rozdziale skupimy się na wydzielaniu elementów z wektora przy użyciu operatora []. Więcej na temat wydzielania innych obiektów można znaleźć w rozdziale 7. Wydzielanie wektorów używając operatora [] może odbywać się używając jednego z poniższych zapytań: Na podstawie pozycji Na podstawie wektora logicznego Na podstawie nazwy Używając elementu pustego Używając zera temperatura[c(1, 3)] #&gt; [1] 8.2 12.0 temperatura[-c(2, 4)] #&gt; [1] 8.2 12.0 temperatura[c(TRUE, FALSE, TRUE, FALSE)] #&gt; [1] 8.2 12.0 temperatura[temperatura &gt; 10] #&gt; [1] 10.3 12.0 NA names(temperatura) = c(&quot;Poniedziałek&quot;, &quot;Wtorek&quot;, &quot;Środa&quot;, &quot;Czwartek&quot;) temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[c(&quot;Wtorek&quot;, &quot;Czwartek&quot;)] #&gt; Wtorek Czwartek #&gt; 10.3 NA temperatura[] #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[0] #&gt; named numeric(0) 5.8 Wydzielanie i przypisanie 5.9 Modyfikowanie obiektów 5.9.1 Łączenie podstawowych typów obiektów c(temperatura, temperatura) #&gt; Poniedziałek Wtorek Środa Czwartek Poniedziałek #&gt; 8.2 10.3 12.0 NA 8.2 #&gt; Wtorek Środa Czwartek #&gt; 10.3 12.0 NA Właściwością wektora jest to, że może on przyjmować tylko jeden typ. Próba stworzenia obiektu składającego się z wielu typów spowoduje wymuszenie (ang. coercion) do najbliższego możliwego typu. Odbywa się to zgodnie z zasadą: logiczny -&gt; liczba całkowita -&gt; liczba zmiennoprzecinkowa -&gt; znakowy. FALSE #&gt; [1] FALSE c(FALSE, 0L) #&gt; [1] 0 0 c(FALSE, 0L, 3.1) #&gt; [1] 0.0 0.0 3.1 c(FALSE, 0L, 3.1, &quot;kot&quot;) #&gt; [1] &quot;FALSE&quot; &quot;0&quot; &quot;3.1&quot; &quot;kot&quot; 5.10 … 5.10.1 Zmiana typów obiektów Do zmiany typu obiektu służą funkcje as.logical(), as.integer(), as.double(), oraz as.character()24. as.logical(c(&quot;FALSE&quot;, &quot;TRUE&quot;)) # znakowy na logiczny #&gt; [1] FALSE TRUE as.integer(c(&quot;3&quot;, &quot;2&quot;)) # znakowy na liczba całkowita #&gt; [1] 3 2 as.double(c(3L, 2L)) # liczba całkowita na liczba zmiennoprzecinkowa #&gt; [1] 3 2 as.character(c(3L, 2L)) # liczba całkowita na znakowy #&gt; [1] &quot;3&quot; &quot;2&quot; 5.11 Zadania Bibliografia "],
["tekst.html", "6 Tekst 6.1 Łączenie tekstu 6.2 Postawowe operacje na tekście 6.3 Wydzielanie tekstu 6.4 Wyrażenia regularne 6.5 Wyrażenia regularne (wydzielanie tekstu) 6.6 Wyrażenia regularne (zamiana tekstu) 6.7 Wyszukiwanie plików 6.8 Zadania", " 6 Tekst Więcej na temat przetwarzania tekstu można znaleźć w rozdziale “Strings” książki R for Data Science (Grolemund and Wickham 2016). Typ znakowy jest określany poprzez użycie cudzysłowia &quot; lub '. Ważne tutaj jest, aby rozpoczynać i kończyć tekst tym samym cudzysłowiem. t1 = &quot;kot&quot; t2 = &#39;pies&#39; t3 = &#39;&quot;W teorii, teoria i praktyka są tym samym. W praktyce, nie są.&quot; - Yogi Berra&#39; W momencie, gdy tekst nie będzie kończył się cudzysłowiem, wykonanie kodu jest niemożliwe. Wówczas zamiast znaku &gt;, oznaczającego nową linię wykonywanego kodu, pojawi się znak +. Oznacza on, że wykonanie kodu nie może zostać zakończone. &gt; &quot;Mój pierwszy alfabet + + W takiej sytuacji należy nacisnąć klawisz Esc, aby przerwać wykonywanie operacji, a następnie poprawić wpisany kod. 6.1 Łączenie tekstu paste(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;t o k o t&quot; paste0(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;to kot&quot; imie = &quot;Olek&quot; wiek = 7 tekst1 = paste(imie, &quot;ma&quot;, wiek, &quot;lat.&quot;) tekst1 #&gt; [1] &quot;Olek ma 7 lat.&quot; 6.2 Postawowe operacje na tekście library(stringr) toupper(tekst1) #&gt; [1] &quot;OLEK MA 7 LAT.&quot; tolower(tekst1) #&gt; [1] &quot;olek ma 7 lat.&quot; tekst2 = c(&quot;chronologia&quot;, &quot;alfabet&quot;, &quot;hałas&quot;) str_sort(tekst2, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; str_sort(tekst2, locale = &quot;cs&quot;) #&gt; [1] &quot;alfabet&quot; &quot;hałas&quot; &quot;chronologia&quot; tekst3 = c(&quot;chronologia &quot;, &quot;alfabet&quot;, &quot; hałas&quot;) str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot; hałas&quot; &quot;alfabet&quot; &quot;chronologia &quot; tekst3 = str_trim(tekst3) tekst3 #&gt; [1] &quot;chronologia&quot; &quot;alfabet&quot; &quot;hałas&quot; str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; 6.3 Wydzielanie tekstu str_sub(tekst1, start = 1, end = 4) #&gt; [1] &quot;Olek&quot; str_sub(tekst1, start = 9, end = 14) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = 9, end = -1) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = -6, end = -1) #&gt; [1] &quot;7 lat.&quot; 6.4 Wyrażenia regularne Wyrażenia regularne (ang. regular expressions), często określane jako regex to sposób opisywanie wzorców tekstu. Używając wyrażeń regularnych możliwe jest, między innymi, znajdowanie tekstu lub zamienienie, który spełnia wymagane warunki. Wyrażenia regularne są powszechnie używane w wyszukiwarkach internetowych, edytorach tekstu, oraz wielu językach programowania. tekst4 = c(&quot;Magdalena&quot;, &quot;Lena&quot;, &quot;1Lena.csv&quot;, &quot;LLena&quot;, &quot;Helena&quot;, &quot;Anna&quot;, 99) str_detect(tekst4, &quot;Lena&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, &quot;lena&quot;) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE Tabela 6.1: Metaznaki w wyrażeniach regularnych Operator Wyjaśnienie ^ Określa początek tekstu/linii $ Określa koniec testu/linii () Grupowanie | Alternatywa (lub) [] Wymienia dozwolone znaki [^] Wymienia niedozwolone znaki * Poprzedni znak zostanie wybrany zero lub więcej razy + Poprzedni znak zostanie wybrany jeden lub więcej razy ? Poprzedni znak zostanie wybrany zero lub jeden raz {n} Poprzedni znak zostanie wybrany n razy . Jakikolwiek znak oprócz nowej linii () \\ Pozwala na użycie specjalnych znaków Wymienione powyżej znaki (np. ^ czy .) określane są jako metaznaki (ang. metacharacters) i mają one specjalne znaczenie. W związku z tym, jeżeli chcemy wyszukać tekstu zawierającego specjalny znak, musimy użyć ukośnik wsteczny (\\, ang. backslash). Istnieje wiele dodatkowych znaków specjalnych, np. \\n - nowa linia, \\t - tabulator, \\d - każdy znak numeryczny (stałoprzecinkowy), \\s - znak niedrukowalny, np. spacja, tabulator, nowa linia. str_detect(tekst4, pattern = &quot;^L&quot;) #&gt; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;ena$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE FALSE FALSE str_detect(tekst4, pattern = &quot;(ena|nna)$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[a-zA-Z]&quot;) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[0-9]&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE str_detect(tekst4, pattern = &quot;L+&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;^[^L]+&quot;) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE &gt;str_detect(tekst4, pattern = &quot;\\.&quot;) #&gt; Error: &#39;\\.&#39; is an unrecognized escape in character string starting &quot;&quot;\\.&quot; str_detect(tekst4, pattern = &quot;\\\\.&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE # str_detect(tekst4, pattern = &quot;&quot;) y = c(&quot;kołdra&quot;, &quot;kordła&quot;, &quot;pościel&quot;) str_detect(y, pattern = &quot;ko(łdr|rdł)a&quot;) 6.5 Wyrażenia regularne (wydzielanie tekstu) # str_extract() 6.6 Wyrażenia regularne (zamiana tekstu) # str_replace() Umiejętności używania wyrażeń regularnych można trenować używając różnych zasobów internetowych, np. strony https://regexr.com/ lub https://regex101.com/. 6.7 Wyszukiwanie plików 6.8 Zadania Bibliografia "],
["zlozone-obiekty.html", "7 Złożone obiekty 7.1 Macierze 7.2 Ramki danych 7.3 Listy 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania", " 7 Złożone obiekty 7.1 Macierze Macierze (ang. matrix), podobnie jak wektory, są obiektami homogenicznymi - jedna macierz może przyjmować dane tylko jednego typu. 7.1.1 Tworzenie macierz1 = matrix(1:12, ncol = 3, nrow = 4) macierz1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 macierz2 = matrix(1:12, ncol = 3, nrow = 4, byrow = TRUE) macierz2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 7.1.2 Podstawowe funkcje class(macierz2) #&gt; [1] &quot;matrix&quot; str(macierz2) #&gt; int [1:4, 1:3] 1 4 7 10 2 5 8 11 3 6 ... typeof(macierz2) #&gt; [1] &quot;integer&quot; ncol(macierz2) #&gt; [1] 3 nrow(macierz2) #&gt; [1] 4 colnames(macierz2) #&gt; NULL colnames(macierz2) = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) macierz2 #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 colnames(macierz2) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 7.1.3 Wydzielanie Podobnie jak w przypadku wektorów (5), macierze można wydzielać używając operatora []. W tym wypadku odbywa się to jednak na w oparciu o dwa indeksy - jeden dla wiersza, drugi dla kolumny - [wiersz, kolumna]. macierz2[c(1, 2), c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 macierz2[c(1, 2), ] #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 macierz2[, c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(TRUE, FALSE, TRUE)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(&quot;a&quot;, &quot;c&quot;)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 7.1.4 Łączenie macierz3 = cbind(macierz1, macierz2) macierz3 #&gt; a b c #&gt; [1,] 1 5 9 1 2 3 #&gt; [2,] 2 6 10 4 5 6 #&gt; [3,] 3 7 11 7 8 9 #&gt; [4,] 4 8 12 10 11 12 macierz4 = rbind(macierz1, macierz2) macierz4 #&gt; a b c #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [5,] 1 2 3 #&gt; [6,] 4 5 6 #&gt; [7,] 7 8 9 #&gt; [8,] 10 11 12 7.2 Ramki danych Ramki danych (ang. data frame) mają dużo podobieństw z macierzami. Są to obiekty dwuwymiarowe, składające się z kolumn i wierszy. Główną różnicą pomiędzy macierzą a ramką danych jest to, że pierwsza z nich przyjmuje tylko dane jednego typu, podczas gdy druga może się składać z danych róznych typów. Ramka danych jest zbudowana z kolumn (wektorów) o równej długości. 7.2.1 Tworzenie ramka1 = data.frame(wek_log = c(TRUE, FALSE, FALSE), wek_cal = c(5L, -7L, 12L), wek_zmi = c(5.3, -7.1, 1.1), wek_zna = c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;), stringsAsFactors = FALSE) ramka1 #&gt; wek_log wek_cal wek_zmi wek_zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.2 Podstawowe funkcje class(ramka1) #&gt; [1] &quot;data.frame&quot; str(ramka1) #&gt; &#39;data.frame&#39;: 3 obs. of 4 variables: #&gt; $ wek_log: logi TRUE FALSE FALSE #&gt; $ wek_cal: int 5 -7 12 #&gt; $ wek_zmi: num 5.3 -7.1 1.1 #&gt; $ wek_zna: chr &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; ncol(ramka1) #&gt; [1] 4 nrow(ramka1) #&gt; [1] 3 colnames(ramka1) #&gt; [1] &quot;wek_log&quot; &quot;wek_cal&quot; &quot;wek_zmi&quot; &quot;wek_zna&quot; colnames(ramka1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) ramka1 #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec colnames(ramka1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.2.3 Wydzielanie Do wydzielania elementów z ramki danych może służyć, między innymi, operator $, operator [] oraz funkcja subset(). Operator $ pozwala na wybranie zmiennej (kolumny) na podstawie jej nazwy. ramka1$zmi #&gt; [1] 5.3 -7.1 1.1 ramka1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; W przypadku ramek danych operator [] wymaga podania dwóch argumentów - jednego dla wierszy (obserwacji) oraz jednego dla kolumn (zmiennych) - [wiersze, kolumny]. ramka1[c(1, 3), c(1, 2)] #&gt; log cal #&gt; 1 TRUE 5 #&gt; 3 FALSE 12 Do wydzielania można też wykorzystać operatory logiczne: ==, %in%, !=, &gt;, &gt;=, &lt;, &lt;=, &amp;, |. ramka1[c(1, 3), ramka1$zmi &gt; 0] #&gt; log zmi zna #&gt; 1 TRUE 5.3 kot #&gt; 3 FALSE 1.1 nosorożec ramka1[ramka1$zna == &quot;kot&quot;, ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot ramka1[ramka1$zna %in% c(&quot;kot&quot;, &quot;pies&quot;), ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies ramka1[ramka1$cal &gt; 6 | ramka1$cal &lt; -6, ] #&gt; log cal zmi zna #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.4 Łączenie ramka2 = data.frame(zmi2 = c(4.3, 2.6, 7.4)) ramka2 #&gt; zmi2 #&gt; 1 4.3 #&gt; 2 2.6 #&gt; 3 7.4 cbind(ramka1, ramka2) #&gt; log cal zmi zna zmi2 #&gt; 1 TRUE 5 5.3 kot 4.3 #&gt; 2 FALSE -7 -7.1 pies 2.6 #&gt; 3 FALSE 12 1.1 nosorożec 7.4 ramka3 = data.frame(log = TRUE, cal = 2L, zmi = 2.3, zna = &quot;żółw&quot;) ramka3 #&gt; log cal zmi zna #&gt; 1 TRUE 2 2.3 żółw rbind(ramka1, ramka3) #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec #&gt; 4 TRUE 2 2.3 żółw 7.3 Listy 7.3.1 Tworzenie lista1 = list(c(TRUE, FALSE), c(5L, -7L), c(5.3), c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;)) lista1 #&gt; [[1]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]] #&gt; [1] 5 -7 #&gt; #&gt; [[3]] #&gt; [1] 5.3 #&gt; #&gt; [[4]] #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.2 Podstawowe funkcje class(lista1) #&gt; [1] &quot;list&quot; str(lista1) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:2] 5 -7 #&gt; $ : num 5.3 #&gt; $ : chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; length(lista1) #&gt; [1] 4 names(lista1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) lista1 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; names(lista1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.3.3 Łączenie lista2 = c(lista1, lista1) lista2 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista3 = list(lista1, lista1) lista3 #&gt; [[1]] #&gt; [[1]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[1]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[1]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[1]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[2]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[2]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.4 Wydzielanie lista4 = lista1[c(1, 2)] str(lista4) #&gt; List of 2 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 lista5 = lista1[[c(4)]] str(lista5) #&gt; chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista6 = lista3[[c(2)]] str(lista6) #&gt; List of 4 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1[c(&quot;zmi&quot;, &quot;zna&quot;)] #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania "],
["petle.html", "8 Powtarzanie 8.1 Pętla for 8.2 Pętla while 8.3 Programowanie funkcyjne 8.4 Zadania", " 8 Powtarzanie 8.1 Pętla for for (element in wektor) { przetwarzanie elementu } odl_mile = c(142, 63, 121) for (i in odl_mile) { print(i * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 for (i in 1:3) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_mile[i] = odl_mile[i] * 1.609 } odl_mile #&gt; [1] 228 101 195 odl_km = vector(&quot;numeric&quot;, length = 0) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km = c(odl_km, odl_mile[i] * 1.609) } odl_km #&gt; [1] 368 163 313 odl_mile = c(142, 63, 121) odl_km = vector(&quot;numeric&quot;, length = length(odl_mile)) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km[i] = odl_mile[i] * 1.609 } odl_km #&gt; [1] 228 101 195 8.2 Pętla while 8.3 Programowanie funkcyjne 8.4 Zadania "],
["io.html", "9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy 9.2 Zadania", " 9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy Folder roboczy (ang. working directory) to miejsce na dysku, w którym aktualnie pracujemy. Folder roboczy można sprawdzić korzystając z funkcji getwd(): getwd() #&gt; [1] &quot;/home/travis/build/Nowosad/elp&quot; Zmienić folder roboczy można za pomocą skrótu Ctrl+Shift+H w RStudio (inaczej Session -&gt; Set Working Directory -&gt; Choose Directory..) lub też funkcji setwd(): setwd(&quot;home/jakub/Documents/progr/&quot;) #unix setwd(&quot;C:/Users/jakub/Documenty/progr/&quot;) #windows Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki. Znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami. Ścieżka względna … Ścieżka bezwzględna … 9.2 Zadania "],
["zlozone-funkcje.html", "10 Złożone funkcje 10.1 API 10.2 Obsługa błędów 10.3 Zadania", " 10 Złożone funkcje 10.1 API 10.2 Obsługa błędów 10.3 Zadania "],
["analiza-kodu.html", "11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie", " 11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie "],
["kontrola-wersji.html", "12 Kontrola wersji 12.1 Git 12.2 Git w RStudio 12.3 GitHub 12.4 Zadania", " 12 Kontrola wersji 12.1 Git 12.2 Git w RStudio 12.3 GitHub 12.4 Zadania "],
["tworzenie-pakietow.html", "13 Tworzenie pakietów 13.1 Rozwijanie pakietu 13.2 Dokumentacja funkcji 13.3 Zależności 13.4 Dokumentacja pakietu 13.5 Testy jednostkowe 13.6 Licencje 13.7 Publikowanie pakietów 13.8 Zadania", " 13 Tworzenie pakietów Funkcja create_packages() tworzy cztery pliki: .Rproj R/ DESCRIPTION NAMESPACE 13.1 Rozwijanie pakietu 13.2 Dokumentacja funkcji 13.3 Zależności 13.4 Dokumentacja pakietu 13.5 Testy jednostkowe 13.6 Licencje 13.7 Publikowanie pakietów software documentation software promotion Continuous Integration 13.8 Zadania "],
["lacznik.html", "14 Łącznik 14.1 Zadania", " 14 Łącznik 14.1 Zadania "],
["debugging.html", "15 Debugowanie 15.1 Zadania", " 15 Debugowanie 15.1 Zadania "],
["podsumowanie.html", "16 Podsumowanie", " 16 Podsumowanie "],
["bibliografia.html", "Bibliografia", " Bibliografia "]
]
