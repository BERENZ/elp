[
["index.html", "Elementarz programisty Wstęp do programowania używając R O książce Wymagania wstępne Styl książki Podziękowania", " Elementarz programisty Wstęp do programowania używając R Jakub Nowosad 2019-04-07 O książce Aktualna wersja książki znajduje się pod adresem https://nowosad.github.io/elp/. Jeżeli używasz tej książki, zacytuj ją jako: Nowosad, J., (2019). Elementarz programisty: wstęp do programowania używając R. Poznań: Space A. Online: https://nowosad.github.io/elp/ Zachęcam również do zgłaszania wszelkich uwag, błędów, pomysłów oraz komentarzy na stronie https://github.com/nowosad/elp/issues. Ta książka jest dostępna na licencji Creative Commons Uznanie autorstwa - Użycie niekomercyjne - Bez utworów zależnych 4.0 Międzynarodowe. Wymagania wstępne Do odtworzenia przykładów oraz do wykonania zadań zawartych w tej książce konieczne jest posiadanie aktualnej wersji R. Pod adresem https://cloud.r-project.org/ można znaleźć instrukcje instalacji R dla systemów Windows, Mac OS i Linux. W niektórych rodziałach użyte zostanie zintegrowane środowisko programistyczne RStudio. Można je zainstalować korzystając ze strony https://www.rstudio.com/products/rstudio/download/#download. Aspekty dotyczące kontroli wersji zostaną omówione używając oprogramowania Git. Zalecanym sposobem installacji Git na Windows jest wersja ze strony https://gitforwindows.org/. Instrukcja instalacji na system Mac OS znajduje się pod adresem https://happygitwithr.com/install-git.html#macos. Wersję Linuxową można zainstalować używając poniższej linii kodu: # Ubuntu sudo apt install git # Fedora sudo dnf install git Styl książki W całej książce stosowana jest konwencja, w której fun() oznacza funkcje, obi oznacza nazwy obiektów, nazwy zmiennych oraz argumentów funkcji, a sci/ oznacza ścieżki do plików. Wszystkie pakiety użyte w tej książce oznaczane są pogrubioną czcionką - pak. Tekst na szarym tle przedstawia blok kodu. Może on zawierać komentarze (rozpoczynające się of znaku #), kod oraz wynik jego użycia (rozpoczynające się od znaków #&gt;). # komentarz kod #&gt; wynik użycia kodu Dodatkowo, ikona kompasu na szarym tle przedstawia dodatkowe informacje, alternatywne sposoby użycia funkcji, czy też wskazówki. Tutaj może znaleźć się dodatkowa informacja, alternatywny sposób użycia funkcji, czy też wskazówka. Podziękowania Książka została stworzona w R (R Core Team 2018) z wykorzystaniem pakietów bookdown (Xie 2018), rmarkdown (Allaire et al. 2019), knitr (Xie 2019) oraz programu Pandoc. Użyte ikony zostały stworzone przez Freepik z www.flaticon.com na licencji CC 3.0 BY. Bibliografia "],
["wprowadzenie.html", "1 Wprowadzenie 1.1 Mity programistyczne 1.2 Języki programowania 1.3 R 1.4 Zadania", " 1 Wprowadzenie Żyjemy obecnie w epoce trzeciej rewolucji przemysłowej1, zwanej inaczej rewolucją cyfrową. Jest ona powiązana z przejściem z technologii mechanicznych i analogowych na technologie elektroniczne i cyfrowe. W tej epoce nastąpiło stworzenie i rozpowszechnieniem się komputerów, co w efekcie spowodowało szerokie zmiany społeczno-ekonomiczne. Wiele z tych zmian jest pozytywnych, ale istnieją również zmiany negatywne, bądź też takie które trudno jednoznacznie ocenić. Przykładowo, wyraźną korzyścią społeczną jest znacznie ułatwiony dostęp do informacji. Jednocześnie taki dostęp powoduje sytuację określaną jako przeciążenie informacją (ang. information overload), w której występuje zbyt wielka ilość informacji aby podjąć właściwą decyzję lub zrozumieć sens danego tematu. Rozwój technologiczny spowodował też transformację produkcji przemysłowej i zmiany gospodarcze. Firmy zajmujące się technologiami informacyjnymi, tj. Microsoft, Apple, czy Google, są obecnie jednymi z najbardziej dochodowych przedsiębiorstw, a twórca platformy Amazon, Jeff Bezos, jest najbogatszym człowiekiem świata2. Wiele z tych technologii nie byłoby możliwych bez programowania. Programowanie, w znacznym uproszczeniu, to proces tworzenia serii instrukcji, które informują komputer jak wykonać pewne zadanie. Ta seria instrukcji jest zazwyczaj zapisywana na komputerze w postaci tekstu w wybranym języku programowania. Co w takim razie powoduje, że programowanie ma tak istotny wpływ na wiele elementów codziennego życia? Programowanie cechuje kilka unikatowych możliwości. Po pierwsze, programowanie i jego efekty można w prosty sposób powielać niemal w nieskończoność. Wcześniej stworzenie pewnego towaru opierało się o ograniczone zasoby, np. ziemia czy surowce naturalne. Nie możliwe było wykucie zbroi raz, a następnie natychmiastowe powielenie jej wiele razy i sprzedanie jej wielu kopii. We współczesnym świecie, jedna aplikacja może być sprzedana (lub rozpowszechniona) wiele razy, a często większy nacisk kładzie się na rozbudowę i ulepszanie istniejących popularnych aplikacji niż tworzenie nowych3. Ułatwia to też budowę nowych rozwiązań na podstawie już istniejących4. Współcześnie programowanie pozwala na wykonywanie trylionów (1018) operacji arytmetycznych na sekundę5. Pozwala to na znaczne zwiększenie wydajności dostępnych rozwiązań, otwiera możliwość praktycznego wykorzystania istniejących idei, lub też tworzenia nowych pomysłów. Inną cechą programowania jest też jego prosta możliwość automatyzacji powtarzanych czynnośći oraz ułatwiona powtarzalność (ang. reproducibility) Posiadając kod źródłowy danego oprogramowania lub skrypt wykonujący analizę danych, możliwe jest odtworzenie tego wyniku przez inną osobę na drugim końcu świata, lub też przez siebie samego po paru miesiącach. Ostatnią cechą programowania jest jego uniwersalność. Jest ono wykorzystywane w transporcie, przemyśle, nauce, rozrywce i wielu innych strefach życia. W efekcie zrozumienie i znajomość języków programowania jest cenną umiejętnością we współczesnym świecie. 1.1 Mity programistyczne Programowanie komputerowe ma obecnie już długą historię - pierwszy język programowania Plankalkül powstał w latach 1943-19456. Fortran, stworzony w roku 1957, jest nadal używany współcześnie do wielu celów, między innymi wymagających dużej wydajności obliczeń hydrologicznych, prognozowania pogody czy modelowania klimatu. Programowanie ewoluowało i nadal ewoluuje wraz z rozwojem dostępności i możliwości komputerów. Pojawiły się nowe pradygmaty programowania oraz wiele nowych języków. W tym samym czasie narosło również wiele mitów dotyczących programowania7. Jednym z mitów jest to, że programowanie polega tylko siedzeniu przed ekranem komputera i wpisywaniu do niego kolejnych linii kodu. Jest to oczywiście istotna część pracy programistycznej, ale prawdopodobnie nie jest ona nawet dominująca w przeciętym dniu programisty. Wcześniej konieczne jest zastanowienie się jaki problem rozwiązujemy oraz zaprojektowanie możliwego rozwiązania tego problemu. Stworzony kod może okazać się być nieprzystępny dla użytkownika, słabo zoptymalizowany, lub nawet błędny. Dlatego też innym ważnym elementem jest testowanie kodu w celu wyłapania potencjalnych problemów. Innym aspektem programowania jest tworzenie dokumentacji. Żaden program nie może zachęcić do siebie użytkowników, jeżeli nie będą oni w stanie zrozumieć jak on działa. Dokumentacja jest też cenna dla twórców programu, szczególnie kiedy konieczne jest użycie czy modyfikacja programu kilka miesięcy po jego ostatnim użyciu. Programy komputerowe są też zazwyczaj w dużej sieci powiązań z już istniejącymi bibliotekami czy oprogramowaniem. Zmiana w tych bibliotekach czy oprogramowaniu może skutkować nie zawsze oczekiwanymi zmianami w stworzonym programie. Częścią programowania jest też utrzymywanie istniejącego kodu źródłowego oraz jego ulepszanie. Programiści do swojej pracy wykorzystują też odpowiednie wspierające ich narzędzia, takie jak edytory kodu źródłowego, debugery, zintegrowane środowiska programistyczne czy systemy kontroli wersji. Mitem również jest przekonanie, że programowanie to męskie zajęcie. Bierze się ono z obecnej na rynku pracy struktury, w której około 75% programistów to mężczyźni a tylko 25% to kobiety. Ta struktura jednak nie jest odzwierciedleniem jakichś wrodzonych umiejętności. Za pierwszego programistę często uważa się Adę Lovelace, angielskiego matematyka i poetkę8. To ona w 1843 opublikowała pierwszy program komputerowy. Jej algorytm do obliczenia liczb Bernoulliego nie został jednak przetestowany, ponieważ urządzenie do tych obliczeń (zwane maszyną analityczną9) nie zostało skonstruowane. Ponad wiek później, gdy istniały już techniczne możliwości tworzenia komputerów, programowanie było uważane za kobiecy zawód10 (Rycina 1.1). Z uwagi na szereg czynników społecznych i historycznych11, w latach 1970 nastąpiło odwrócenie proporcji w tym zawodzie. Obecnie podejmowanych jest szereg inicjatyw, które mają na celu zachęcić kobiety do programowania. Wsród nich można wymienić działania organizacji R-Ladies, PyLadies, czy girls.js. Mit programisty mężczyzny jest też powiązany z wymienionym kilka akapitów niżej mitem samotnego programisty. Rycina 1.1: Margaret Hamilton stojąca w 1969 roku obok wydruków oprogramowania, które on i jej zespół stworzył na potrzeby misji Apollo. Źródło: Wikipedia. Kolejny jest mit wielkiego produktu. Oznacza on, że po nauczeniu się podstaw danego języka programowanie, jest się od razu w stanie stworzyć bardzo złożony program, np. nowy system operacyjny, skomplikowaną aplikację na telefon, czy grę komputerową. W rzeczywistości takie produkty opierają się o tysiące godzin pracy wielu programistów. Dodatkowo, nie są one tworzone od podstaw, ale używając szeregu dostępnych narzędzi, bibliotek i innych rozwiązań. Celem pisania kodu, więc nie powinno być stworzenie od zera bardzo złożonej aplikacji, lecz odpowiednie użycie istniejących rozwiązań. Jednocześnie pisanie złożonego oprogramowania wymaga uzyskania niezbędnego doświadczenia. Mit wielkiego produktu wiąże się również z wymienionym w kolejnym akapicie mitem samotnego programisty. W popkulturze osoba, która potrafi programować spędza czas samotnie, gwałtownie wpisując kolejne linie kodu do komputera w ciemnym pokoju. W rzeczywistości jednak większość profesjonalnych programistów pracuje w zespołach, których członkowie pracują nad różnymi aspektami tego samego problemu. Pisanie programów często wymaga współpracy różnych osób, dlatego też umiejętność pracy w grupie jest coraz istotniejsza. Warto dodać, że współpraca nad pisaniem programów nie musi odbywać się w jednym pokoju czy budynku. Ze względu na charakter takiej pracy i możliwości technologiczne, wiele formalnych i nieformalnych grup pracuje zdalnie nad projektami. Wiele przykładów takich zachowań można znaleźć przyglądając się otwartemu oprogramowaniu (ang. open-source software) na platformie GitHub (np. https://github.com/trending/r). W poprzednim akapicie celowo użyłem stwierdzenia “osoba, która potrafi programować” zamiast “programista”. Jest to kolejny powszechny mit, że każda osoba która potrafi stworzyć program musi od razu zostać pełnoetatowym programistą. Pisanie programów jest narzędziem, które ma wspomóc twórcę w pewnym celu. Jednym z celów może być zostanie profesjonalnym deweloperem stron internetowych, aplikacji mobilnych, gier komputerowych, itd. Nie jest to jednak jedyny cel - programowanie może być, na przykład przydatnym narzędziem w analizie danych12. Umiejętności programistyczne są wykorzystywane przez ekonomistów, biologów, geografów i osób z wielu innych dziedzin. Dodatkowo, podstawowe aspekty programowania są bardzo cenne w zawodach, w których ważna jest częsta współpraca z programistami. Kolejny mitem jest mit programisty geniusza. W tym micie programują tylko osoby, która ma nadludzką pamięć oraz wyróżniającą wiedzę matematyczną. Oczywiście, takie cechy przydają się w programowaniu, ale nie są one wymagane do programowania. W programowaniu częściej od dobrej pamięci przydaje się umiejętność szybkiego znalezienia rozwiązania czy odpowiedzi na problem w internecie. Programista nie musi znać na pamięć setek różnych poleceń i funkcji, ważne że umie je zidentyfikować. Natomiast zamiast głębokiej wiedzy matematycznej do większości zadań programistycznych wystarczy podstawowa znajomość algebry. Z tym mitem wiąże się też inna kwestia - założenia że ten programista geniusz posiadł całą wiedzę programistyczną. Podobnie jak nauka języka obcego, nauka języka programowania wymaga dużo pracy i czasu. Dodatkowo, języki programowania czy techniki programowania zmieniają się znacznie częściej niż języki naturalne, dlatego też częścią programowania jest ciągłe uczenie się. Ostatni mit natomiast mówi o tym, że dla każdego problemu programistycznego istnieje tylko jedno najlepsze rozwiązanie. Jeden problem można zazwyczaj rozwiązać na dziesiątki różnych sposobów. Wynika to z tego, że wiele aspektów programowania opiera się o personalne preferencje, np. wybór danego języka programowania, używanych bibliotek, czy stylu pisania kodu. W efekcie zazwyczaj nie możliwe jest jednoznaczne określenie, które rozwiązanie jest lepsze, szczególnie jeżeli wiele rozwiązań ma podobną wydajność. Istnieje jednak kilka reguł, z którymi zgadza się większość programistów. Pierwsza z nich mówi, że wolny działający kod jest lepszy niż szybki niedziałający kod13. Kolejna opiera się o zasadę DRY (nie powtarzaj się, ang. Don’t Repeat Yourself), zalecającą unikanie różnego rodzaju powtórzeń wykonywanych przy programowaniu, np. używania tych samych fragmentów kodu w wielu miejscach. Ostatnia reguła mówi, żeby tworzyć pisać programy w sposób modularny, czyli taki w którym każda funkcja spełnia tylko jedno i nie więcej zadanie, a złożone funkcje składają się z szeregu prostych funkcji. 1.2 Języki programowania Głównym sposobem przekazywania instrukcji do komputera jest użycie języków programowania. Pozwalają one na precyzyjny zapis zadań, które następnie mają zostać wykonane przez komputer. Języki programowania składają się ze zbioru reguł syntaktycznych (składni) oraz semantyki. Składnia (forma) mówi o tym jakie symbole są dostępne w danym języku oraz jak te symbole mogą być łączone w większe struktury. Semantyka (treść) natomiast definiuje znaczenie poszczególnych symboli. W przeciwieństwie do języków naturalnych, języki programowania wymagają wysokiej precyzji. Mówiąc w języku naturalnym możemy popełnić jakiś błąd (np. gramatyczny czy składniowy) i nadal być łatwo zrozumianym przez otoczenie. Języki programowania nie akceptują takich błędów i nie są w stanie wykonać danego polecenia. Obecnie istnieją tysiące14 języków programowania i każdego roku powstają nowe. Nie ma wśród nich jednego najlepszego, uniwersalnego języka programowania i w najbliższej przyszłości ten stan się nie zmieni. Jest to związane z bardzo szerokim zastosowaniem programowania w wielu dziedzinach czy problemach, które mają od siebie zupełnie różne wymagania. Przykładowe wymagania mogą dotyczyć np. szybkości wykonywanych obliczeń, łatwości pisania kodu, stabilności języka programowania, czy celu obliczeń. Do tego dochodzą również rożne kwestie historyczne i społeczne, jak na przykład preferowanie danego języka programowania przez osoby w danej branży. Obecnie wśród najpopularniejszych języków programowania można wymienić takie języki jak Java, C, Python, C++, Visual Basic .NET, JavaScript, C#, PHP, SQL, Objective-C, język asemblera, Perl, czy R. Języki programowania można podzielić na wiele różnych grup w zależności od przyjętych kryteriów. Poniżej wyjaśnionych jest kilka możliwych podziałów języków programowania. Jednym z nich jest sposób wykonywania kodu - to czy kod w danym języku jest kompilowany czy też interpretowany. Kompilacja kodu (np. C czy Java) polega na jego tłumaczeniu do postaci języka maszynowego. W efekcie zapewnia to wysoką wydajność programu, ale za to kod jest ściśle powiązany z daną platformą sprzętową. Programowanie w językach kompilowanych jest zazwyczaj bardziej złożone i trudniejsze w nich jest odnajdywanie błędów (tzw. debugging). Interpretowane języki programowania, często również nazywane językami skryptowymi, (np. R czy Python) charakteryzuje to, że w momencie uruchomienia kod jest zamieniany na postać zrozumiałą dla komputera i od razu wykonywany. W efekcie można szybko zobaczyć efekt zmian. Wadą tego typu języków jest ich zmniejszona wydajność w porównany do języków kompilowanych. Innym powszechnym podziałem języków programowania jest ich rozróżnianie na podstawie poziomu. Tutaj można wyróżnić języki od niskiego poziomu do wysokiego poziomu. Na najniższym poziomie jest język maszynowy, czyli taki w którym zapis programu wyrażony jest w postaci liczb binarnych. Powyżej są umieszczony jest język asemblera, w którym program jest zapisany poprzez serię instrukcji. Na najwyższym poziomie stawia się języki, które są wspomagane przez kompilator albo interpreter. Języki programowania można też rozróżnić ze względu na paradygmat programowania. Definiuje on w jaki sposób w danym języku wykonywany jest przepływ sterowania czy też jak kod jest organizowany. Dwa podstawowe paradygmaty programowania to programowanie imperatywne i deklaratywne. Programowanie imperatywne (np. Fortran, C) opisuje proces wykonywania kodu jako sekwencję instrukcji zmieniających stan programu. Obejmuje ono inne paradygmaty, jak na przykład programowanie proceduralne czy obiektowe. Programowanie deklaratywne skupia się natomiast na warunkach jakie musi spełniać końcowe rozwiązanie, a nie na sekwencji kroków do jego stworzenia. W skład tej grupy wchodzi, między innymi, programowanie funkcyjne czy matematyczne. Niektóre języki mogą być zaklasyfikowane do kilku paradygmatów. Przykładowo R wspiera zarówno paradygmat funkcyjny, ale zawiera też możliwości programowania obiektowego. 1.3 R W tej książce wprowadzenie do programowania opiera się o język R (Rycina 1.2). Rycina 1.2: Logo języka programowania R. Wynika to z szeregu zalet tego języka: R jest bezpłatnym, otwartym oprogramowaniem, który można uruchomić na różnych systemach operacyjnych (Windows, Mac OS i Linux), zarówno na komputerach osobistych jak i na dużych klastrach obliczeniowych. W efekcie nie ma on finansowej bariery rozpoczęcia pracy, a kod napisany na jednym komputerze można również przenieść i uruchomić na innym sprzęcie. R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. Ten aspekt ułatwia szybsze zrozumienie działania tego języka. R posiada wiele wbudowanych narzędzi analizy i wizualizacji danych. Pozwala to na relatywnie szybkie osiąganie wymiernych efektów z korzystania z tego języka. R posiada tysiące dodatkowych rozszerzeń (zwanych pakietami) pozwalających na, między innymi, przetwarzanie różnorodnych danych, ich wizualizację, czy zaawansowane modelowanie. Oficjalnym portalem zawierającym dodatkowe pakiety R jest CRAN. R ma przyjazną społeczność użytkowników tego języka, zarówno online jak i spotykających się na żywo na tzw. meetupach. W celu ułatwienia pracy z R powstało również zintegrowane środowisko programistyczne RStudio, które wspomaga pisanie i analizę kodu w R. R został zaprojektowany jako narzędzie ułatwiające komunikację między różnymi językami programowania, głównie C oraz Fortran15. Obecnie R pozwala na łatwe łączenie kodu pochodzącego również z takich języków jak C++, Python, JavaScript, itd. R jest używany przez wiele małych firm, jak i wielkich korporacji, wliczając w to BBC, Facebook, Google, Microsoft, Mozilla, Netflix, T-Mobile, czy Uber16. Oczywiście, uniwersalny i idealny język nie istnieje: R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. W efekcie R nie jest najszybszym językiem programowania. Podobnie jak wiele innych języków, również R zawiera wiele niekonsekwencji, wynikających z wieloletniej ewolucji tego języka. W efekcie istnieje wiele specjalnych przypadków czy wyjątków, które warto znać (Burns 2012). Ta książka skupia się na prezentacji głównym konceptów programistycznych używając języka R. W sekcji 2.5 można znaleźć listę różnorodnych materiałów, książek, blogów, kursów, czy serwisów ułatwiających i wspomagających naukę R. Istnieje także wiele wprowadzających materiałów do nauki innych języków. Przykładowo, osoby zainteresowane nauką Pythona mogą skorzystać z istniejących książek (Gries, Campbell, and Montojo (2017) oraz Guzdial and Ericson (2016)), czy też kursów Software Carpentry oraz Python Course. W pracy programistycznej przydaje się również często znajomość linii komend. Tutaj również można użyć materiałów z kursu Software Carpentry lub książki The Unix Workbench (Kross 2017). 1.4 Zadania Pomyśl do czego jesteś w stanie wykorzystać programowanie w swoim życiu zawodowym lub prywatnym? Zastanów się nad mitami związanymi z programowaniem. Czy jesteś w stanie wskazać jakieś mity nie wymienione powyżej? Wybierz trzy języki programowania z listy wymienionej w tym rozdziale i poszukaj informacji o nich. Do czego są one stosowane? Jakie mają wady i zalety? Bibliografia "],
["ergosum.html", "2 Start R 2.1 Wyrażenia 2.2 Obiekty 2.3 IDE 2.4 Styl 2.5 Dodatkowe materiały 2.6 Zadania", " 2 Start R Wykonywanie kodu w języku interpretowalnym, jakim jest R, może odbywać się poprzez wpisanie polecenia w oknie konsoli (zwanej też terminalem) i jego uruchomienie17. Komendy są najpierw sprawdzanie pod kontekstem ich poprawności. Polega to na określeniu, np. czy podana funkcja lub inny obiekt istnieje, czy nie zostały użyte niedozwolone znaki, lub czy wszystkie nazwiasy czy cudzysłowia zostały zamknięte. Języki programowania są w tym aspekcie bardziej bezwzględne niż języki naturalne - nie potrafią one zrozumieć wyrażeń zawierających nawet niewielkie błędy takie jak, np. użycie dużej litery zamiast małej. 2.1 Wyrażenia Podstawowe działania arytmetyczne, dodawanie, odejmowane, mnożenie i dzielenie, są również często używane w wielu językach programowania. Dla każdej z tych operacji istnieje odpowiedni operator w R. Operatorem dodawania jest +. 2 + 2 #&gt; [1] 4 Operatorem odejmowania jest -. 1 - 3 #&gt; [1] -2 Operatorem mnożenia jest *. 5 * 5 #&gt; [1] 25 Operatorem mnożenia jest /. 42 / 5 #&gt; [1] 8.4 Wszystkie powyższe operacje można wykonać poprzez ich wpisanie w oknie konsoli R i naciśnięcie klawisza Enter. 2.2 Obiekty “Dwa slogany są pomocne w zrozumieniu obliczeń w R: 1. Wszystko co istnieje jest obiektem. 2. Wszystko co się dzieje jest wywołaniem funkcji.” — John Chambers Powyższy cytat sugeruje dwa najważniejsze elementy języka R: obiekty i funkcje. Zrozumienie w jaki sposób się je tworzy i zmienia będzie w związku z tym, konieczną wiedzą osób piszących w tym języku. 2.2.1 Operator przypisania Nadanie wartości do obiektu wykonuje się używając operatora przypisania18. R posiada trzy operatory przypisania, które mają niemal identyczne działanie19: =, &lt;-, -&gt;. Warto wybrać jeden z tych operatorów i konsekwentnie używać go pisząc kod. W tej książce jako główny operator przypisania będzie używany znak =. W poniższej linii stworzony jest nowy obiekt, o nazwie x, który zawiera wartość 7. x = 7 Można to sprawdzić wpisując nazwę tego obiektu. x #&gt; [1] 7 Operatory przypisania może również posłużyć do nadania wartości z jednego obiektu do drugiego. Poniżej nowy obiekt y przyjmuje wartość od obiektu x. y = x y #&gt; [1] 7 Język R przechowuje i przetwarza wszystkie obiekty w pamięci komputera (RAM). Wpływa to na zwiększoną wydajność i elastyczność obliczeń, ale jednocześnie powoduje to ograniczenie wielkości obiektów na jakich można pracować. Istnieje równocześnie szereg strategii jak postępować z większymi zbiorami danych, które nie mieszczą się w RAMie (Peng, Kross, and Anderson 2017). 2.2.2 Działania na obiektach Każdy stworzony obiekt w R może być następnie używany do kolejnych operacji, a w efekcie też tworzenia nowych obiektów. W poniższych czterech przypadkach obiekt x został przetworzony używając operatorów dodawania, odejmowania, mnożenia oraz dzielenia, a nowe obiekty powstały jako wyniki tych obliczeń. z1 = x + 3 z1 #&gt; [1] 10 z2 = x - 5 z2 #&gt; [1] 2 z3 = x * 2 z3 #&gt; [1] 14 z4 = x / 4 z4 #&gt; [1] 1.75 Część języków programowania, np. C, wymaga zadeklarowania zmiennej przed jej użyciem poprzez podanie jej nazwy i typu. Wybór typu zmiennej w tych językach może mieć widoczne konsekwencje. Przykładowo, jeżeli obiekt x zostanie zadeklarowany jako liczba całkowita (integer), wynikiem dzielenia x / 4 będzie 1 zamiast 1.75. Działania na obiektach mogą też się odbywać używając innych operatorów oraz różnorodnych funkcji. Przykładowo, operator zapisywany jako %% to modulo, którego celem jest określanie reszty z dzielenia. z5 = x %% 3 z5 #&gt; [1] 1 Operator %/% przestawia dzielenie całkowite. z6 = x %/% 3 z6 #&gt; [1] 2 Operator ^ natomiast wykonuje podniesienie wartości obiektu do wybranej potęgi. z7 = x^2 z7 #&gt; [1] 49 Odwrotnością potęgowania jest pierwiastkowanie. W R nie istnieje do tego celu specjalny operator, ale zawiera on specjalną funkcję sqrt(). z8 = sqrt(x) z8 #&gt; [1] 2.65 Często używaną funkcją w R jest też c(). Ta funkcja łączy krótsze wektory w dłuższe wektory. z9 = c(z2, z4, z8) z9 #&gt; [1] 2.00 1.75 2.65 Operatory użyte w tym rozdziale, np. +, *, ^, %% to też są funkcje, ale zapisane w skrótowej formie ułatwiającej z nimi pracę. Te operatory można też użyć jako normalne funkcje poprzez dodanie znaku zwanego grawisem - &quot;&quot;, np.2 + 2można też zapisać jako`+`(2, 2)`. 2.3 IDE RStudio to zintegrowane środowisko programistyczne (ang. Integrated Development Environment, IDE) dla R. Zawiera ono bardzo wiele użytecznych funkcjonalności, tj. wbudowany edytor, podświetlanie składni, automatyczne uzupełnianie kodu i wiele innych. RStudio to nie jest to samo co R. R jest językiem programowania, podczas gdy RStudio to aplikacja ułatwiająca pisanie kodu. Możliwe jest używanie R bez RStudio, ale RStudio bez R nie pełni już swojej roli. Częstą analogią jest porównanie samochodowe, w którym R jest opisywany jako silnik a RStudio jako deska rozdzielcza. Rycina 2.1: Okno RStudio z opisaną funkcjonalnością każdej z jego części. Typowa praca w RStudio często polega na wpisywaniu poleceń do pliku tekstowego widocznego w części skryptowej (Rycina 2.1), a następnie wykonywaniu kolejnych linii kodu w oknie konsoli używając skrótu klawiaturowego CTRL+ENTER (więcej przydatnych skrótów klawiaturowych można znaleźć w tabeli 2.1). Efektem wykonywania funkcji może być powstanie nowych obiektów, które można zobaczyć w oknie “środowiska” lub też wyświetlenie grafik, które można zobaczyć w oknie “wykresu”. Dobrą praktyką pracy z R w RStudio jest też używanie projektów RStudio (ang. RStudio projects). Projekt jest to folder zawierający wszystkie skrypty i pozostałe pliki powiązane z jakimś zadaniem (np. analizą danych, czy stworzeniem nowego pakietu R). Ułatwia on przenoszenie kodu pomiędzy różnymi komputerami, a także daje dostęp do szeregu dodatkowych możliwości w RStudio. Aby stworzyć pierwszy projekt RStudio, należy: Kliknąć File -&gt; New Project. Wybrać New Directory. Wybrać New Project. Podać nazwę nowego projektu, np. “programowanie1” oraz wybrać miejsce na dysku, gdzie ma się nowy projekt znajdować. Jeżeli możliwe, to wybrać też opcję Create a git repository. Kliknąć Create Project. Tabela 2.1: Podstawowe skróty klawiaturowe w RStudio Skrót Wyjaśnienie Ctrl+Enter wykonuje wybraną linię kodu w skrypcie R Tab uzupełnia kod (podaje pasujące możliwości) F1 wyświetla plik pomocy dla wybranej funkcji Ctrl+Shift+C ustawia wybrane linie jako komentarz/odkomentuj fragment kodu strzałka Góra/Dół (w oknie konsoli) wybiera wcześniej wpisany kod Esc przerywa niedokończoną operację Shift+Alt+K wyświetla listę skrótów klawiaturowych 2.4 Styl Poniżej znajdują się podstawowe porady dotyczące stylu pisania kodu. Więcej wskazówek można znaleźć na w poradniku stylu RStudio oraz poradniku stylu Google. Oba te poradniki nie są identyczne i czasami zawierają sprzeczne porady. Najważniejsze jest, aby wybrać jeden odpowiadający piszącemu kod styl i się go konsekwentnie trzymać. 2.4.1 Nazwy obiektów Istnieje wiele konwencji nazywania obiektów20. Najczęściej używaną konwencją w R jest tzw. “snake case”. Polega ona na tworzeniu nazw obiektów składających się ze słów połączonych znakiem podkreślenia (_). Ważne, żeby nazwy obiektów ułatwiały zrozumienie ich zawartości. # obiekt bok_a bok_b # funkcja pole_prostokata Nazwa obiektu nie może zaczynać się od liczby, ani nie może używać specjalnych symboli, tj. ^, !, $, @, +, -, /, czy *. Dodatkowo należy uważać, żeby nowa nazwa obiektu nie nadpisała istniejącego obiektu lub funkcji. Nie powinno nazywać się obiektów tak jak istniejące funkcje, np. c, t, table, itd. 2.4.2 Odstępy Odstępy pełnią bardzo ważną funkcję przy pisaniu kodu, podobnie jak odstępy przy pisaniu tekstu. Wyobraź sobie czytanie powieści, w której nie ma żadnych odstępów między słowami czy rozdziałami. Często mówi się, że “kod musi oddychać” - odstępy zwiększają czytelność kodu i pozwalają na jego szybsze zrozumienie oraz ułatwiają naprawienie występujących błędów. Odstępy można uzyskać poprzez użycie spacji. Spacje powinny być użyte po przecinkach, ale nigdy przed nimi. Dodatkowo, większość operatorów (np. =, +, -, ==) powinna być otoczona przez spacje. # Zalecane srednia = mean(wartosc, na.rm = TRUE) pole = bok_a * bok_b # Niewskazane srednia=mean ( wartosc,na.rm=TRUE ) pole=bok_a*bok_b Spacje należy również używać do tworzenia wcięć - każde z nich powinno się składać z dwóch spacji. # Zalecane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } # Niewskazane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Warto także ograniczać długość każdej linii kodu, żeby nie przekraczała ona ok. 80 znaków. Dzięki temu możliwe jest szybkie przeczytanie kodu czy też jego wydrukowanie. # Zalecane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, b = &quot;drugi argument&quot;, c = &quot;trzeci argument&quot;) # Niewskazane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, &quot;drugi argument&quot;, &quot;trzeci argument&quot;) 2.4.3 Komentarze Komentarze służą do wyjaśniania istotnych elementów kodu. Do komentowania w języku R służy operator #. # Mój komentarz 2.4.4 Nazwy plików Nazwy plików powinny spełniać trzy wymagania - być łatwe (i) do odczytania przez komputer, (ii) do odczytania przez człowieka, (iii) do posortowania. Nazwy plików nie powinny zawierać spacji, znaków specjalnych (np. !, %, *), znaków diakrytycznych (np. ć, Ł, ź). Warto też aby nazwy plików składały się tylko z małych liter. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane Obliczanie Średniej.R pomiaryTemperatury!.csv Podobnie jak nazwy obiektów, również nazwy plików powinny opisywać ich zawartość. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane kod.R dane.csv Dodatkowo wskazane jest dodanie wartości numerycznych przed nazwą pliku, jeżeli pliki mają jakąś kolejność. # Zalecane 01_przygotowanie-danych.R 02_obliczanie-sredniej.R # Niewskazane przygotowanie-danych.R obliczanie-sredniej.R Kodowanie znaków (ang. character encodings) jest to sposób sposób prezentacji znaków. Istnieje szereg różnych standardów kodowania znaków. Standard ASCII przyporządkowuje liczbom z zakresu 0−127 litery alfabetu angielskiego, cyfry, znaki przestankowe i inne symbole oraz polecenia. Firma Microsoft stworzyła dodatkowo cały szereg standardów dla różnych języków. Przykładowo do obsługi języków środkowoeuropejskich istnieje wersja oznaczona jako Windows-1250 (lub CP1250). Alternatywnie do systemu Microsoftu powstał też zbiór standardów ISO, przykładowo ISO-8859-2 dla języków środkowoeuropejskich. W efekcie oznacza to, że otworzenie tekstu z innego komputera, na komputerze z “polskim” kodowaniem znaków może spowodować pojawienie się tzw. “krzaczków”. Aby uniknąć takiej sytuacji powstał system kodowania UTF-8, który zawiera w sobie ponad milion różnych znaków. Jest on obecnie zalecanym standardem na całym świecie. 2.4.5 Daty Istnieje wiele sposobów zapisu dat21, co może powodować różnorodne problemy przy programowaniu oraz analizie danych. Z ratunkiem w tej kwestii przychodzi norma ISO 8601, która definiuje daty kalendarzowe jako YYYY-MM-DD, czyli ROK-MIESIĄC-DZIEŃ. # Zalecane 2019-06-02 # Niewskazane wszelkie inne 2.5 Dodatkowe materiały Polskie książki: http://www.biecek.pl/R/ (Biecek 2014) http://www.gagolewski.com/publications/programowanier/ (Gagolewski 2016) https://helion.pl/ksiazki/jezyk-r-kompletny-zestaw-narzedzi-dla-analitykow-danych-hadley-wickham-garrett-grolemund,jezrko.htm#format/d (Wickham and Grolemund 2016) https://helion.pl/ksiazki/wydajne-programowanie-w-r-praktyczny-przewodnik-po-lepszym-programowaniu-gillespie-colin-lovelace-robin,a_0491.htm#format/d (Gillespie and Lovelace 2016) https://bookdown.org/nowosad/Geostatystyka/ (Nowosad 2019) http://www.enwo.pl/przetwarzanie/index.html (Czernecki 2018) Angielskie książki: https://rstudio-education.github.io/hopr/ (Grolemund 2014) https://r4ds.had.co.nz/ (Wickham and Grolemund 2016) https://csgillespie.github.io/efficientR/ (Gillespie and Lovelace 2016) https://adv-r.hadley.nz (Wickham 2014) https://geocompr.robinlovelace.net/ (Lovelace, Nowosad, and Muenchow 2019) Blogi: Agregator blogów dotyczących R - https://www.r-bloggers.com/ Polski blog opisujący kwestie analizy danych w R, wizualizacji, oraz edukacji - http://smarterpoland.pl/ Polski blog pokazujący zastosowanie R do analizy i wizualizacji danych - http://szychtawdanych.pl/ Kursy: Lista kursów dotyczących R na platformie DataCamp (część z nich jest dostępna bezpłatnie) - https://www.datacamp.com/search?q=r Polskie tłumaczenie pakietu R służącego do nauki tego języka - https://github.com/dabrze/swirl Lista kursów dotyczących R na platformie Coursera - https://www.coursera.org/courses?query=r Lista kursów dotyczących R na platformie edX - https://www.edx.org/course?search_query=r Pisanie kodu oraz jego dokumentowanie opiera się w znacznym stopniu na wprowadzaniu znaków na klawiaturze do komputera. Warto jest więc aby robić to w sposób efektywny, czyli taki w którym używamy wszystkich palców u rąk a nasz wzrok nie jest skupiony na klawiaturze. Takie pisanie nazwa się pisaniem bezwzrokowym (ang. touch typing). Pisanie bezwzrokowe ma szereg reguł, które wymagają przestawienia się ze starych nawyków oraz pewnego treningu. Na szczęście istnieje wiele internetowych zasobów, które ułatwiają naukę takiego pisania, między innymi strona TypingClub. Serwisy internetowe: Wyszukiwarki internetowe są nieocenionym narzędziem wspierającym programowanie - https://rseek.org/, https://duckduckgo.com/, https://www.google.com/, https://www.bing.com/, itd. Serwis społecznościowy zawierający pytania i odpowiedzi dotyczące różnych języków programowania w tym R - https://stackoverflow.com. Pytania dotyczące R można znaleźć pod adresem https://stackoverflow.com/questions/tagged/r. Przed zadaniem nowego pytania warto wyszukać czy nie zostało ono zadane wcześniej a następnie przeczytać wątek dotyczący tworzenia nowych pytań - https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example Twitter jest miejscem, w którym można znaleźć zarówno nowości z języka R, jak również odpowiedzi na pytania dotyczące tego języka - https://twitter.com/. Kwestie związane z R są opatrzone hasztagiem #rstats, natomiast kwestie przestrzenne w R są opisywane hasztagami #rspatial oraz #geocompr Elektroniczny biuletyn R Weekly zbierający co tydzień nowości związane z r - https://rweekly.org/ Lista emailowa dotycząca R - https://stat.ethz.ch/mailman/listinfo/r-help Lista emailowa dotycząca kwestii przestrzennych w R - https://stat.ethz.ch/mailman/listinfo/r-sig-geo Forum dotyczące kwestii R i RStudio - https://community.rstudio.com/ Meetups (spotkania początkujących i zaawansowanych użytkowników R): Poznań - https://www.meetup.com/pl-PL/Poznan-R-User-Group-PAZUR/ Warszawa - https://www.meetup.com/pl-PL/Spotkania-Entuzjastow-R-Warsaw-R-Users-Group-Meetup/ Wrocław - https://www.meetup.com/Wroclaw-R-Users-Group/ Kraków - https://www.meetup.com/erkakrakow/ Trójmiasto - https://www.meetup.com/Trojmiejska-Grupa-Entuzjastow-R/ 2.6 Zadania Rozwiązując poniższe zadania oraz pozostałe zadania z tej książki staraj się stosować do stylu podanego w sekcji 2.4. Przejrzyj poniższą listę poleceń. Spróbuj określić uzyskane wyniki bez wykonywania kodu w R. x = 7 y = -2 x + 3 y - 5 x * 2 y / 4 x %% 3 x %/% 3 y ^ 2 y ^ x Jedziesz na krótkie wakacje i planujesz na nie zabrać 500 EUR. Aktualny kurs kupna EUR wynosi 4,31. Ile PLN musisz wydać? Wylicz to w R. Masz trapez o długości podstaw a = 5 i b = 6 oraz wysokości h = 3. Stwórz nowy obiekt pole_trapezu, który zawiera obliczone pole tego trapezu. Wraz z grupą znajomych planujesz zamówić pizzę z dostawą i macie na to przeznaczonych 50 PLN. Pizza o średnicy 30 cm kosztuje 23,5 PLN, a pizza o średniczy 50 cm kosztuje 50 PLN. Wylicz w R, czy bardziej opłaca się kupno dwóch małych pizz czy jednej dużej. Bibliografia "],
["funkcje.html", "3 Funkcje 3.1 Struktura funkcji 3.2 Wbudowane funkcje 3.3 Kolejność wykonywania funkcji 3.4 Dokumentacja funkcji 3.5 Pakiety 3.6 Algorytmy 3.7 Tworzenie skryptów 3.8 Budowanie funkcji 3.9 Komunikaty 3.10 Zadania", " 3 Funkcje Funkcje to programy, który przyjmują pewne argumenty, przetwarzają je i zwracają jakiś wynik. Są one zbudowane z dostępnych elementów języka programowania jak i też z innych dostępnych funkcji. Funkcje mogą służyć do wielu celów, od prostych odliczeń arytmetycznych, poprzez przetwarzanie tekstu, tworzenie wykresów i map, aż do bardziej złożonych i specjalistycznych procedur. Ich celem jest ułatwienie pracy programistycznej i zwiększenie czytelności kodu. Zamiast wielokrotnie powtarzać te same linie kodu, możliwe jest napisanie funkcji raz, a następnie użycie jej wiele razy. 3.1 Struktura funkcji Funkcje są reprezentowane w R jako specjalne obiekty, które można uruchomić poprzez dodanie do ich nazwy nawiasów okrągłych. Przykładowo, funkcja mean() wylicza średnią. Może ona przyjąć kilka różnych argumentów, czyli pewnych obiektów lub parametrów wejściowych. W poniższym przykładzie do funkcji mean() zostały podane dwa argumenty. Pierwszy argument nazywa się x i przyjmuje on wektor numeryczny economics$pop, drugi argument nazywa się na.rm i został on ustalony na TRUE. W efekcie działania funkcji otrzymano wynik - 246348.9 - który jest średnią wartością w zadanym wektorze. 3.2 Wbudowane funkcje R posiada wiele wbudowanych funkcji, które znacznie ułatwiają wykonywanie bardziej złożonych operacji. Pierwsze z funkcji, w tym c(), zostały już poznane w sekcji 2.2.2. Ta funkcja pozwala na łączenie kolejnych obiektów rozdzielonych przecinkami. Poniższy obiekt, x jest w efekcie wektorem zawierającym trzy wartości 8.2, 10.3 oraz 12.0. x = c(8.2, 10.3, 12.0) x #&gt; [1] 8.2 10.3 12.0 Wyliczenie średniej z tych trzech wartości wymaga ich zsumowania, a następnie podzielenia uzyskanej wartości przez liczbę wartości. (8.2 + 10.3 + 12.0) / 3 #&gt; [1] 10.2 W przypadku jednak, gdy chcemy dodać czwartą, piątą, itd. wartość należy zmieniać kod w co najmniej dwóch miejscach. Konieczne jest dodanie nowej wartości do zsumowania, a następnie zmianę wartości określającej liczbę elementów. Zamiast tych dwóch operacji, można wykonać tylko jedną zmianę w obiekcie x, a następnie przetworzyć go używając funkcji wbudowanych w R - sum() oraz length(). Pierwsza z nich sumuje wartości z wektora, druga natomiast zwraca liczbę elementów w wektorze. sum(x) / length(x) #&gt; [1] 10.2 Powyższy kod można też dalej uprościć, poprzez użycie wbudowanej w R funkcji do liczenia średniej - mean(). mean(x) #&gt; [1] 10.2 Jej użycie powoduje, że wystarczy wykonać tylko jedną zmianę w obiekcie x, aby uzyskać poprawny wynik, a dodatkowo napisanie tego obliczenia wymaga napisania znacznie krótszego kodu. Funkcje można używać w celu wyświetlenia oczekiwanego rezultatu, ale także, aby na podstawie wyniku funkcji tworzyć nowe obiekty, takie jak y poniżej. y = mean(x) y #&gt; [1] 10.2 3.3 Kolejność wykonywania funkcji Wykonywanie funkcji w R odbywa się linia po linii, od góry do dołu. a = 4 b = 5 a2 = a^2 b2 = b^2 R pozwala na dwa podstawowe sposoby łączenia działania wielu funkcji22. Pierwszy z nich polega na tworzeniu pośrednich obiektow jako wyników działania pojedynczych funkcji. suma_a2b2 = sum(a2, b2) przekatna = sqrt(suma_a2b2) przekatna #&gt; [1] 6.4 Drugi sposób opiera się o zagnieżdzanie funkcji. W tej sytuacji najpierw wykonywana jest funkcja w środku, na następnie kolejne funkcje coraz bliżej brzegu. przekatna = sqrt(sum(a2, b2)) przekatna #&gt; [1] 6.4 3.4 Dokumentacja funkcji Każda wbudowana funkcja w R posiada swoją dokumentację23. Można ją wyświetlić poprzez dodanie znaku zapytania przed nazwą funkcji, a następnie wykonanie tej linii kodu. ?mean Alternatywnie, w RStudio możliwe jest użycie skrótu F1 gdy kursor znajduje się na nazwie funkcji. Dokumentacja każdej funkcji, zwana inaczej plikiem pomocy, ma zazwyczaj podobną strukturę. W lewym górnym rogu znajduje się nazwa funkcji (mean) oraz nazwa pakietu z którego dana funkcja pochodzi (base). Poniżej znajduje się tytuł funkcji oraz jej krótki opis. Kolejnym elementem jest budowa funkcji (Usage), która skrótowo opisuje z jakich argumentów składa się dana funkcja. Np. funkcja mean() przyjmuje argument x, trim, oraz na.rm. Dla argumentów trim oraz na.rm są także ustalone ich domyślne wartości. Dodatkowo, widoczny jest argument w postaci wielokropka (...). Argumenty funkcji są również wypisane oraz skrótowo wyjaśnione. Przykładowo, x musi być obiektem R o typie numerycznym (który łączy typ liczb całkowitych i zmiennoprzecinkowych), logicznym, date, date-time, lub time interval. Część Value (lub Details) opisuje szczegóły wykonywanej funkcji. Inne możliwe elementy to np. References odnoszący się do artykułu czy książki opisującej daną funkcję lub metodę, czy też See also zawierający odnośniki do innych, podobnych funkcji. Jeden z najważniejszych elementów pliku pomocy znajduje się na samym końcu - są to przykłady (Examples). Jeżeli nie jesteśmy pewni jak dana funkcja działa warto zacząć od skopiowania przykładów a następnie ich wykonania. Czytanie dokumentacji wymaga pewnej wprawy i doświadczenia. Nie bój się używać innych źródeł pomocy (zobacz sekcję 2.5), jeżli potrzebujesz zrozumieć działanie danej funkcji. 3.5 Pakiety Pakiet to zorganizowany zbiór funkcji, który rozszerza możliwości R. Pakiety oprócz kodu zawierają szereg dodatkowych istotnych elementów, takich jak: Informacja o wersji pakietu, jego twórcach, zależnościach, czy licencji Dokumentacja Przykładowe dane Testy kodu Pakiety R mogą być przechowywane i instalowane z wielu miejsc w internecie. Istnieje jednak jedno centralne repozytorium (CRAN, ang. the Comprehensive R Archive Network), które zawiera oficjalne wersje pakietów R. Wersje deweloperskie (rozwojowe) często można znaleźć na platformie GitHub. Do instalacji pakietu w R z repozytorium CRAN służy wbudowana funkcja install.packages(), np: install.packages(&quot;stringr&quot;) #instalacja pakietu stringr Zainstalowanie pakietu w R z platformy GitHub jest możliwe używając, np. funkcji install_github() z pakietu remotes. # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;tidyverse/stringr&quot;) W przypadku instalacji pakietu w R z platformy GitHub należy podać nazwę użytkownika lub organizacji, która tworzy ten pakiet (np. powyżej tidyverse) oraz nazwę pakietu (np. powyżej stringr) oddzielone znakiem /. Podobnie jak instalowanie programów na komputerze - zainstalowanie pakietu odbywa się tylko jeden raz. Istnieją dwa główne formy, w których rozpowszechniane są pakiety R - postać źródłowa (ang. source packages) i postać binarna (ang. binary packages). Postać źródłowa zawiera kod źródłowy pakietu, który musi zostać następnie skompilowany na komputerze użytkownika. Skompilowanie pakietu na podstawie kodu źródłowego może wymagać posiadania odpowiednich bibliotek na komputerze, np. Rtools dla systemu Windows czy też narzędzia Xcode dla Mac OS. Dodatkowo, instalacja w ten sposób zabiera więcej czasu. Postać binarna została już wcześniej skompilowana na zewnętrznym komputerze (np. w repozytorium CRAN) Jest ona dostępna dla systemów Windows i Mac OS. Niestety, nie wszystkie pakiety (lub ich wersje) posiadają postać binarną i wymagana jest ich kompilacja. Użycie wybranego pakietu wymaga dołączenia go do R za pomocą funkcji library(). Dołączenie wybranych pakietów do R robimy po każdym uruchomieniu R. library(stringr) W przypadku, gdy chcemy użyć zewnętrznej funkcji, ale nie dołączyliśmy odpowiedniego pakietu, pojawi się błąd o treści could not find function &quot;nazwa_funkcji&quot;. str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; Error in str_sub(&quot;chronologia&quot;, start = 1, end = 6) : #&gt; could not find function &quot;str_sub&quot; Istnieją dwa możliwe rozwiązania powyższego problemu. Po pierwsze możliwe jest dołączenie pakietu poprzez library(stringr). Po drugie można bezpośrednio zdefiniować z jakiego pakietu pochodzi konkretna funkcja używając nazwy pakietu i operatora ::. stringr::str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; [1] &quot;chrono&quot; Operator :: może być też pomocny w przypadku, gdy kilka pakietów ma funkcję o tej samej nazwie. Wówczas, aby kod został poprawnie wykonany, warto podać nie tylko nazwę funkcji ale też nazwę pakietu z jakiego ona pochodzi. 3.6 Algorytmy Algorytm to zbiór kroków powadzących do uzyskania określonego celu. Algorytmy można porównać do przepisu kucharskiego, w którym opisany jest szereg czynności aby uzyskać konkretną potrawę. Podobnie jak w przepisie kucharskim, algorytmy wymagają posiadania odpowiednich składników - danych wejściowych w o pewnej strukturze. Tworzenie nowych algorytmów często zaczyna się od narysowania schematu procedury działania lub też pseudokodu. Kolejnym krokiem jest zapisanie tego algorytmu w wybranym języku lub językach programowania24 w formie skryptu (sekcja 3.7) lub funkcji (sekcja 3.8). 3.7 Tworzenie skryptów Skrypt w R to plik testowy z rozszerzeniem .R, który zawiera szereg linii kodu w celu uzyskania konkretnego efektu. Może on zawierać zaledwie kilka jak i setki linii kodu w zależności od złożoności postawionego problemu. Zobaczmy jak wyglądają skrypty na prostym przykładzie - przeliczania wartości ze skali Fahrenheita na skalę Celsjusza. Otrzymaliśmy informację, że w “mieście A” temperatura w stopniach Fahrenheita wynosi 75. miasto_a = 75 Pierwszym naszym krokiem powinno być dowiedzenie się jaka jest relacja pomiędzy skalą Fahrenheita na skalą Celsjusza. \\[T_{Celsjusz} = \\frac{T_{Fahrenheit} - 32}{1.8}\\] Następnie powyższy wzór można przepisać do postaci kodu w języku R oraz podstawić do niego wartość temperatury w stopniach Fahrenheita w mieście A. Ostatnim etapem jest wyświetlenie uzyskanego wyniku - temperatura w mieście A wynosi ok. 24 stopnie Celsjusza. miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Powyższe kroki można również zapisać do pliku tekstowego. # plik przeliczanie-temp.R miasto_a = 75 miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c Co można zrobić jeżeli mamy więcej podobnych pomiarów, które chcemy wykonać? Najprostszą opcją jest użycie kopiuj/wklej i powielenie tego samego kodu, a później naniesienie małych zmian, np. nazw obiektów. miasto_a = 75 miasto_b = 110 miasto_c = 0 miasto_a_c = (miasto_a - 32) / 1.8 miasto_b_c = (miasto_b - 32) / 1.8 miasto_c_c = (miasto_c - 32) / 1.8 Powyższe podejście jest poprawne, ale ma ono kilka wad: Łatwo jest o popełnie jakiegoś prostego błędu lub literówki podczas adaptacji kodu (np. można zapomnieć zmienić nazwę jakiejś zmiennej). Jeżeli obliczenia zajmują więcej niż kilka linii kodu - wówczas kopiowanie go znacznie powiększa tworzony skrypt i utrudnia jego czytelność. Poprawienie kodu w przypadku zauważenia błędu w procedurze obliczeniowej jest czasochłonne. To podejście jest też niezgodne z jedną z najważniejszych reguł w programowaniu - regułą DRY (Nie powtarzaj się, ang. Don’t Repeat Yourself). Zamiast tworzenia skryptu w oparciu o kopiuj/wklej lepiej pomyśleć nad zbudowaniem odpowiedniej funkcji25. 3.8 Budowanie funkcji Funkcje pozwalają na automatyzację często używanych obliczeń. Formalnie funkcje składają się z trzech elementów: listy argumentów (ang. formals), ciała funkcji (ang. body) oraz środowiska (ang. environment). Pierwsze dwa elementy ustala twórca funkcji, natomiast środowisko jest określane na podstawie tego, gdzie dana funkcja została zdefiniowana. Dodatkowo każda funkcja ma swoją nazwę. moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Lista argumentów wymienia obiekty wejściowe funkcji. formals(moja_funkcja) #&gt; $x #&gt; #&gt; #&gt; $y #&gt; #&gt; #&gt; $z Ciało zawiera kod danej funkcji. body(moja_funkcja) #&gt; { #&gt; pod = y/z #&gt; wynik = x * pod #&gt; wynik #&gt; } Środowisko określa, gdzie dana funkcja jest zlokalizowana. environment(moja_funkcja) #&gt; &lt;environment: R_GlobalEnv&gt; Przykładowa funkcja odpowiadająca problemowi z poprzedniej sekcji może wyglądać w poniższy sposób: konwersja_temp = function(temperatura_f){ (temperatura_f - 32) / 1.8 } Nowa funkcja nazywa się konwersja_temp() oraz posiada tylko jeden argument temperatura_f. Ciało funkcji zawiera natomiast wzór potrzebny do obliczeń przepisany do R. Ważne jest to, że obiekt użyty wewnątrz funkcji (temperatura_f) jest taki sam jak wejściowy argument. Po stworzeniu funkcji warto sprawdzić czy jej działanie odpowiada naszym oczekiwaniom. konwersja_temp(75) #&gt; [1] 23.9 konwersja_temp(110) #&gt; [1] 43.3 konwersja_temp(0) #&gt; [1] -17.8 konwersja_temp(c(0, 75, 110)) #&gt; [1] -17.8 23.9 43.3 3.9 Komunikaty Oprócz wyniku danej operacji R może wyświetlić kilka rodzajów komunikatów. Trzy podstawowe z nich to: Błędy (ang. errors) Ostrzeżenia (ang. warnings) Wiadomości (ang. messages) Błedy oznaczają, że wykonanie danej funkcji nie może być kontynuowane i przerwane jest jej działanie. Przykładowo, w poniższym kodzie podjęta została próba wyliczenia logarytmu naturalnego z tekstu &quot;abecadło&quot;. Takie obliczenie nie jest możliwe, w efekcie pojawił się komunikat błędu a kod nie został wykonany. log(&quot;abecadło&quot;) #&gt; Error in log(&quot;abecadło&quot;): non-numeric argument to mathematical function Ostrzeżenia zazwyczaj występują kiedy nastąpił jakiś problem z wykonaniem funkcji, ale jej działanie mogło być dokończone. Często sugerują one użytkownikowi, aby dokładnie przyjrzał się wykonywanej funkcji i upewnił się czy na pewno ustala on odpowiednie wartości dla argumentów funkcji. Poniżej została podjęta próba wyliczenia logarytmu naturalnego dla wartości ujemnej. W efekcie pojawił się komunikat błędu, który mówi, że w wyniku zostały stworzone wartości NaN (ang. Not a Number). log(-1) #&gt; Warning in log(-1): NaNs produced #&gt; [1] NaN Wiadomości pojawiają się, aby przekazać użytkownikowi jakąś informację. inna_funkcja(15) #&gt; Chcę ciebie o czymś poinformować. #&gt; [1] 2.71 Opis tworzenia komunikatów błędu, ostrzeżenia i wiadomości można znaleźć w rozdziale 11. 3.10 Zadania Zobacz jak wygląda plik pomocy funkcji mean(). Wykonaj zawarte w nim przykłady. Co przedstawiają uzyskane wyniki? Zainstaluj pakiet magrittr. Spróbuj użyć operatora %&gt;% z tego pakietu na przykładzie z sekcji 3.3 dotyczącym wyliczania przekątnej prostokąta. Stwórz nowy plik skryptu R nazywający się 01_zadania-funkcje.R. W tym pliku, stwórz nowy obiekt poznan, który przyjmuje wartość 8.4, napisz przeliczenie wartości tego obiektu ze stopnii Celsjusza na stopnie Fahrenheita, a następnie wyświetl uzyskany wynik. Uwaga: pamiętaj o ustawieniu odpowiedniego kodowania znaków dla tego nowego pliku. Stwórz nową funkcję, która służy do przeliczania wartości ze stopnii Celsjusza na stopnie Fahrenheita. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z mil lądowych na kilometry. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z metrów na sekundę na kilometry na godzinę. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z metrów na sekundę na mile lądowe na godzinę. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do wyliczania pola trapezu na podstawie długości podstaw oraz wysokości trapezu. Jak nazwiesz taką funkcję? Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean() Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean(&quot;abecadło&quot;) Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean(sqrt()) Wykonaj poniższy kod. Co oznacza uzyskany wynik? str_length(&quot;abecadło&quot;) Wykonaj poniższy kod. Co oznacza uzyskany wynik? u = 2 z = 3 + v v = 7 Istnieje też szereg dodatkowych sposobów, wśród których najpopularniejszy polega na używaniu operatora %&gt;% z pakietu magrittr (Bache and Wickham 2014).↩ Niektóre zbiory danych również posiadają swoje pliki pomocy.↩ Łączenie różnych języków programowania jest wyjaśnione w rozdziale 14↩ Wickham and Grolemund (2016) radzą tworzyć nowe funkcje, gdy ten sam kod potwarza się co najmniej trzy razy.↩ "],
["warunki.html", "4 Wyrażenia warunkowe 4.1 Warunki 4.2 Warunki zagnieżdzone 4.3 Operatory porównania 4.4 Wyrażenia warunkowe w funkcjach 4.5 Zadania", " 4 Wyrażenia warunkowe Języki programowania opierają się o dwa podstawowe narzędzia pozwalające na sterowanie przepływem operacji. Są to wyrażenia warunkowe oraz pętle. Wyrażenia warunkowe są głównym tematem tego rozdziału, natomiast pętle oraz ich alternatywy są omówione w rozdziale 8. Celem wyrażeń warunkowych jest wykonywanie różnego zadania w zależności od danych wejściowych. 4.1 Warunki Wyrażenie if opiera się o spełnienie (lub niespełnienie) danego warunku. Jeżeli dany warunek jest spełniony, kod wewnątrz wyrażenia if() jest wykonywany. if (warunek){ jeżeli warunek spełniony to wykonaj operację } Wyrażenie if oczekuje, że warunek jest wektorem logicznym o długości jeden, tj. takim który przyjmuje wartość TRUE lub FALSE. Istnieje szereg sposób uzyskania wektora logicznego w R, jednym z nich jest zastosowanie porównania wartości. W poniższym przykładzie wyrażenie if() sprawdza czy wartość obiektu temperatura jest wyższa niż 0. W przypadku, gdy ten warunek jest spełniony (czyli jest TRUE), wyświetlany jest tekst &quot;Dodatnia&quot;. temperatura = 5.4 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } #&gt; [1] &quot;Dodatnia&quot; W przeciwnym razie, gdy warunek nie jest spełniony (czyli ma wartość FALSE), kod wewnątrz warunku nie jest wykonywany. temperatura = -11 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } Warunek if można też tworzyć w uproszczonej formie: if (warunek) spelniony else niespelniony 4.2 Warunki zagnieżdzone Działanie wyrażenia if może być połączone z dodatkowymi wyrażeniami else if oraz else. Te dwa wyrażenia wymagają najpierw wywołania wyrażenia if(). Jeżeli warunek w wyrażeniu if() jest równy TRUE to wykonywany jest kod w nim zawarty, a następnie obliczenie jest kończone. W przypadku, gdy wyrażenie if() otrzyma wartość FALSE, to kod w nim zawarty nie jest wykonywany, a następuje przejście do kolejnego wyrażenia, np. else if() w poniższym przypadku. temperatura = 8.8 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } else if (temperatura &lt; 0) { &quot;Ujemna&quot; } else { &quot;Zero&quot; } #&gt; [1] &quot;Dodatnia&quot; Wyrażenie else if() różni się od else tym, że wymaga ono określenia jaki warunek ma być spełniony. W przypadku else wyliczane są wszystkie przypadki, które nie spełniają wcześniejszych warunków. 4.3 Operatory porównania W tabeli 4.1 można znaleźć listę podstawowych operatorów porównania. Ich celem jest sprawdzanie pewnego warunku i zwrócenie wartości TRUE lub FALSE. Tabela 4.1: Operatory porównania. Operator Wyjaśnienie == Równy != Nie równy %in% Zawiera się w &gt;, &lt; Większy/Mniejszy niż &gt;=, &lt;= Większy/Mniejszy niż lub równy Wyrażenie if() oczekuje wektora logiczego o długości jeden. Często jednak efektem porównania może być wektor o większej długości. Przykładowo, porównanie operatorem == daje w wyniku wektor o długości trzy, a porówanie z użyciem %in% skutkuje wektorem o długości jeden. x = 1 y = c(1, 2, 3) x == y #&gt; [1] TRUE FALSE FALSE x %in% y #&gt; [1] TRUE Sterowanie tym, żeby uzyskany wynik miał oczekiwaną długość jeden może się odbywać też z pomocą operatorów logicznych i funkcji pomocniczych (tabela 4.2). Tabela 4.2: Operatory logiczne i funkcje pomocniczne. Operator Wyjaśnienie ! Negacja (nie) &amp;&amp; Koniunkcja (i) || Alternatywa (lub) all Wszystkie any Którykolwiek Pozwalają one na sprawdzenie czy wszystkie (all()) lub którykolwiek (any()) z elementów obiektu przyjmuje wartość TRUE. x = 1 y = c(1, 2, 3) all(x == y) #&gt; [1] FALSE any(x == y) #&gt; [1] TRUE Możliwe jest też łączenie bardziej złożonych zapytań używając operatora “i” (&amp;&amp;) oraz operatora “lub” (||). x = 1 y = c(1, 2, 3) z = 4 (x %in% y) || !(z %in% y) #&gt; [1] TRUE Powyżej nastąpiło sprawdzenie czy element z obiektu x znajduje się w obiekcie y, a następnie czy element z obiektu z nie znajduje się w obiekcie y. Po wykonaniu ich sprawdzeń nastąpiło ich połączenie używając operatora ||, który daje wartość TRUE, gdy chociaż jedno z zapytań jest prawdziwe. W R istnieją dwa dodatkowe operatory logiczne &amp; i |, które są zwektoryzowaną wersją operatorów &amp;&amp; i ||. Pierwsze dwa porównują wszystkie elementy zadanych wektorów i ich wynikiem może być wektor o długości większej niż 1. Operatory &amp;&amp; i || porównują tylko pierwszy element każdego wektora, a w efekcie zawsze zwracają tylko jedną wartość. Dodatkowo, to one są zazwyczaj używane w wyrażeniach warunkowych. 4.4 Wyrażenia warunkowe w funkcjach Wyrażenia warunkowe są często używanym elementem przy tworzeniu funkcji. Pozwalają one na nie tylko na określanie tego w jaki sposób dana funkcja zadziała, ale też pełnią rolę w sprawdzaniu czy do funkcji zostały wprowadzone poprawne argumenty. Celem poniższej funkcji pogoda() jest wyświetlenie pewnego tekstu w zależności od podanej wartości argumentu temperatura. Pierwszym warunkiem, który można sprawdzić jest określenie czy użytkownik wprowadził do funkcji w postaci argumentu oczekiwany typ danych (więcej o typach danych można dowiedzieć się w rozdziale 5). W tym przypadku typ numeryczny jest oczekiwany, co można sprawdzić używając funkcji is.numeric(), która zwraca TRUE dla danych numerycznych i FALSE dla każdych innych. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(&quot;nie wiem&quot;) Efekt działania powyższej funkcji jest teraz zależy od wejściowego typu danych - jeżeli podana jest wartość numeryczna zwracany jest tekst, a jeżeli ten warunek nie jest spełniony to nic się nie dzieje. Warto, aby tworzona funkcja obsługiwała najczęściej potencjalnie używane rodzaje danych wejściowych. W tym przypadku, warto dodać wyrażenie else, którego efektem jest kolejny tekst sugerujący, że funkcja została wykonana, ale w inny sposób. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(&quot;nie wiem&quot;) #&gt; Dzisiaj nie mamy pomiarów temperatury. Wyrażenia warunkowe można też wielokrotnie zagnieżdzać wewnątrz zdefiniowanej funkcji. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.\\n&quot;)) if (temperatura &lt; 5){ cat(&quot;Ubierz się ciepło!&quot;) } } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. #&gt; Ubierz się ciepło! pogoda(&quot;nie wiem&quot;) #&gt; Dzisiaj nie mamy pomiarów temperatury. Przykładowo, powyżej komunikat &quot;Ubierz się ciepło!&quot; jest wyświetlany w momencie, gdy spełnione zostaną dwa warunki - najpierw wejściowy obiekt temperatura musi być typu numerycznego, a następnie wartość tego obiektu musi być niższa niż 5. 4.5 Zadania Spójrz na poniższe przykłady, ale ich nie wykonuj. Co będzie wynikiem działania każdego z tych przykładów? liczby = c(1, 2) liczby == 1 #1 liczby != 1 #2 liczby %in% 1 #3 all(liczby %in% 1) #4 any(liczby %in% 1) #5 Spójrz na cztery poniższe przykłady, ale ich nie wykonuj. Co będzie wynikiem działania każdego z tych przykładów? (c(1, 2) &gt; 0) &amp; (c(-1, 2) &gt; 0) #1 (c(1, 2) &gt; 0) &amp;&amp; (c(-1, 2) &gt; 0) #2 (c(1, 2) &gt; 0) | (c(-1, 2) &gt; 0) #3 (c(1, 2) &gt; 0) || (c(-1, 2) &gt; 0) #4 Napisz funkcję, która przyjmuje trzy zmienne logiczne x, y i z. Jeżeli tylko jedna lub trzy ze zmiennych ma wartość TRUE wyświetl tekst &quot;Nieparzysta liczba.&quot;, natomiast jeżeli dwie zmienne mają wartość TRUE wyświetl tekst &quot;Parzysta liczba.&quot; Napisz funkcję, która przyjmuje dwie zmienne numeryczne x i y. Jeżeli wszystkie wartości zmiennej x są większe od y wyświetl tekst &quot;Zwycięstwo.&quot;, a w przeciwnym razie wyświetl tekst &quot;Porażka.&quot;. Napisz funkcję, która przyjmuje dwie zmienne numeryczne populacja i powierzchnia. Jeżeli wartości gęstości zaludnienia (liczba osób na jednostkę powierchni) jest wyższa niż 123 wyświetl tekst &quot;Wartość powyżej średniej dla Polski.&quot;. "],
["proste-obiekty.html", "5 Proste obiekty 5.1 Wektory 5.2 Właściwości wektorów 5.3 Podstawowe funkcje 5.4 Działania na wektorach 5.5 Brakujące wartości 5.6 Wydzielanie 5.7 Wydzielanie i przypisanie 5.8 Modyfikowanie obiektów 5.9 Łączenie podstawowych typów obiektów 5.10 Zmiana typów obiektów 5.11 Wektory czynnikowe 5.12 Wektory dat 5.13 Wektory czasu 5.14 Zadania", " 5 Proste obiekty Obiekty w R można podzielić na proste (homogeniczne) i złożone (heterogeniczne). Do podstawowych prostych obiektów należą wektory atomowe (ang. vector) i macierze (ang. matrix), natomiast listy (ang. list) i ramki danych (ang. data frame) to obiekty złożone. W tym rozdziale skupimy się na wektorach atomowych, dla uproszczenia nazywanych dalej po prostu wektorami. Pozostałe podstawowe typy obiektów są omówione w rozdziale 7. Więcej informacji na temat podstawowych typów obiektów można znaleźć w rozdziale “Vectors” książki Advanced R (Wickham 2014). 5.1 Wektory Wektory są podstawowymi elementami, które pozwalają na budowanie bardziej złożonych rodzajów obiektów. Wektor może przyjmować jeden z czterech podstawowych typów26: logiczny (ang. logical) wek_log = c(TRUE, FALSE) wek_log #&gt; [1] TRUE FALSE liczba całkowita (ang. interger) wek_cal = c(5L, -7L) wek_cal #&gt; [1] 5 -7 liczba zmiennoprzecinkowa (ang. double)27 wek_zmi = c(5.3, -7.1) wek_zmi #&gt; [1] 5.3 -7.1 znakowy (ang. character) wek_zna = c(&quot;kot&quot;, &quot;pies&quot;) wek_zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; Wektory przedstawiające liczby stałoprzecinkowe i zmiennoprzecinkowe są często łączone i wspólnie określane jako wektory numeryczne (ang. numeric). Wiele języków programowania posiada zmienne skalarne (tzw. skalary), czyli takie które mogą przyjmować tylko jedną wartość. W R one nie występują, zamiast nich stosowane są wektory o długości jeden. Dodatkowo, istnieje wiele dodatkowych, rzadziej spotykane typów wektorów - czynnikowy (ang. factor), dat (ang. date) i czasu (ang. date-time) (sekcje 5.11, 5.12 i 5.13). 5.2 Właściwości wektorów Każdy wektor ma trzy właściwości - typ, długość i atrybuty. Typ może być sprawdzony używając funkcji typeof(). # typ typeof(wek_zmi) #&gt; [1] &quot;double&quot; Celem funkcji length() jest sprawdzenie długości wektora, czyli tego z ilu wartości (elementów) się on składa. # długość length(wek_zmi) #&gt; [1] 2 Atrybuty pozwalają na dodawanie nowych informacji do wektorów atomowych, a w efekcie dają też możliwość tworzenia bardziej złożonych struktur (rozdział 7). # atrybuty attributes(wek_zmi) #&gt; NULL 5.3 Podstawowe funkcje Z racji bycia podstawowym typem obiektu w R, wektory są używane w bardzo dużej liczbie funkcji. Kilka z podstawowych, często przydatnych funkcji jest podana i wyjaśniona poniżej. Funkcja str() ma na celu wyświetlenie struktury danych. W przypadku wektorów oznacza to skrót od nazwy typu danych (logi - logiczny, int - stałoprzecinkowy, num - zmiennoprzecinkowy (numeryczny), chr - tekstowy), jego długość (np. [1:2] oznacza, że wektor ma dwa elementy), oraz kilka przykładowych wartości tego wektora. str(wek_cal) #&gt; int [1:2] 5 -7 Funkcja names() wyświetla nazwy przypisane kolejnym elementom wektora. names(wek_zna) #&gt; NULL W powyższym przypadku wektor wek_zna nie miał żadnych nazw, w efekcie funkcja names() zwróciła NULL (więcej informacji na temat NULL można znaleźć w sekcji 5.5). Oprócz wyświetlania nazw, funkcja names() daje też możliwość ich nadania. names(wek_zna) = c(&quot;a&quot;, &quot;b&quot;) wek_zna #&gt; a b #&gt; &quot;kot&quot; &quot;pies&quot; names(wek_zna) #&gt; [1] &quot;a&quot; &quot;b&quot; Funkcja seq ma na celu generowanie ciągów liczbowych28. Pierwszym jego argumentem jest from czyli początkowa liczba w ciągu a drugi argument to oznacza maksymalną możliwą liczbę w ciągu. Obie te liczby mogą być wektorami o długości jeden. Dodatkowo ta funkcja wymaga zdefiniowania jeszcze jednego argumentu, np. by lub length.out. Argument by określa co ile wartości w ciągu mają rosnąć od wartości początkowej. seq(1, 365, by = 7) #&gt; [1] 1 8 15 22 29 36 43 50 57 64 71 78 85 92 99 106 113 #&gt; [18] 120 127 134 141 148 155 162 169 176 183 190 197 204 211 218 225 232 #&gt; [35] 239 246 253 260 267 274 281 288 295 302 309 316 323 330 337 344 351 #&gt; [52] 358 365 Alternatywnie, argument length.out ustala jakiej długości ma być wynikowy ciąg, a na podstawie tego tworzone są wartości w równych odstępach. seq(1, 365, length.out = 10) #&gt; [1] 1.0 41.4 81.9 122.3 162.8 203.2 243.7 284.1 324.6 365.0 Funkcja rep służy powielaniu zadanej wartości podaną liczbę razy. W poniższym przykładzie, wartość 11 jest powielona 4 razy. rep(11, 4) #&gt; [1] 11 11 11 11 Ta funkcja działa też na różnego typu wektorach - logicznych, numerycznych, czy tekstowych. rep(wek_zna, 4) #&gt; a b a b a b a b #&gt; &quot;kot&quot; &quot;pies&quot; &quot;kot&quot; &quot;pies&quot; &quot;kot&quot; &quot;pies&quot; &quot;kot&quot; &quot;pies&quot; 5.4 Działania na wektorach Wiele podstawowych operacji w R jest zwektoryzowana. Przykładowo, możliwe jest pomnożenie kolejnych elementów jednego wektora przez kolejne elementy drugiego wektora. a = c(1, 2, 3) b = c(3, 5, 10) a * b #&gt; [1] 3 10 30 Kod zapisany w powyższy sposób zajmuje niewiele miejsca i jest łatwy do odczytania. Alternatywnie można by ten problem rozbić na podelementy i je wymnożyć. a1 = 1 a2 = 2 a3 = 3 b1 = 3 b2 = 5 b3 = 10 a1 * b1 #&gt; [1] 3 a2 * b2 #&gt; [1] 10 a3 * b3 #&gt; [1] 30 Jak można szybko zaobserwować, mnożenie kolejnych elementów w ten sposób wymaga zapisania znacznie więcej kodu i jest trudniejsze do odczytania. Jest jeszcze trzecia możliwość użycie pętli (rozdział 8). y = numeric(length = 3) for (i in 1:3){ y[i] = a[i] * b[i] } y #&gt; [1] 3 10 30 Stworzony kod zajmuje mniej miejsca, ale nadal nie jest on bardzo łatwy do szybkiego zrozumienia. Wektoryzacja ma też inną zaletę - obliczenia wykonywane w ten sposób są szybkie. W przypadku stosowania niektórych operacji, np. mnożenia czy dodawania, R wykorzystuje w tle (bez wiedzy użytkownika) zoptymalizowane funkcje zapisane w języku C lub Fortran. W przypadku, gdy dwa wektory mają różną długość, wówczas następuje proces nazwany recyklingiem (ang. recycling) - elementy krótszego wektora są powtarzane aż do momentu gdy osiągnie on taką samą długość jak ten dłuższy, a dopiero później następuje wykonanie wybranego działania. W takiej sytuacji pojawi się też poniższy komunikat ostrzeżenia. a = c(1, 2, 3) d = c(3, 5) a * d #&gt; Warning in a * d: longer object length is not a multiple of shorter object #&gt; length #&gt; [1] 3 10 9 Więcej informacji na temat wektoryzowania kodu można znaleźć w rozdziale 8. 5.5 Brakujące wartości Wyobraź sobie, że wykonujesz codziennie o 12:00 pomiar temperatury. temperatura = c(8.2, 10.3, 12.0) Czwartego dnia twój termometr się popsuł i nie można było wykonać pomiaru. Co należałoby w takim razie zrobić? Można by pominąć ten pomiar, naprawić termometr i wykonać pomiar kolejnego dnia. Wówczas jednak mielibyśmy cztery wartości dla pięciu dni. Inną możliwą opcją byłoby użycie wartości, która stałaby się kodem wartości brakujących, np. 999. Problemem tego rozwiązania jest to w jaki sposób należałoby, np. wyliczyć średnią w tym obiekcie. temperatura = c(8.2, 10.3, 12.0, 999) Najlepszą opcją byłoby wykorzystanie wbudowanego oznaczenia wartości brakujących w R - NA. temperatura = c(8.2, 10.3, 12.0, NA) Zachowanie wartości NA (ang. Not Available) jest bardzo intuicyjne. Przykładowo, jeżeli nie znamy jakiejś wartości to jeżeli dodamy do niej 2 to również nie wiemy jaki mamy wynik. NA + 2 #&gt; [1] NA 5 &gt; NA #&gt; [1] NA Podobnie będzie w sytuacji, gdy chcemy wyliczyć średnią na podstawie wektora, który zawiera wartość NA. mean(temperatura) #&gt; [1] NA W takich przypadkach najpierw należałoby usunąć wartość NA a następnie wyliczyć średnią z pozostałych wartości w tym wektorze. Aby ułatwić taką operację w wielu funkcjach istnieje argument na.rm. W momencie, gdy jest on ustalony na TRUE, to wszystkie przypadki NA są usuwane na potrzeby wyliczania średniej. mean(temperatura, na.rm = TRUE) #&gt; [1] 10.2 Do sprawdzenia czy w wektorze znajduje się wartość NA służy funkcja is.na(). is.na(temperatura) #&gt; [1] FALSE FALSE FALSE TRUE R posiada też kilka dodatkowych specjalnych obiektów, takich jak NULL, NaN, Inf oraz -Inf. NULL ma długość zero i nie posiada żadnych atrybutów. Może on posłużyć np. do usuwania kolumn w ramkach danych. NaN (ang. Not a Number) oznacza wartość, która nie jest zdefiniowaną lub nie może być reprezentowana w inny sposób, przykładowo 0/0. Inf i -Inf (ang. Infinity) jest wynikiem obliczeń, które dały bardzo dużą wartość dodatną lub ujemną, przykładowo 9^999. 5.6 Wydzielanie R posiada trzy podstawowe operatory wydzielania (ang. subsetting) - [], [[]] oraz $, które działają w różny sposób w zależności od tego czy wydzielamy wektory, macierze, ramki danych czy listy. W tym rozdziale skupimy się na wydzielaniu elementów z wektora przy użyciu operatora []. Więcej na temat wydzielania innych obiektów można znaleźć w rozdziale 7. Wydzielanie wektorów używając operatora [] może odbywać się używając jednego z poniższych zapytań: Na podstawie pozycji. Na podstawie wektora logicznego. Na podstawie nazwy. Używając elementu pustego. Używając zera. W przypadku wydzielania na podstawie pozycji konieczne jest podanie wektora, który wskazuje numer elementów, które mają zostać wybrane. temperatura[c(1, 3)] #&gt; [1] 8.2 12.0 Alternatywnie, możliwe jest też użycie znaku minus (-) przed definicją pozycji. Wówczas wybrane zostaną wszystkie elementy wektora oprócz tych w podanych pozycjach. temperatura[-c(2, 4)] #&gt; [1] 8.2 12.0 Drugim sposobem jest użycie wektora logicznego. W takim przypadku elementy określone jako prawda (TRUE) zostają wybrane. temperatura[c(TRUE, FALSE, TRUE, FALSE)] #&gt; [1] 8.2 12.0 Możliwe jest też stworzenie wektora logicznego poprzez wykonanie prostego zapytania. Poniżej wybrano tylko te elementy wektora temperatura, gdzie wartość w wektorze temperatura była wyższa niż 10. temperatura[temperatura &gt; 10] #&gt; [1] 10.3 12.0 NA Wydzielanie na podstawie nazwy wymaga aby elementy w wektorze były nazwane. names(temperatura) = c(&quot;Poniedziałek&quot;, &quot;Wtorek&quot;, &quot;Środa&quot;, &quot;Czwartek&quot;) temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA Następnie wybór elementów odbywa się poprzez podanie nazw wybranych elementów. temperatura[c(&quot;Wtorek&quot;, &quot;Czwartek&quot;)] #&gt; Wtorek Czwartek #&gt; 10.3 NA Czwartą metodą jest zapytanie w oparciu o pusty element. W przypadku prostych obiektów, efektem takiego wydzielania jest oryginalny wektor. Ta metoda jest jednak bardzo użyteczna dla obiektów złożonych, takich jak macierze czy ramki danych (rozdział 7). temperatura[] #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA Ostatnią metodą jest użycie zera. W efekcie zostanie zwrócony wektor o długości zero, ale zachowujący oryginalne właściwości, jak np. bycie wektorem numerycznym (numeric) poniżej. Takie zachowanie może być przydatne podczas tworzenia nowych obiektów w oparciu o już istniejące. temperatura[0] #&gt; named numeric(0) 5.7 Wydzielanie i przypisanie Wydzielanie elementów może mieć kilka dodatkowych zastosowań oprócz wyświetlania wybranych wartości. Kolejną możliwością jest tworzenie nowych obiektów na podstawie wydzieleń. W takich sytuacjach działa każda z metod wyjaśnionych w powyższej sekcji, np. wydzielenie przez nazwę. temperatura_pon = temperatura[&quot;Poniedziałek&quot;] temperatura_pon #&gt; Poniedziałek #&gt; 8.2 Dodatkowo, wydzielanie może przyjmować bardziej złożoną postać. Poniżej nastąpiło stworzenie nowego obiektu temperatura_10 składającego się z wszystkich elementów wektora temperatura, których wartość jest wyższa od 10 i nie jest NA. temperatura_10 = temperatura[temperatura &gt; 10 &amp; !is.na(temperatura)] temperatura_10 #&gt; Wtorek Środa #&gt; 10.3 12.0 5.8 Modyfikowanie obiektów Trzecim zastosowaniem wydzielania jest modyfikowanie obiektów. Poprzez wydzielenie możliwe jest wskazanie, które elementy wektora mają być zamienione i na jakie wartości. Przykładowo, wektor temperatura zawiera cztery wartości nazwane kolejnymi dniami tygodnia. W tym wektorze &quot;Czwartek&quot; posiada wartość brakującą NA. temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[&quot;Czwartek&quot;] #&gt; Czwartek #&gt; NA Aby zamienić wartość tego elementu należy go wydzielić a następnie przypisać temu elementowi nową wartość. Efektem jest trwała zmiana obiektu temperatura. temperatura[&quot;Czwartek&quot;] = 9.1 temperatura[&quot;Czwartek&quot;] #&gt; Czwartek #&gt; 9.1 temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 9.1 5.9 Łączenie podstawowych typów obiektów Właściwością wektora jest to, że może on przyjmować tylko jeden typ. Przykładowo poniżej wyświetlony jest wektor logiczny przyjmujący wartość FALSE. c(FALSE) #&gt; [1] FALSE Co stanie się, gdy będziemy chcieli taki wektor połączyć z wektorem innego typu, np. numerycznego czy tekstowego? Próba stworzenia obiektu składającego się z wielu typów spowoduje wymuszenie (ang. coercion) do najbliższego możliwego typu. Odbywa się to zgodnie z zasadą: logiczny -&gt; liczba całkowita -&gt; liczba zmiennoprzecinkowa -&gt; znakowy. Łącząc wektor logiczny i liczby całkowitej otrzyma się wektor składający się z liczb całkowitych, gdzie FALSE zostanie zamienione na 0. c(FALSE, 2L) #&gt; [1] 0 2 Łączenie wektorów logicznego, liczby całkowitej i liczby zmiennoprzecinkowej w efekcie da wektor zmiennoprzecinkowy. c(FALSE, 2L, 3.1) #&gt; [1] 0.0 2.0 3.1 W sytuacji, gdy którykolwiek element będzie tekstem, cały wektor zostaje zamieniony na tekst. c(FALSE, 2L, 3.1, &quot;kot&quot;) #&gt; [1] &quot;FALSE&quot; &quot;2&quot; &quot;3.1&quot; &quot;kot&quot; 5.10 Zmiana typów obiektów Do zmiany typu obiektu29 służą funkcje as.logical(), as.integer(), as.double(), oraz as.character(). as.logical(c(&quot;FALSE&quot;, &quot;TRUE&quot;)) # znakowy na logiczny #&gt; [1] FALSE TRUE as.integer(c(&quot;3&quot;, &quot;2&quot;)) # znakowy na liczba całkowita #&gt; [1] 3 2 as.double(c(3L, 2L)) # liczba całkowita na liczba zmiennoprzecinkowa #&gt; [1] 3 2 as.character(c(3L, 2L)) # liczba całkowita na znakowy #&gt; [1] &quot;3&quot; &quot;2&quot; Do sprawdzenia czy dany obiekt należy do wybranego typu służą funkcje is.logical(), is.integer(),is.double(), oraz is.character(). 5.11 Wektory czynnikowe Wektory czynnikowe służą do przechowywania informacji o pewnych kategoriach. Mogą to być, na przykład, wielokrotnie powtórzone nazwy miast czy krajów, czy też określenia płci w danych statystycznych. Wektory czynnikowe wspomagają określanie wartości dla kolejnych grup o tej samej nazwie. tekst = c(&quot;Poznań&quot;, &quot;Kraków&quot;, &quot;Warszawa&quot;, &quot;Poznań&quot;) Zamiana wektora tekstowego na czynnikowy odbywa się z użyciem funkcji as.factor(). czynn = as.factor(tekst) czynn #&gt; [1] Poznań Kraków Warszawa Poznań #&gt; Levels: Kraków Poznań Warszawa Wektory czynnikowe są wewnętrznie w R reprezentowane jako wartości stałoprzecinkowe. Dodatkowo, posiadają one pewne informacje zaszyte w atrybutach, w tym wartości wszystkich kategorii oraz stwierdzenie posiadanej klasy [^Posiadanie attubutu class zamienia je w tak zwane obiekty S3, które zachowują się inaczej niż normalne wektory atomowe.]. typeof(czynn) #&gt; [1] &quot;integer&quot; length(czynn) #&gt; [1] 4 attributes(czynn) #&gt; $levels #&gt; [1] &quot;Kraków&quot; &quot;Poznań&quot; &quot;Warszawa&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Możliwa jest również zamiana w drugą stronę - z wektora czynnikowego na wektor tekstowy używając funkcji as.character(). tekst2 = as.character(czynn) tekst2 #&gt; [1] &quot;Poznań&quot; &quot;Kraków&quot; &quot;Warszawa&quot; &quot;Poznań&quot; 5.12 Wektory dat R ma wbudowaną reprezentację dat w postaci klasy Date. dzis = Sys.Date() dzis #&gt; [1] &quot;2019-04-07&quot; Pomimo tego, że powyżej data jest wyświetlona jako tekst (zwróć uwagę na cudzysłowia), wewnętrznie w R jest ona reprezentowana jako wartość zmiennoprzecinkowa. typeof(dzis) #&gt; [1] &quot;double&quot; length(dzis) #&gt; [1] 1 attributes(dzis) #&gt; $class #&gt; [1] &quot;Date&quot; Sprawdzenie tej wartości możliwe jest poprzez użycie funkcji unclass(). unclass(dzis) #&gt; [1] 17993 Wynik, 17993, oznacza liczbę dni od 1970-01-01.30 W tej reprezentacji dni przed 1970-01-01 określane wewnętrznie są poprzez wartości ujemne. stara_data = as.Date(&quot;1912-04-13&quot;) unclass(stara_data) #&gt; [1] -21082 Tworzenie wektora dat odbywa się używając funkcji as.Date(). daty = as.Date(c(&quot;2011-02-02&quot;, &quot;2011-02-03&quot;)) daty #&gt; [1] &quot;2011-02-02&quot; &quot;2011-02-03&quot; Funkcja as.Date() oczekuje podanych wartość w postaci YYYY-MM-DD (wyjaśnienie można znaleźć w sekcji 2.4.5), ale możliwe jest również wymuszenie innej postaci danych wejściowych poprzez użycie argumentu format. 5.13 Wektory czasu W R istnieją również wbudowane reprezentacje dat i godzin (inaczej zwane data-czas, ang. date-times). Najczęściej używaną jest klasa POSIXct, która jest wektorem przedstawiającym liczbę sekund of 1970-01-01.31 czas = as.POSIXct(&quot;2011-02-02 10:33&quot;, tz = &quot;CET&quot;) czas #&gt; [1] &quot;2011-02-02 10:33:00 CET&quot; Wewnętrznie w R jest ona również reprezentowana jako wartość zmiennoprzecinkowa. typeof(czas) #&gt; [1] &quot;double&quot; length(czas) #&gt; [1] 1 attributes(czas) #&gt; $class #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; #&gt; #&gt; $tzone #&gt; [1] &quot;CET&quot; Przykładowo, &quot;2011-02-02 10:33&quot; miało miejsce 1296639180 sekund od 1970-01-01. unclass(czas) #&gt; [1] 1.3e+09 #&gt; attr(,&quot;tzone&quot;) #&gt; [1] &quot;CET&quot; Ważnym elementem reprezentacji czasu jest określenie strefy czasowej. Można ją zdefiniować w funkcji as.POSIXct() używając argumentu tz, ale też można zmienić strefę czasową istniejącego wektora poprzez modyfikację jego atrybutów. W poniższym przykładzie nastąpiła zmiana strefy czasowej z czasu środkowoeuropejskiego (&quot;CET&quot;) na czas pacyficzny.32 attributes(czas)$tzone = &quot;America/Los_Angeles&quot; czas #&gt; [1] &quot;2011-02-02 01:33:00 PST&quot; Więcej informacji na temat stref czasowych używanych w R można znaleźć w pliku pomocy ?timezones. R posiada też dodatkowe klasy specjalne, np POSIXlt przechowująca informacje o dacie w postaci listy oraz difftime reprezentująca czas trwania. 5.14 Zadania Wykonujesz trzy razy dziennie (o godzinie 7:00, 15:00 i 23:00) pomiar temperatury. W ostatnich dwóch dniach (2019-03-11 i 2019-03-12) pomierzone wartości to 0, 5,2, 3,9, 4,1, 8,7, 5,3 stopni Celsjusza. Stwórz nowy wektor pomiary zawierający te wartości. Nazwij kolejne elementy tego wektora używając kolejnych liter alfabetu. Pomyśl jakie właściwości ma wektor pomiary - jaki ma typ, jaką ma długość, jakie ma atrybuty? Jeżeli jesteś przekonany co do odpowiedzi to sprawdź to pisząc odpowiedni kod. Znajdź i wyświetl wartość 4.1 w wektorze pomiary używając kilku różnych sposobów wydzielania. Ile możliwości udało się Tobie znaleźć? Znajdź automatycznie położenie najwyższej wartości wektora pomiary i na jej podstawie stwórz nowy obiekt pomiary_max. Wydziel wszystkie pomiary równe i niższe niż 5 stopni Celsjusza. Na ich podstawie stwórz nowy obiekt pomiary_n5. Inna osoba również wykonywała pomiary temperatury w tym samym czasie. Jej pomierzone wartości to -1.1, 4,2, 2,4, 3,1, 7,1, 4,2 stopni Celsjusza. Dodaj te wartości do obiektu pomiary. Stwórz nowy wektor nazwy_stacji zawierający nazwę Twojej stacji pomiarowej (&quot;Punkt 31&quot;) oraz stacji drugiej osoby (&quot;Stacja Thule&quot;), którego długość ma być równa długości wektora pomiary. Wektor nazwy_stacji powinien być klasy czynnikowej. Stwórz nowy wektor daty_pomiarow zawierający rok, miesiąc i dzień pomiarów w wektorze pomiary. Stwórz nowy wektor czas_pomiarow zawierający datę i czas pomiarów w wektorze pomiary. Zdefiniuj też odpowiednią strefę czasową. Stwórz nowy wektor id_pomiarow zawierający kolejne liczby całkowite od 1 do liczby pomiarów w wektorze pomiary. Zastanów się (bez wykonywania) co jest efektem działania poniższego kodu. Kiedy taka operacja mogłaby być konieczna? pomiary[3] = 3.3 Zastanów się (bez wykonywania) co jest efektem działania poniższego kodu. Kiedy taka operacja mogłaby być konieczna? pomiary[pomiary &lt;= 0] = NA Zastanów się (bez wykonywania) co jest efektem działania poniższego kodu. wartosci1 = as.character(c(1, 3, 5)) mean(wartosci1) Zastanów się (bez wykonywania) co jest efektem działania poniższego kodu. wartosci2 = as.numeric(c(1, &quot;trzy&quot;, 5)) wartosci2 mean(wartosci2) Wykonaj poniższą funkcję. Następnie wydziel nowy wektor pomiary2, który nie zawiera wartości NA. pomiary[pomiary &lt;= 0] = NA Trzecia osoba również wykonywała pomiary temperatury w tym samym czasie. Przesłała ona Tobie taki wektor - c(-5.2, 3.0, 1.1, &quot;zaspałem&quot;, 6.4, 2.2). Jakiej klasy jest ten wektor a jaka powinna być jego klasa, aby możliwe było wykonywanie na niej obliczeń, np. wyliczanie średniej? Jak to można uzyskać? Bibliografia "],
["tekst.html", "6 Tekst 6.1 Reprezentacja tekstu 6.2 Podstawowe operacje na tekście 6.3 Wydzielanie tekstu 6.4 Wyrażenia regularne 6.5 Wydzielanie tekstu - regex 6.6 Zamiana tekstu - regex 6.7 Wyszukiwanie plików 6.8 Zadania", " 6 Tekst Podstawowymi typami danych w R są wektory logiczne, numeryczne i znakowe (sekcja 5.1). Pierwsze z nich przyjmują dwie formy - TRUE i FALSE, przez co istnieje pewna skończona liczba operacji, które można na nich wykonać. Wektory numeryczne mogą przyjmować wiele form, ale najczęściej są one przetwarzanie używając podstawowych operacji arytmetycznych, takich jak dodawanie, odejmowanie, mnożenie czy dzielenie. Wektory znakowe są natomiast najbardziej zróżnicowane - mogę przyjmować różne formy (nawet w zależności od przyjętego alfabetu), w tym pozwalają one także na przechowywanie wartości logicznych czy numerycznych. Celem tego rozdziału jest przedstawienie najczęściej spotykanych operacji na tekście, takich jak jego wyszukiwanie, wydzielanie czy zamiana. Więcej na temat przetwarzania tekstu można znaleźć w rozdziale “Strings” książki R for Data Science (Wickham and Grolemund 2016). 6.1 Reprezentacja tekstu Typ znakowy jest określany poprzez użycie cudzysłowia &quot; lub '. Ważne tutaj jest, aby rozpoczynać i kończyć tekst tym samym cudzysłowiem. t1 = &quot;kot&quot; t2 = &#39;pies&#39; t3 = &#39;&quot;W teorii, teoria i praktyka są tym samym. W praktyce, nie są.&quot; - Yogi Berra&#39; W momencie, gdy tekst nie będzie kończył się cudzysłowiem, wykonanie kodu jest niemożliwe. Wówczas zamiast znaku &gt;, oznaczającego nową linię wykonywanego kodu, pojawi się znak +. Oznacza on, że wykonanie kodu nie może zostać zakończone. &gt; &quot;Mój pierwszy alfabet + + W takiej sytuacji należy nacisnąć klawisz Esc, aby przerwać wykonywanie operacji, a następnie poprawić wpisany kod. 6.2 Podstawowe operacje na tekście Jedną z podstawowych operacji na wektorach znakowych jest ich łączenie. Do tego celu służy funkcja paste()33. paste(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;t o k o t&quot; Efekt działania funkcji paste() jest jeden wektor tekstowy, który składa się z wejściowych wektorów oddzielonych domyślnie spacjami. Funkcja paste() ma jednak również dodatkowy argument sep, który pozwala na dowolne określanie separatora. Ostatnim argumentem tej funkcji jest collapse, który łączy elementy jednego wektora tekstowego. R oferuje też uproszczoną postać tej funkcji o nazwie paste0(), w której nie ma znaku seperatora. paste0(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;to kot&quot; Te funkcje są używane w sytuacjach, gdy chcemy połączyć stały, znany tekst, wraz z tekstem wprowadzanym przez użytkownika lub pochodzącym z innego źródła. Poniżej stworzono dwie nowe zmienne imie i wiek, których treść złączono ze słowami &quot;ma&quot; i &quot;lat.&quot;. imie = &quot;Olek&quot; wiek = 77 tekst1 = paste(imie, &quot;ma&quot;, wiek, &quot;lat.&quot;) tekst1 #&gt; [1] &quot;Olek ma 77 lat.&quot; Takie konstrukcje są często używane w funkcjach. Powyższy przykład możnaby przepisać jako: lata = function(imie, wiek){ paste(imie, &quot;ma&quot;, wiek, &quot;lat.&quot;) } lata(&quot;Asia&quot;, 61) #&gt; [1] &quot;Asia ma 61 lat.&quot; Dodatkowo w R istnieje alternatywa dla paste() i paste0() w postaci funkcji sprintf(). Kolejne podstawowe funkcje, toupper() i tolower() zamieniają cały istniejący tekst na taki który posiada tylko duże lub małe litery. toupper(tekst1) #&gt; [1] &quot;OLEK MA 77 LAT.&quot; tolower(tekst1) #&gt; [1] &quot;olek ma 77 lat.&quot; Są one używane w sytuacjach, gdy posiadamy dane, w których jeden tekst jest podany w kilku formach i chcemy je ujednolicić. R posiada też wiele innych wbudowanych funkcji do obsługi tekstu (np. grep()), ale istnieją też specjalne pakiety poświęcone temu zagadnieniu, w tym pakiet stringr (Wickham 2019). library(stringr) Większość funkcji tego pakietu zaczyna się od prefiksu str_ co ułatwia znajdowanie funkcji w tym pakiecie i zmniejsza szansę na nałożenie się funkcji o takiej samej nazwie z innego pakietu. Przykładową operacją na tekście jest jego sortowanie (czyli układanie alfabetycznie), do którego służy funkcja str_sort(). tekst2 = c(&quot;czosnek&quot;, &quot; hałas&quot;, &quot;ćma &quot;) tekst2 #&gt; [1] &quot;czosnek&quot; &quot; hałas&quot; &quot;ćma &quot; str_sort(tekst2) #&gt; [1] &quot; hałas&quot; &quot;ćma &quot; &quot;czosnek&quot; W powyższym przykładzie oczkiwalibyśmy ułożenia, w których &quot;hałas&quot; byłby na ostatnim miejscu. Nie jest tak z powodu istnienia z przodu tego wyrazu znaku niedrukowalnego - spacji. Aby usunąć spacje z przodu i tyłu tekstu można użyć funkcji str_trim(). tekst2 = str_trim(tekst2) tekst2 #&gt; [1] &quot;czosnek&quot; &quot;hałas&quot; &quot;ćma&quot; W tej chwili możmy użyć funkcji str_sort() jeszcze raz. str_sort(tekst2) #&gt; [1] &quot;ćma&quot; &quot;czosnek&quot; &quot;hałas&quot; Teraz &quot;hałas&quot; jest poprawnie na ostanim miejscu, ale na pierwszej pozycji jest &quot;ćma&quot; zamiast &quot;czosnek&quot;. Różne alfabety na świecie mają inne znaki oraz ich kolejność. Domyślnie funkcja str_sort() używa alfabetu angielskiego, co w efekcie powoduje niepoprawne ułożenie polskich znaków. Do rozwiązania tego problemu służy argument locale, w którym można określić jaki alfabet ma być używany. str_sort(tekst2, locale = &quot;pl&quot;) #&gt; [1] &quot;czosnek&quot; &quot;ćma&quot; &quot;hałas&quot; str_sort(tekst2, locale = &quot;cs&quot;) #&gt; [1] &quot;ćma&quot; &quot;czosnek&quot; &quot;hałas&quot; Powyżej można zobaczyć dwa przykłady - ułożenia tekstu według polskiego i czeskiego alfabetu34. 6.3 Wydzielanie tekstu Częstym przypadkiem jest potrzeba wydzielenia tylko fragmentu tekstu. W tej sekcji zostanie pokazane jak wydzielać tekst na podstawie pozycji, ale możliwe jest również wydzielanie tekstu na podstawie wzorca (zobacz sekcję 6.5). Wydzielanie na podstawie pozycji jest używane w sytuacjach, gdy struktura wejściowego tekstu jest nam znana i stabilna, np. gdy interesuje nas wybranie fragmentu tekstu z automatycznie generowanych raportów. tekst1 = &quot;Olek ma 77 lat.&quot; W przypadku wydzielania tekstu na podstawie pozycji należy określić pozycję pierwszego i ostatniego znaku, który nas interesuje. Można to zrobić na kilka sposobów. Pierwszy z nich polega na określeniu położenia znaków od lewej strony, np. poniższy kod wybiera tekst rozpoczynający się od 9 znaku i kończący się na znaku 15 włącznie. str_sub(tekst1, start = 9, end = 15) #&gt; [1] &quot;77 lat.&quot; Definiowanie pozycji może się też odbywać od prawej strony tekstu używając znaku -. str_sub(tekst1, start = 9, end = -1) #&gt; [1] &quot;77 lat.&quot; W powyższym przykładzie wybierany jest tekst zaczynający się na 9 znaku a kończący na pierwszym znaku od końca włącznie. Natomiat poniżej wybrany jest tekst zaczynający się na siódmym znaku od końca i kończący na pierwszym od kónca włącznie. str_sub(tekst1, start = -7, end = -1) #&gt; [1] &quot;77 lat.&quot; 6.4 Wyrażenia regularne Sprawdzanie czy dany tekst występuje w wektorze można wykonać używając funkcji str_detect(). tekst3 = c(&quot;Magdalena&quot;, &quot;Lena&quot;, &quot;1Lena.csv&quot;, &quot;LLena&quot;, &quot;Helena&quot;, &quot;Anna&quot;, &quot;99&quot;) W takim wypadku konieczne jest zdefiniowanie argumentu pattern, czyli wzorca tekstowego, który nas interesuje. Aby znaleźć wszystkie wystąpienia (nawet fragmentaryczne) słowa &quot;Lena&quot; można użyć poniższego kodu. str_detect(tekst3, pattern = &quot;Lena&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE Jego efektem będzie wektor logiczny wskazujący, które elemeny zawierają wybrany wzorzec (TRUE) oraz które go nie zawierają (FALSE). Wzorzec zdefiniowany w tej sposób jest czuły na wielkość znaków dlatego też zapytanie używając &quot;Lena&quot; da inny wynik niż takie używając &quot;lena&quot;. str_detect(tekst3, pattern = &quot;lena&quot;) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE W celu ułatwienia wyszukiwania złożonych fraz powstały wyrażenia regularne. Wyrażenia regularne (ang. regular expressions), często określane jako regex to sposób opisywanie wzorców tekstu. Używając wyrażeń regularnych możliwe jest, między innymi, znajdowanie tekstu lub zamienienie, który spełnia wymagane warunki. Wyrażenia regularne są powszechnie używane w wyszukiwarkach internetowych, edytorach tekstu, oraz wielu językach programowania. Wyrażenia regularne opierają się o stosowanie szeregu operatorów (metaznaków) wymienionych w tabeli 6.1. Tabela 6.1: Metaznaki w wyrażeniach regularnych Operator Wyjaśnienie ^ Określa początek tekstu/linii $ Określa koniec testu/linii () Grupowanie | Alternatywa (lub) [] Wymienia dozwolone znaki [^] Wymienia niedozwolone znaki * Poprzedni znak zostanie wybrany zero lub więcej razy + Poprzedni znak zostanie wybrany jeden lub więcej razy ? Poprzedni znak zostanie wybrany zero lub jeden raz {n} Poprzedni znak zostanie wybrany n razy . Jakikolwiek znak oprócz nowej linii (\\n) \\ Pozwala na użycie specjalnych znaków Wymienione powyżej znaki (np. ^ czy .) mają specjalne znaczenie. W związku z tym, jeżeli chcemy wyszukać tekstu zawierającego specjalny znak, musimy użyć ukośnik wsteczny (\\, ang. backslash). Istnieje wiele dodatkowych znaków specjalnych, np. \\n - nowa linia, \\t - tabulator, \\d - każdy znak numeryczny (stałoprzecinkowy), \\s - znak niedrukowalny, np. spacja, tabulator, nowa linia. Sprawdźmy działanie wyrażeń regularnych na kilku przykładach. W pierwszym z nich określiliśmy nasz wzorzec jako &quot;^L&quot;, co oznacza, że interesują nas tylko elementy wektora tekst3 rozpoczynające się od dużej litery L. str_detect(tekst3, pattern = &quot;^L&quot;) #&gt; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE Do określenia zakończenia wzorca służy metaznak $. Poniżej wyszukano elementy, które kończą się na ena. str_detect(tekst3, pattern = &quot;ena$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE FALSE FALSE Operatory () i | można łączyć, aby zdefiniować alternatywy. Przykładowo, interesują nas elementy, które kończą się na ena lub nna. str_detect(tekst3, pattern = &quot;(ena|nna)$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE TRUE FALSE W wyrażeniach regularnych można też stosować pewne skrótowe polecenia. W poniższym przypadku interesują nas elementy, które zawierają jakiekolwiek znaki od małego a do małego z oraz dużego A do dużego Z. str_detect(tekst3, pattern = &quot;[a-zA-Z]&quot;) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE Podobnie można określać wartości numeryczne - np. tylko elementy zawierające wartości od 0 do 9. str_detect(tekst3, pattern = &quot;[0-9]&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE Celem metaznaku + jest określenie, że poprzedni znak musi wystąpić jeden lub więcej razy. Poniżej interesują nas tylko takie elementy, w których litera L występuje raz lub więcej. str_detect(tekst3, pattern = &quot;L+&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE W wyrażeniach regularnych metaznak ^ określa początek tekstu/linii, ale ma on też inne zastosowanie, gdy jest użyty w kwadratowym nawiasie. Przykładowo [^L] oznacza, że szukamy wszystkich elementów nie zawierających litery L. W poniższym przykładzie nie interesują nas elementy, które zaczynają się od jednej lub więcej litery L. str_detect(tekst3, pattern = &quot;^[^L]+&quot;) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE Metaznak . służy do określania jakikolwiek znaku, a ukośnik wsteczny (\\) służy do określania innych znaków specjalnych. Dlatego też, jeżeli chcemy wyszukać elementów zawierających kropki (.) musimy połączyć ukośnik wsteczny z tym znakiem. str_detect(tekst3, pattern = &quot;\\.&quot;) #&gt; Error: &#39;\\.&#39; is an unrecognized escape in character string starting &quot;&quot;\\.&quot; Powyższy przykład daje jednak komunikat błędu - aby użyć ukośnik wsteczny do zasygnalizowania, że interesuje nas kropka musimy wprowadzić go dwa razy35. str_detect(tekst3, pattern = &quot;\\\\.&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE Celem funkcji str_detect() jest wskazanie, który element spełnia dane zapytanie. Do wydzielenia elementu służy funkcja str_subset(). str_subset(tekst3, pattern = &quot;\\\\.&quot;) #&gt; [1] &quot;1Lena.csv&quot; Umiejętności używania wyrażeń regularnych można trenować używając różnych zasobów internetowych, np. strony https://regexr.com/, https://regex101.com/, czy https://regexcrossword.com/. Pomocne w zrozumieniu bardziej zaawansowanych elementów wyrażeń regularncych może być też prezentacja Best of Fluent 2012: /Reg(exp){2}lained/: Demystifying Regular Expressions oraz książka Mastering Regular Expressions (Friedl 2006). 6.5 Wydzielanie tekstu - regex Innym często spotykanym problemem w pracy z tekstem jest posiadanie długiego elementu tekstowego, z którego chcemy tylko wydobyć pewien fragment. W sekcji 6.3 używaliśmy do tego pozycji, ale możemy zastosować również wzroce do tego celu. tekst_pomiary = &quot;Wrocław: 23.5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3&quot; Wektor tekst_pomiary zawiera tylko jeden element tekstowy, w którym wymienione są kolejne miasta i ich wartości. Wyobraźmy sobie, że interesują nas tylko nazwy miast zawarte w powyższym wektorze. Do wydzielania tekstu na podstawie wyrażeń regularnych służy funkcja str_extract(). str_extract(tekst_pomiary, pattern = &quot;[a-zA-Z]*&quot;) #&gt; [1] &quot;Wroc&quot; Podaliśmy jako wzorzec wszyskie litery od małego a do małego z oraz dużego A do dużego Z. Niestety w efekcie otrzymaliśmy tylko Wroc - taka definicja wzorca obejmuje tylko litery z angielskiego alfabetu. Aby to naprawić możemy dodać do tego wzorca polskie litery. str_extract(tekst_pomiary, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*&quot;) #&gt; [1] &quot;Wrocław&quot; Tym razem otrzymaliśmy pełną nazwę pierwszego miasta, ale nie żadnego kolejnego. Funkcja str_extract() jest leniwa - po znalezieniu pierwszego pasującego fragmentu przestaje ona szukać dalej i przekazuje wynik. Aby uzyskać wszystkie przypadki spełniające określony wzorzec należy użyć funkcji str_extract_all(). str_extract_all(tekst_pomiary, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*&quot;) #&gt; [[1]] #&gt; [1] &quot;Wrocław&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; #&gt; [6] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;Bydgoszcz&quot; #&gt; [11] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; #&gt; [16] &quot;&quot; &quot;&quot; &quot;&quot; &quot;Toruń&quot; &quot;&quot; #&gt; [21] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; #&gt; [26] &quot;&quot; &quot;&quot; &quot;Lublin&quot; &quot;&quot; &quot;&quot; #&gt; [31] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Efektem jej działania są wszystkie nazwy miast z wektora tekst_pomiary, ale też wiele elementów pustych. Dlaczego? W powyższym wzorcu użyliśmy metaznaku *, który szuka wystąpienia zdefiniowanych znaków zero lub więcej razy. Gdy napotkany jest zdefiniowany znak sprawdzane jest jego kolejne wystąpienie, aż do momentu, gdy pojawi się jakiś inny znak. W efekcie zwrócony został np. &quot;Wrocław&quot;. Metaznak * w przypadku, gdy zdefiniowanego znaku nie ma (wystąpił zero razy) zwraca pusty element. Jeżeli interesują nas tylko fragmenty wektora zawierające tekst musimy użyć metaznaku +. str_extract_all(tekst_pomiary, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+&quot;) #&gt; [[1]] #&gt; [1] &quot;Wrocław&quot; &quot;Bydgoszcz&quot; &quot;Toruń&quot; &quot;Lublin&quot; Wyobrażmy sobie, że otrzymaliśmy rozszerzoną wersję poprzednich danych, która tym razem zawiera dwa dodatkowe miasta - Gorzów Wielkopolski i Zieloną Górę. tekst_pomiary2 = &quot;Wrocław: 23.5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3, Gorzów Wielkopolski: 20, Zielona Góra: 19&quot; Nadal interesuje nas wydzielenie nazw miast, więc próbujemy użyć kodu, który stworzyliśmy powyżej. str_extract_all(tekst_pomiary2, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+&quot;) #&gt; [[1]] #&gt; [1] &quot;Wrocław&quot; &quot;Bydgoszcz&quot; &quot;Toruń&quot; &quot;Lublin&quot; #&gt; [5] &quot;Gorzów&quot; &quot;Wielkopolski&quot; &quot;Zielona&quot; &quot;Góra&quot; Niestety w efekcie otrzymujemy osiem elementów, gdzie &quot;Gorzów&quot; jest innym elementem niż &quot;Wielkopolski&quot;. Zdefiniowany przez nas wzorzec nie brał pod uwagę możliwości wystąpienia spacji. Możemy naprawić tę sytuację w poniższy sposób. str_extract_all(tekst_pomiary2, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+[\\\\s]?[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*&quot;) #&gt; [[1]] #&gt; [1] &quot;Wrocław&quot; &quot;Bydgoszcz&quot; &quot;Toruń&quot; #&gt; [4] &quot;Lublin&quot; &quot;Gorzów Wielkopolski&quot; &quot;Zielona Góra&quot; Teraz szukamy wystąpienia liter co najmniej raz lub więcej (+), następnie wystąpienia spacji zero razy lub raz ([\\\\s]?) i kończymy na sprawdzeniu wystąpienia tekstu zero razy lub więcej (*). Podobnie jak w każdym powyższym przypadku, efekt działania funkcji może być użyty do stworzenia nowego obiektu. miasta_pomiary2 = str_extract_all(tekst_pomiary2, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+[\\\\s]?[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*&quot;) miasta_pomiary2 #&gt; [[1]] #&gt; [1] &quot;Wrocław&quot; &quot;Bydgoszcz&quot; &quot;Toruń&quot; #&gt; [4] &quot;Lublin&quot; &quot;Gorzów Wielkopolski&quot; &quot;Zielona Góra&quot; 6.6 Zamiana tekstu - regex Innym przykładem działania na tekście jest zamiana wybranych jego elementów. tekst_pomiary3 = &quot;Wrocław: 23.5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3&quot; Powyższy obiekt tekst_pomiary3 zawiera nazwy miast i wartości pomiarów przedstawione zgodnie z amerykańskim standardem, gdzie kropka oddziela wartości dziesiętne, a przecinek kolejne elementy. Aby zamienić wybrany wzorzec w tekście (np. kropkę na przecinek) możemy użyć funkcji str_replace(), w której podajemy obiekt tekstowy, szukany wzorzec oraz jego zamianę. str_replace(tekst_pomiary3, pattern = &quot;.&quot;, replacement = &quot;,&quot;) #&gt; [1] &quot;,rocław: 23.5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3&quot; Efekt działania tego kodu nie jest jednak zgodny z naszymi oczekiwaniami. Zamiast zamiany wszyskich kropek na przecinki, nastąpiła zamiana pierwszego znaku w tekście (litery W) na przecinek. Wynika to ze znaczenia metaznaku ., który reprezentuje jakikolwiek znak oprócz nowej linii. Żeby naprawić tę sytuację musimy użyć ukośnika wstecznego. str_replace(tekst_pomiary3, pattern = &quot;\\\\.&quot;, replacement = &quot;\\\\,&quot;) #&gt; [1] &quot;Wrocław: 23,5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3&quot; Funkcja str_replace(), podobnie jak str_extract(), jest leniwa i zamienia tylko pierwsze wystąpienie wzorca. Do zamiany wszystkich przypadków trzeba użyć funkcji str_replace_all(). str_replace_all(tekst_pomiary3, pattern = &quot;\\\\.&quot;, replacement = &quot;\\\\,&quot;) #&gt; [1] &quot;Wrocław: 23,5, Bydgoszcz: 12,7, Toruń: 11,1, Lublin: 14,3&quot; W przypadku, gdy interesuje nas zarówno zamiana kropek na przecinki oraz przecinków na średniki, musimy zacząć od tej drugiej zamiany. tekst_pomiary4 = str_replace_all(tekst_pomiary3, pattern = &quot;\\\\,&quot;, replacement = &quot;\\\\;&quot;) Nowy obiekt tekst_pomiary4 oddziela kolejne miasta średnikami. Teraz na jego podstawie możliwa jest zamiana kropek na przecinki w sposób opisany powyżej. str_replace_all(tekst_pomiary4, pattern = &quot;\\\\.&quot;, replacement = &quot;\\\\,&quot;) #&gt; [1] &quot;Wrocław: 23,5; Bydgoszcz: 12,7; Toruń: 11,1; Lublin: 14,3&quot; Funkcje jakie jak str_replace() czy str_replace_all() mogą być też stosowane do usuwania fragmentów tekstu. Do tego celu można zdefiniować wzorzec jaki chcemy usunąć, a jako jego zamianę tekst pusty (&quot;&quot;). str_replace_all(tekst_pomiary4, pattern = &quot;[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+&quot;, replacement = &quot;&quot;) #&gt; [1] &quot;: 23.5; : 12.7; : 11.1; : 14.3&quot; 6.7 Wyszukiwanie plików Umiejętności związane z obsługą wyrażeń regularnych przydają się też w przypadku wyszukiwania plików zawierających określony tekst w nazwie lub specyficzne rozszerzenie. Jest to szczególnie przydatne, gdy posiadamy wiele plików na komputerze, które chcemy następnie przetwarzać w sposób automatyczny. Do wyświetlania nazw plików znajdujących się w wybranym folderze służy funkcja dir(). Przykładowo poniższa linia kodu wyświetla wszyskie pliki znajdujące się w folderze &quot;pliki&quot;36. dir(&quot;pliki&quot;) #&gt; [1] &quot;dane_meteo.csv&quot; &quot;dane_meteo.rds&quot; &quot;dane_meteo.xlsx&quot; &quot;dokument.docx&quot; #&gt; [5] &quot;kod.R&quot; &quot;mapa.png&quot; &quot;obrazek.png&quot; &quot;zdjęcie.jpg&quot; W przypadku, gdy interesują nas tylko pliki o wybranym rozszerzeniu możemy użyć argumentu pattern i zdefiniować wzorzec. dir(&quot;pliki&quot;, pattern = &quot;*\\\\.png$&quot;) #&gt; [1] &quot;mapa.png&quot; &quot;obrazek.png&quot; W powyższym przykładzie zostaną wybrane tylko pliki o jakiejkolwiek nazwie, ale kończące się na rozszerzenie .png. Metaznak $ użyty w tym przypadku zapogiega sytuacji, gdy tekst .png znajduje się w środku nazwy pliku. Do znalezienia plików o kilku rozszerzeniach można użyć metaznaków () i |. dir(&quot;pliki&quot;, pattern = &quot;*\\\\.(png|jpg)$&quot;) #&gt; [1] &quot;mapa.png&quot; &quot;obrazek.png&quot; &quot;zdjęcie.jpg&quot; Domyślnie funkcja dir() pokazuje zawartość wybranego folderu, aby jednak poznać jego pełną ścieżkę względną należy określić argument full.names na TRUE. dir(&quot;pliki&quot;, pattern = &quot;*\\\\.(png|jpg)$&quot;, full.names = TRUE) #&gt; [1] &quot;pliki/mapa.png&quot; &quot;pliki/obrazek.png&quot; &quot;pliki/zdjęcie.jpg&quot; 6.8 Zadania Plik tekstowy zawiera listę pomiarów, w której piąty i czwarty znak od końca oznacza symbol chemiczny pomierzonego pierwiastka, przykładowo: &quot;TERYT 18; podkarpackie; Rzeszów; 0.2 He; A&quot; &quot;TERYT 22; pomorskie; Gdańsk; 12 C ; B&quot; Napisz kod, który będzie wydzielał symbole chemiczne pomierzonych pierwiastków. Napisz funkcję nazywającą się horoskop, która przyjmuje dwa argumenty imie (pierwsze imię, tekst) oraz miesiac (miesiąc urodzin, liczba). Funkcja ma zwrócić tekst “Osoba o imieniu ‘imie’ będzie miała jutro szczęście.” w przypadku, gdy argument miesiac jest liczbą parzystą oraz “Osoba o imieniu ‘imie’ będzie miała jutro nieszczęście.” jeżeli argument miesiac jest liczbą nieparzystą. Rozbuduj funkcję horoskop poprzez sprawdzenie pierwszej litery podanego imienia. Jeżeli pierwsza litera imienia to K, M, lub Z wówczas wyświetli się zawsze tekst “Osoba o imieniu ‘imie’ będzie miała jutro szczęście.”, bez względu na podany miesiąc. Efektem zbierania pomiarów temperatury okazał być się plik tekstowy, który zawiera datę pomiaru oraz wartość. W jaki sposób możliwe jest wydzielenie tylko dat w takiej sytuacji? Poniżej znajduje się fragment przykładowych danych wejściowych. &quot;2019-03-11: 23.5, 19/03/12: 12.7, 2019.03.13: 11.1, 2019-marzec-14: 14.3&quot; Co należałoby zrobić, aby wydzielić tylko wartości pomiarów w powyższym przypadku? Stwórz nowy obiekt wartosci zawierający te pomiary. Jakiej klasy powinien być wyjściowy obiekt? Posiadasz wektor wsp zawierający współrzedne geograficzne szeregu miast w formacie DMS (Stopnie, Minuty, Sekundy). Wydziel tylko wartości stopnii z tej reprezentacji. Poniżej znajduje się fragment przykładowych danych wejściowych. wsp = c(&quot;52°24′N 16°55′E&quot;, &quot;53°08′07″N 23°08′44″E&quot;, &quot;39°6′N 84°31′W&quot;) Stwórz funkcję, która przyjmując przykładowe dane z poprzedniego zadania zamieni współrzędne na format w postaci stopni dziesiętnych (np. 52°24′N w formacie DMS to 52.4 w stopniach dziesiętnych). Bibliografia "],
["zlozone-obiekty.html", "7 Złożone obiekty 7.1 Macierze 7.2 Ramki danych 7.3 Listy 7.4 Zmiany klas 7.5 Inne klasy obiektów 7.6 Zadania", " 7 Złożone obiekty W rozdziale 5 omówiono wektory atomowe, które są obiektami jednowymiarowymi zawierającymi tylko jeden typ danych. Ten rozdział jest poświęcony pozostałymi trzema podstawowymi klasami obiektów w R - macierzami, ramkami danych i listami (sekcje 7.1, 7.2, i 7.3). 7.1 Macierze Macierze (ang. matrix), podobnie jak wektory, są obiektami homogenicznymi - jedna macierz może przyjmować dane tylko jednego typu. Od wektorów różnią się jednak tym, że są dwuwymiarowe - wartości ułożone są w kolejnych wierszach i kolumnach. Macierze są używane do różnorodnych obliczeń matematycznych i statystycznych. W uproszczeniu można o nich myśleć jako o reprezentacji komputerowej zdjęcia lub mapy. W R istnieją też wielowiarowe obiekty podobne do macierzy zwane matrycami (ang. array). 7.1.1 Tworzenie Tworzenie macierzy odbywa się poprzez użycie funkcji matrix(), która przyjmuje wartości wektora jako pierwszy argument, a następnie informacje o wymiarach w postaci liczby wierszy (nrow) i liczby kolumn (ncol). macierz1 = matrix(1:12, nrow = 4, ncol = 3) macierz1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 Domyślnie w R wartości wpisywane są do macierzy do kolejnych kolumn startując od lewej strony. Możliwe jest jednak ustawienie argumentu byrow = TRUE co powoduje wpisywanie podanych wartości dla kolejnych wierszy zamiast kolejnych kolumn. macierz2 = matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE) macierz2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 7.1.2 Podstawowe funkcje Sprawdzenie jakiej klasy jest podany obiekt odbywa się używając funkcji class(). class(macierz2) #&gt; [1] &quot;matrix&quot; Więcej informacji na temat obiektu można poznać używając funkcji str(). Jej działanie na macierzy jest bardzo podobne do wyniku na wektorach (zobacz sekcję 5.3) - wyświetlony zostaje typ obiektu (np. int), jego wymiary (np. [1:4, 1:3]) i kilka przykładowych wartości (np. 1 4 7 10 2 5 8 11 3 6). str(macierz2) #&gt; int [1:4, 1:3] 1 4 7 10 2 5 8 11 3 6 ... Macierz może przyjmować tylko jeden typ obiektów, co można sprawdzić używając funkcji typeof(). typeof(macierz2) #&gt; [1] &quot;integer&quot; Wektory atomowe mają tylko jeden wymiar więc ich długość oznacza liczbę elementów i może być sprawdzona używając funkcji length(). W przypadku macierzy możliwe jest dodatowo sprawdzenie liczby występujących wierszy (nrow) i kolumn (ncol). nrow(macierz2) #&gt; [1] 4 ncol(macierz2) #&gt; [1] 3 Domyślnie macierze nie zawierają nazw kolumn ani wierszy. colnames(macierz2) #&gt; NULL Sprawdzenie czy dodanie nazw kolumn jest jednak możliwe używając funkcji colnames(). Może to pozwolić w przyszłości na wydzielanie konkretnych wartości na podstawie nazw kolumn. colnames(macierz2) = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) macierz2 #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 colnames(macierz2) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 7.1.3 Wydzielanie Podobnie jak w przypadku wektorów (rozdział 5), macierze można wydzielać używając operatora []. W tym wypadku odbywa się to jednak w oparciu o dwa indeksy - jeden dla wiersza, drugi dla kolumny - [wiersz, kolumna]. Przykładowo, poniżej zostaną wybrane tylko wartości znajdujące się w pierwszy i drugim wierszy oraz pierwszej i trzeciej kolumnie. macierz2[c(1, 2), c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 Do wydzielania macierzy czy ramek danych też często przydatne jest używanie elementu pustego. Pozwala on na wybór wszystkich wartości w danym wymiarze. Na poniższy przykładzie zostały wybrane wiersze jeden i dwa oraz, z uwagi na element pusty, wszystkie kolumny. macierz2[c(1, 2), ] #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 Element pusty można też zastosować do wybrania wszystkich wierszy. macierz2[, c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 Wszystkie pozostałe sposoby wydzielania opisane dla wektorów w sekcji 5.6 działają również na macierzach. Możeliwe jest więc używanie wektora logicznego czy nazw kolumn. macierz2[, c(TRUE, FALSE, TRUE)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(&quot;a&quot;, &quot;c&quot;)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 7.1.4 Łączenie Łączenie wektorów odbywa się używając jednej funkcji c(). W przypadku macierzy występują jednak dwa wymiary - możliwe jest połączenie macierzy wierszami lub kolumnami. W efekcie istnieją do tego dwie oddzielne funkcje rbind() i cbind(). Pierwsza z nich łączy macierze wierszami. macierz3 = rbind(macierz1, macierz2) macierz3 #&gt; a b c #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [5,] 1 2 3 #&gt; [6,] 4 5 6 #&gt; [7,] 7 8 9 #&gt; [8,] 10 11 12 Druga dokleja obiekty kolumnami. macierz4 = cbind(macierz1, macierz2) macierz4 #&gt; a b c #&gt; [1,] 1 5 9 1 2 3 #&gt; [2,] 2 6 10 4 5 6 #&gt; [3,] 3 7 11 7 8 9 #&gt; [4,] 4 8 12 10 11 12 W przypadku, gdy chcemy połączyć kilka wektorów różnych typów działają dokładnie takie same reguły jak w przypadku wektorów atomowych (sekcja 5.9). 7.2 Ramki danych Ramki danych (ang. data frame) mają dużo podobieństw z macierzami. Są to obiekty dwuwymiarowe, składające się z kolumn i wierszy. Główną różnicą pomiędzy macierzą a ramką danych jest to, że pierwsza z nich przyjmuje tylko dane jednego typu, podczas gdy druga może się składać z danych róznych typów. Ramka danych jest zbudowana z kolumn (wektorów) o równej długości. Ten typ obiektu jest głównie wykorzystywany do różnorodnej analizy danych. Ramki danych przypominają w swojej strukturze arkusze kalkulacyjne czy bazy danych. 7.2.1 Tworzenie Stworzenie nowej ramki danych możliwe jest używając funkcji data.frame(), w której podawane są nazwy kolejnych kolumn (np. wek_log) oraz ich wartości (np. c(TRUE, FALSE, FALSE)). ramka1 = data.frame(wek_log = c(TRUE, FALSE, FALSE), wek_cal = c(5L, -7L, 12L), wek_zmi = c(5.3, -7.1, 1.1), wek_zna = c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;), stringsAsFactors = FALSE) ramka1 #&gt; wek_log wek_cal wek_zmi wek_zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec W powyższym przykładzie, ramka1 składa się z czterech kolumn o długości trzy. Każda z tych kolumn ma inny typ - logiczny, liczby całkowitej, liczby zmiennoprzecinkowej oraz znakowy. Domyślnie funkcja data.frame wykonuje jeszcze jedną operację w tle - zamienia ona wszystkie dane o type znakowym na typ czynnikowy (sekcja 5.11). W większości przypadków nie jest to porządane działanie - dlatego też warto wyłączyć tę konwersję używając argumentu stringsAsFactors = FALSE. Obiekty klasy ramka danych są też zazwyczaj wynikiem wczytywania zewnętrznych plików do R, np. w formacie .csv czy .xlsx. Więcej informacji na ten temat można znaleźć w rozdziale 9. 7.2.2 Podstawowe funkcje Oficjalnie klasa ramki danych jest określana jako data.frame. class(ramka1) #&gt; [1] &quot;data.frame&quot; Sprawdzenie struktury ramki danych pozwala na szybkie poznanie kilku róznych cech wejściowego obiektu. Pierwszą informacją jest klasa obiektu (data.frame), liczba wierszy (3 obs. - trzy obserwacje) i liczba kolumn (4 variables - cztery zmienne). Następnie, dla kolejnych kolumn są określane ich nazwy, typy danych oraz przykładowe wartości. str(ramka1) #&gt; &#39;data.frame&#39;: 3 obs. of 4 variables: #&gt; $ wek_log: logi TRUE FALSE FALSE #&gt; $ wek_cal: int 5 -7 12 #&gt; $ wek_zmi: num 5.3 -7.1 1.1 #&gt; $ wek_zna: chr &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Podobnie jak w przypadku macierzy, ramki danych mają dwa wymiary, których długość można sprawdzić używając funkcji nrow i ncol. nrow(ramka1) #&gt; [1] 3 ncol(ramka1) #&gt; [1] 4 W przeciwieństwie jednak do macierzy, ramki danych zawsze posiadają nazwy kolumn. colnames(ramka1) #&gt; [1] &quot;wek_log&quot; &quot;wek_cal&quot; &quot;wek_zmi&quot; &quot;wek_zna&quot; Ich zmiana również jest możliwa używając funkcji colnames(). colnames(ramka1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) ramka1 #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec colnames(ramka1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.2.3 Wydzielanie Do wydzielania elementów z ramki danych może służyć kilka narzędzi, między innymi, operator $, operator [] oraz funkcja subset(). Operator $ pozwala na wybranie zmiennej (kolumny) na podstawie jej nazwy. ramka1$zmi #&gt; [1] 5.3 -7.1 1.1 ramka1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; W efekcie otrzymywany jest jednak inna klasa - w powyższych przykładzach są to wektory. W przypadku ramek danych operator [] wymaga podania dwóch argumentów - jednego dla wierszy (obserwacji) oraz jednego dla kolumn (zmiennych) - [wiersze, kolumny]. ramka1[c(1, 3), c(1, 2)] #&gt; log cal #&gt; 1 TRUE 5 #&gt; 3 FALSE 12 Do wydzielania można też wykorzystać operatory logiczne: ==, %in%, !=, &gt;, &gt;=, &lt;, &lt;=, &amp;, |. ramka1[ramka1$zmi &gt; 0, c(1, 3)] #&gt; log zmi #&gt; 1 TRUE 5.3 #&gt; 3 FALSE 1.1 Powyżej wybrano tylko pierwszą i trzecią kolumnę oraz wiersze, dla których kolumna zmi miała wartość wyższą niż 0. Zapytania też można łączyć, np. wybierając tylko te wiersze gdzie wartość cal jest wyższa niż 6 lub niższa niż -6. ramka1[ramka1$cal &gt; 6 | ramka1$cal &lt; -6, ] #&gt; log cal zmi zna #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec Poniżej wybrano natomiast wszystkie kolumny, ale tylko wiersz gdzie zmienna zna przyjęła wartość &quot;kot&quot;. ramka1[ramka1$zna == &quot;kot&quot;, ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot Aby wybrać więcej niż jedną zmienną należy użyć funkcji %in%. ramka1[ramka1$zna %in% c(&quot;kot&quot;, &quot;pies&quot;), ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies Alternatywą do wydzielania ramek danych na podstawie zapytania logicznego jest użycie funkcji subset(). Używając tej funkcji powyższe zapytanie można przestawić jako: subset(ramka1, zna %in% c(&quot;kot&quot;, &quot;pies&quot;)) #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies Podobnie jak w przypadku wektorów (sekcje 5.7 i 5.8), wydzielanie ramek danych może służyć do wyświetlenia wybranych wartości, ale też ich wydzielenia i przypisania oraz modyfikowania. 7.2.4 Łączenie Łączenie ramek danych przypomina łączenie macierzy używając funkcji rbind() i cbind(). Jednocześnie należy pamiętać, że łączenie wierszy (rbind()) wymaga posiadania kolumn o tych samych nazwach w obu obiektach. ramka2 = data.frame(log = TRUE, cal = 2L, zmi = 2.3, zna = &quot;żółw&quot;) ramka2 #&gt; log cal zmi zna #&gt; 1 TRUE 2 2.3 żółw rbind(ramka1, ramka2) #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec #&gt; 4 TRUE 2 2.3 żółw Ograniczeniem łącznia kolumn jest posiadanie tej samej długości każdej kolumny. ramka3 = data.frame(zmi2 = c(4.3, 2.6, 7.4)) ramka3 #&gt; zmi2 #&gt; 1 4.3 #&gt; 2 2.6 #&gt; 3 7.4 cbind(ramka1, ramka3) #&gt; log cal zmi zna zmi2 #&gt; 1 TRUE 5 5.3 kot 4.3 #&gt; 2 FALSE -7 -7.1 pies 2.6 #&gt; 3 FALSE 12 1.1 nosorożec 7.4 Funkcje rbind() i cbind() łączą obiekty nie zmieniając kolejności występujących w nich wartości. Bardziej zaawansowanymi sposobami łączenia ramek danych są różnorodne operacje łączenia (ang. joins), np. left_join() czy inner_join() z pakietu dplyr. Więcej na ten temat można znaleźć w rozdziale “Relational data” książki Advanced R (Wickham 2014). 7.3 Listy Ostatnią podstawową klasą obiektów w R są listy (ang. list). Ta klasa pozwala na przechowywanie obiektów o różnych typach i różnej długości. 7.3.1 Tworzenie Do tworzenia list służy funkcja list(), która przyjmuje jako argumenty kolejne obiekty, które mają się w niej znaleźć. lista1 = list(c(TRUE, FALSE), c(5L, -7L), c(5.3), c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;)) lista1 #&gt; [[1]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]] #&gt; [1] 5 -7 #&gt; #&gt; [[3]] #&gt; [1] 5.3 #&gt; #&gt; [[4]] #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Przykładowa powyższa lista składa się z czterech elementów, o długości jeden, dwa lub trzy, i o różnorodnych typach danych. Inną ważną właściwością list jest możliwość ich zagnieżdzania - jedna lista może przechowywać kolejną, która jest w stanie przechowywać następną… Z tego powodu listy są czasami nazywane wektorami rekurencyjnymi. zlozona_lista1 = list(list(list(lista1))) str(zlozona_lista1) #&gt; List of 1 #&gt; $ :List of 1 #&gt; ..$ :List of 1 #&gt; .. ..$ :List of 4 #&gt; .. .. ..$ : logi [1:2] TRUE FALSE #&gt; .. .. ..$ : int [1:2] 5 -7 #&gt; .. .. ..$ : num 5.3 #&gt; .. .. ..$ : chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.2 Podstawowe funkcje Listy są przedstawane jako klasa list. class(lista1) #&gt; [1] &quot;list&quot; W ich wypadku funkcja str() wyświetla klasę (List), liczbę elementów w liście (4) oraz wypisuje kolejne elementy listy, ich typy, wymiary i przykładowe wartości. str(lista1) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:2] 5 -7 #&gt; $ : num 5.3 #&gt; $ : chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Listy nie zawierają wierszy czy kolumn, dlatego do sprawdzenia liczby elementów w liście służy tylko funkcja length(). length(lista1) #&gt; [1] 4 Kolejne elementy znajdujące się w liście mogą przyjmować wbrane nazwy. Można je sprawdzić czy zmienić używając funkcji names(). names(lista1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) lista1 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; names(lista1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.3.3 Łączenie Łączenie list może odbywać się na dwa postawowe sposoby. W pierwszym, używając funkcji c() następuje dołączenie elementów jednej listy do drugiej. lista2 = c(lista1, lista1) str(lista2) #&gt; List of 8 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Efektem nadal jest jedna lista, ale składająca się z większej liczby elementów. Drugim sposobem jest użycie funkcji list(). W tym przypadku tworzona jest nowa, nadrzędna lista, która zawiera dwie wcześniejsze listy. lista3 = list(lista1, lista1) str(lista3) #&gt; List of 2 #&gt; $ :List of 4 #&gt; ..$ log: logi [1:2] TRUE FALSE #&gt; ..$ cal: int [1:2] 5 -7 #&gt; ..$ zmi: num 5.3 #&gt; ..$ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; $ :List of 4 #&gt; ..$ log: logi [1:2] TRUE FALSE #&gt; ..$ cal: int [1:2] 5 -7 #&gt; ..$ zmi: num 5.3 #&gt; ..$ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.4 Wydzielanie Wydzielanie list może mieć miejsce używając jednego z trzech operatorów - [], [[]], oraz $. Operator [] wydziela wybrane elementy z listy, ale jednocześnie dalej zwraca w wyniku obiekt klasy lista. Wyobraź sobie, że masz torbę zawierający cztery przedmioty (listę zawierającą cztery elementy) i chcesz zostawić w plecaku tylko pierwszy i drugi z nich. lista4 = lista1[c(1, 2)] lista4 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 str(lista4) #&gt; List of 2 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 W efekcie wynikowy obiekt nadal jest listą, ale z mniejszą liczbą elementów. Do wydobycia wartości z listy służą operatory [[]] oraz $. Pierwszy z nich wydobywa wartości na podstawie ich położenia i w efekcie otrzymywany jest obiekt znajdujący się wewnątrz listy. W poniższym przykładzie, wydzielany jest czwarty element z obiektu lista1. lista5 = lista1[[4]] lista5 #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; str(lista5) #&gt; chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Czwarty element w lista1 jest wektorem znakowym o długości trzy. W przypadku, gdy wybrany element listy jest innej klasy to jest on również zwracany. Poniżej drugi element listy3 jest również listą - wyobraź to sobie jako wyciągnięcie jednej torby, która znajduje się wewnątrz innej. lista6 = lista3[[2]] lista6 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; str(lista6) #&gt; List of 4 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; Ostatni operator, $, wydziela wartości na podstawie ich nazw. lista1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.4 Zmiany klas R ma też szereg pomocnicznych służących do zmian istniejących klas. Te funcje rozpoczynają się od as. a następnie zawierają nazwę klasy do której chcemy przetworzyć wejściowy obiekt, np. as.vector(), as.matrix(), as.data.frame(), as.list(). Działanie tych funkcji jednak jest bardzo różne w zależności o klasy wejściowego obiektu. Zobaczmy to na przykładzie obiektu macierz1. macierz1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 class(macierz1) #&gt; [1] &quot;matrix&quot; Jego zamiana na ramkę danych odbywa się używając funkcji as.data.frame(). W efekcie nowy obiekt ma takie same wymiary (cztery wiersze i trzy kolumny) oraz te same wartości. Zauważalną zmianą jest jednak automatyczne dodane nazw wierszy (1, 2, 3, 4) i nazw kolumn (V1, V2, V3). ramka_z_m1 = as.data.frame(macierz1) ramka_z_m1 #&gt; V1 V2 V3 #&gt; 1 1 5 9 #&gt; 2 2 6 10 #&gt; 3 3 7 11 #&gt; 4 4 8 12 class(ramka_z_m1) #&gt; [1] &quot;data.frame&quot; Zupełnie inny efekt będzie miało natomiast zamienienie macierzy i ramki danych na listy. lista_z_m1 = as.list(macierz1) lista_z_r1 = as.list(ramka_z_m1) W pierwszym przypadku powstanie lista zawierająca dwanaście elementów. str(lista_z_m1) #&gt; List of 12 #&gt; $ : int 1 #&gt; $ : int 2 #&gt; $ : int 3 #&gt; $ : int 4 #&gt; $ : int 5 #&gt; $ : int 6 #&gt; $ : int 7 #&gt; $ : int 8 #&gt; $ : int 9 #&gt; $ : int 10 #&gt; $ : int 11 #&gt; $ : int 12 W drugim przypadku efektem będzie lista składająca się z trzech wektorów, które reprezentują kolejne kolumny z poprzedniej ramki danych. str(lista_z_r1) #&gt; List of 3 #&gt; $ V1: int [1:4] 1 2 3 4 #&gt; $ V2: int [1:4] 5 6 7 8 #&gt; $ V3: int [1:4] 9 10 11 12 7.5 Inne klasy obiektów W tym oraz 5 rozdziale zostały wymienione i opisane cztery podstawowe klasy obiektów w R - wektory atomowe, macierze, natomiast listy i ramki danych. R zawiera jednak znacznie więcej klas obiektów, a co więcej - każda osoba może stworzyć swoją własną klasę obiektów. Poniżej zostały stworzone trzy nowe wektory - znakowy (wek_tkt), numeryczny (wek_num) i dat (wek_dat). wek_tkt = c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;) wek_num = c(4, 6, 8) wek_dat = as.Date(c(&quot;2019-04-10&quot;, &quot;2019-04-12&quot;, &quot;2019-04-14&quot;)) Czy można na nich wyliczyć średnią w ten sam sposób? Raczej nie - wyliczenie średniej z tekstu nie jest jednoznacznie możliwe, wyliczenie średniej z wartości numerycznych powinno dać wartość numeryczną, a wyliczenie średniej z dat - również datę. mean(wek_tkt) #&gt; Warning in mean.default(wek_tkt): argument is not numeric or logical: #&gt; returning NA #&gt; [1] NA mean(wek_num) #&gt; [1] 6 mean(wek_dat) #&gt; [1] &quot;2019-04-12&quot; Powyższe wyniki są poprawne, ale każdy z nich zwraca inny rodzaj wyniku. Jest to możliwe dzięki tzw. metodom (ang. methods). Metoda to sposób w jaki zachowuje się funkcja w zależności od tego jakiej klasy będzie obiekt wejściowy. methods(mean) #&gt; [1] mean.Date mean.default mean.difftime mean.POSIXct mean.POSIXlt #&gt; see &#39;?methods&#39; for accessing help and source code Przykładowo, funkcja mean() ma pięć metod: .Date - obsługującą daty .difftime - obsługującą czas trwania .POSIXct oraz .POSIXlt - obsługujące czas .default - domyślna metoda W momencie, gdy funkcja otrzyma jakiś obiekt, sprawdzana jest jego klasa i jeżeli istnieje metoda dla tego obiektu to wówczas jest ona używana. Natomiat w sytuacji, gdy dla danej klasy obiektu nie ma istniejącej metody, używana jest domyślna metoda (.default). Jak widać w powyższym przykładzie, nowe klasy obiektów oraz nowe metody są tworzone, aby ułatwić pracę na innych niż domyślne strukturach danych. 7.6 Zadania Stwórz trzy nowe macierze - ma1, ma2, ma3 - składające się z trzech wierszy i czterech kolumn. Macierz ma1 powinna zawierać wartości od 0 do 11, cała macierz ma2 powinna składać się tylko z wartości 2, a macierz ma3 powinna zawierać losowe wartości od 1 do 3 (w stworzeniu losowych wartości może pomóc funkcja sample()). Wykonaj podstawowe operacje, takie jak dodawanie, odejmowanie, mnożenie i dzielenie używając macierzy ma1 oraz ma2, a następnie macierzy ma1 i ma3. Co jest efektem tych obliczeń? W jaki sposób działania arytmetyczne są wykonywane na macierzach w R? Wydziel tylko pierwszy wiersz i ostatnią kolumnę macierzy ma1. Znajdź wartości macierzy ma3, które są większe niż 2. Połącz kolumnami macierz ma1 i macierz ma3 tworząc nowy obiekt ma4 Stwórz nową ramkę danych, ra1, która składa się z dwóch kolumn i trzech wierszy. Pierwsza kolumna data zawiera datę z dziś, wczoraj i przedwczoraj, a kolumna miasto zawiera nazwę miasta w którym się właśnie znajdujesz. Stwórz nową ramkę danych, ra2, która również składa się z dwóch kolumn i trzech wierszy. Kolumna tmin zawiera wartości 5.3, 4.6, 2.9, a kolumna tmax zawiera wartości 11.1, 14.6, 9. Połącz dwie stworzone ramki danych ra1 i ra2 tworząc obiekt ra3. Używając obiektu ra3 wylicz średnią temperaturę dla każdego wiersza i wpisz ją w nową kolumnę tmean. Zmień nazwę drugiej kolumny w obiekcie ra3 na &quot;tmaks&quot;, a trzeciej na &quot;tsr&quot;. Wyświetl tylko te daty dla których średnia temperatura była wyższa niż 8. Stwórz nową listę, li1, która zawiera trzy elementy. Pierwszy element to wektor liczb od 10 do 0, drugi element to obiekt ma4, a trzeci element to obiekt ra3. Wydziel z tej listy pierwszy element i nazwij go wektor_l. Wylicz średnią wartość z kolumny &quot;tsr&quot; z trzeciego elementu listy. Zamień obiekt ramka1 utworzony w tym rozdziale na macierz. Co jest efektem zamiany klasy? Bibliografia "],
["petle.html", "8 Powtarzanie 8.1 Pętla for 8.2 Pętla while 8.3 Programowanie funkcyjne 8.4 Zadania", " 8 Powtarzanie W sekcji 1.2 zostały wspomniane różne istniejące paradygmaty programowania. Pętle for czy while (sekcje 8.1 i 8.2) są przykładami programowania imperatywnego, gdzie program komputerowy postrzegany jest jako ciąg poleceń dla komputera. Alternatywą do tego sposobu działania jest programowanie funkcyjne, w którym rozwiązanie pewnego problemu jest oparte o użycie lub stworzenie odpowiedniej funkcji (sekcja 8.3). Język R pozwala na stosowanie zarówno paradygmatu imperatywnego jak i paradygmatu funkcyjnego37. 8.1 Pętla for Pęlta for jest jednym z najczęściej używanych wyrażeń w językach programowania38, którego celem jest powtórzenie pewnej operacji o znaną liczbę razy. 8.1.1 Składnia Pęlta for jest zbudowana z dwóch elementów: nagłówka określającego powtórzenia, oraz ciała zawierającego obliczenia. for (element in wektor) { przetwarzanie elementu } 8.1.2 Przykład działania Zobaczmy jak działa pętla for na uproszczonym przykładzie zamiany wartości odległości z mil lądowych na kilometry. Nasze dane wejściowe to lista składająca się z trzech wartości - 142, 63, oraz 121. Wiemy też, że jedna mila lądowa to 1,609 kilometra. odl_mile = list(142, 63, 121) Pętla for może być użyta w tym przypadku na kilka sposobów. Na początku warto zastanowić się w jaki sposób można zamienić tylko jedną wartość z powyższej listy. Wiemy, że do wybrania jednego elementu z listy służy operator [[]] (sekcja 7.3.4), więc przeliczenie i wyświetlenie tylko pierwszego elementu można wykonać poprzez: print(odl_mile[[1]] * 1.609) #&gt; [1] 228 Teraz naszym celem jest potwórzenie tej operacji dla każdego elementu. print(odl_mile[[1]] * 1.609) #&gt; [1] 228 print(odl_mile[[2]] * 1.609) #&gt; [1] 101 print(odl_mile[[3]] * 1.609) #&gt; [1] 195 W powyższym przypadku mamy tylko trzy elementy, ale jeżeli mielibyśmy takich elementów 1000 musielibyśmy powtórzyć niemal tą samą linię kodu tysiąc razy jedynie zamieniając numer elementu. Jednym z celów programowania jest ułatwienie szybkiej powtarzalności pewnych czynności. Dlatego w tym przypadku moglibyśmy uniknąć wieloktornego pisania podobnego kodu używając pętli for. Ciałem tej pętli będzie sposób przeliczania i wyświetlania wartości na kilometry, ale zamiast wydzielać kolejne elementy listy ([[1]], [[2]], [[3]]), użyjemy nowego obiektu i. W efekcie nowe ciało pętli for będzie przedstawiać się jako print(odl_mile[[i]] * 1.609). Kolejnym krokiem jest odpowiednie ustawienie jakie wartości będzie przyjmować i w kolejnych powtórzeniach. for (i in 1:3) { print(odl_mile[[i]] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 Powyższy nagłówek pętli for, for (i in 1:3), określa, że nasz obiekt i przyjmie najpierw wartość 1, wykona obliczenie wewnątrz pętli, następnie i przyjmie wartość 2, znów wykona obliczenie, a na końcu i przyjmie wartość 3 i obliczenie zostanie wykonane po raz ostatni. Tradycyjnie zmienna w pętli for nazywana jest i, a w przypadku zagnieżdzonych pętli druga zmienna nazywana jest j. Nazywanie zmiennych w ten sposób nie jest jednak obowiązkowe. W powyższym przypadku możliwe byłoby nazwanie zmiennej, np. pomiar: for (pomiar in odl_mile) {...}. Użyty wyżej kod wykonuje nasz cel, ale wymaga od nas zawsze deklaracji dotyczącej tego jakie wartości ma przyjąć obiekt i. W przypadku, gdy obiekt wejściowy odl_mile będzie krótszy lub dłuższy niż trzy elementy, będziemy musieli ręcznie zmienić nagłówek pętli for. Aby tego uniknąć możemy automatycznie określić wszystkie pozycje elementów w liście odl_mile używając funkcji seq_along(). Ta funkcja zawsze wyświetli numery położenia kolejnych elementów danego wektora lub listy. seq_along(odl_mile) #&gt; [1] 1 2 3 Poniższy kod nie wymaga już od nas ręcznego wprowadzania kolejnych położeń elementów wejściowej listy. for (i in seq_along(odl_mile)) { print(odl_mile[[i]] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 Często w takich sytuacjach używana jest konstrukcja 1:length(), np. 1:length(old_mile). Zadziała ona poprawnie w powyższym przypadku, ale nie jest ona uniwersalna. Konstrukcja 1:length() może wywołać problemy w kodzie, gdy wejściowy obiekt jest pusty. for (i in 1:length(NULL)){...} wykona pętlę for dwa razy, podczas gdy w rzeczywistości nie powinna ona zostać w ogóle wykonana. Funkcja seq_along() jest odporna na ten problem - seq_along(NULL) nie wykona pętli ani razu. Wcześniejsze przykłady wyświetlały przeliczone na kilometry kolejne elementy listy odl_mile. Możliwe było zobaczenie nowych wartości, ale nie zostawały one w pamięci komputera - w efekcie nie można było wykorzystać wyników działania pętli for w przyszłości. Co w takim razie należy zrobić, aby wynik dało się użyć dalej? Jednym z podejść jest modyfikacja istniejącej list odl_mile. Poniższa pętla for zastępuje kolejne wartości z obiektu odl_mile na kilometry. for (i in seq_along(odl_mile)) { odl_mile[[i]] = odl_mile[[i]] * 1.609 } odl_mile #&gt; [[1]] #&gt; [1] 228 #&gt; #&gt; [[2]] #&gt; [1] 101 #&gt; #&gt; [[3]] #&gt; [1] 195 Niestety, w efekcie stracone zostały oryginalne wartości w milach lądowych. odl_mile = list(142, 63, 121) Aby zostawić oryginalne wartości w milach lądowych, ale też stworzyć nowy obiekt określony w kilometrach musimy stworzyć nowy, pusty obiekt, a następnie wypełnić go wartościami. Poniżej nazwany on został odl_km - jest to pusta lista. Następnie kolejne wykonania pętli for doklejają kolejne elementy do tej listy. odl_km = vector(&quot;list&quot;, length = 0) for (i in seq_along(odl_mile)) { odl_km = c(odl_km, odl_mile[[i]] * 1.609) } odl_km #&gt; [[1]] #&gt; [1] 228 #&gt; #&gt; [[2]] #&gt; [1] 101 #&gt; #&gt; [[3]] #&gt; [1] 195 Efektem jest poprawne rozwiązanie naszego problemu, ale niestety posiada ono istotną wadę - to rozwiązanie nie jest bardzo wydajne. Za każdym przejściem pętli następuje bowiem alokacja pamięci, co zabiera niepotrzebnie czas. Więcej informacji na ten temat można znaleźć w rozdziale 12. Lepszym rozwiązaniem w takiej sytuacji jest od razu stworzenie listy, o długości zgodnej z naszym oczekiwaniem. Następnie kolejne elementy stworzonej listy są zamieniane na oczekiwane przez nas wartości. odl_km = vector(&quot;list&quot;, length = length(odl_mile)) for (i in seq_along(odl_mile)) { odl_km[[i]] = odl_mile[[i]] * 1.609 } odl_km #&gt; [[1]] #&gt; [1] 228 #&gt; #&gt; [[2]] #&gt; [1] 101 #&gt; #&gt; [[3]] #&gt; [1] 195 8.1.3 Zastosowanie w funkcjach Pętle for, podobnie jak wyrażenia warunkowe (sekcja 4.4), w naturalny sposób są stosowane w funkcjach. Przykładowo, możemy stworzyć nową funkcję mile_na_km(), która przyjmuje listę z wartościami w milach lądowych jako obiekt wejściowy, a później zwraca listę z wartościami w kilometrach. mile_na_km = function(odl_mile) { odl_km = vector(&quot;list&quot;, length = length(odl_mile)) for (i in seq_along(odl_mile)) { odl_km[[i]] = odl_mile[[i]] * 1.609 } odl_km } Sprawdźmy działanie funkcji na prostym przykładzie listy z pięcioma elementami. odleglosci_mile = list(0, 1, 10, 55, 160) mile_na_km(odleglosci_mile) #&gt; [[1]] #&gt; [1] 0 #&gt; #&gt; [[2]] #&gt; [1] 1.61 #&gt; #&gt; [[3]] #&gt; [1] 16.1 #&gt; #&gt; [[4]] #&gt; [1] 88.5 #&gt; #&gt; [[5]] #&gt; [1] 257 Zgodnie z oczekiwaniami zero mil lądowych to również zero kilometrów, a jedna mila lądowa to 1,609 kilometra. 8.2 Pętla while W przypadku pętli for znana jest liczba powtórzeń przed rozpoczęciem jej działania. Inny rodzaj pętli, pętla while, jest natomiast stosowany gdy nie wiadomo ile potwórzeń jest koniecznych. W efekcie pętla while jest bardziej elastyczna, co jest zarazem jej atutem i wadą. Bardziej elastyczne metody charakteryzuje większa liczba potencjalnych sytuacji do których mogą zostać użyte, ale w efekcie też więcej potencjalnych problemów. Pętla while powinna być używana tylko gdy rozwiązanie z użyciem pętli for nie jest możliwe. Pętla while składa się z nagłówka definującego pewien warunek oraz ciała określającego operację do wykonania. Pętla ta będzie tak długo powtarzana jak długo warunek będzie spełniony - dlatego też w ciale pętli musi być jakiś mechanizm zmieniający wartość wpływającą na warunek. while (warunek){ wykonuj operację tak długo jak warunek jest spełniony } Wyobraźmy sobie poniższą sytuację. Mamy 1000 zł (obiekt budzet) i chcemy zainwestować te pieniądze na giełdzie w celu ich pomnożenia. Interesują nas tylko dwa scenariusze - jeden w którym tracimy całą kwotę, oraz drugi w którym udaje się nam podwoić tę kwotę. Wiemy też jedną dodatkową rzecz - losowe wahania na giełdzie mogą pozwolić nam na stratę maksymalnie 100 zł aż do zysku 100 zł każdego dnia. Poniższy kod wykonuje pętlę while tak długo jak obiekt budzet ma wartość większą od zera i mniejszą od 2000. budzet = 1000 liczba_dni = 0 while(budzet &gt; 0 &amp;&amp; budzet &lt; 2000){ budzet = budzet + sample(-100:100, size = 1) # losowa strata lub zysk liczba_dni = liczba_dni + 1 } Po jego wykonaniu możemy dowiedzieć się czy udało się nam zarobić czy też stracić całe pieniądze. Dodatkowo możemy sprawdzić ile zajęło to dni. budzet #&gt; [1] 2009 liczba_dni #&gt; [1] 531 Inne istniejące rodzaje pętli to pętla repeat oraz pętla do. Pętla repeat powtarza pewnien kod aż do momentu przerwania go przez użytkownika (np. użycie klawisza Esc) lub do pojawienia się komendy break. Działanie pętli do natomiast wygląda w następujący sposób: do {wykonuj operację} while (warunek). Pętla do nie występuje w R. Dodatkowe informacje na temat pętli for and while można znaleźć w sekcji Loops książki Advanced R (Wickham 2014) 8.3 Programowanie funkcyjne Sprawdźmy działanie programowania funkcyjnego na dwóch przykładach. W pierwszym posiadamy listę pomiary_f_lista składającą się z trzech elementów - każdy z nich to wektor z trzema pomiarami temperatury w stopniach Fahrenheita. pomiary_f_lista = list( miastoA = c(61, 14, 21), miastoB = c(43, 52, 30), miastoC = c(41, 42, 33) ) pomiary_f_lista #&gt; $miastoA #&gt; [1] 61 14 21 #&gt; #&gt; $miastoB #&gt; [1] 43 52 30 #&gt; #&gt; $miastoC #&gt; [1] 41 42 33 Naszym celem jest zamiana tych wartości na stopnie Celsjusza. Używając paradygmatu imperatywnego, moglibyśmy zastosować pętlę for i zastosować przeliczenie wartości dla kolejnych elementów listy. W paradygmacie funkcyjnym natomiast naszym pierwszym krokiem jest stworzenie funkcji wykonującej podstawową operację: konwersja_f_to_c = function(temperatura_f){ (temperatura_f - 32) / 1.8 } Funkcje użyte w programowaniu funkcyjnym muszą spełniać dwa warunki: Wynik działania funkcji musi zależeć od obiektu wejściowego, czyli gdy dwa razy uruchomimy tą samą funkcję na tych samych danych musimy dostać ten sam wynik. Taka funkcja nie może mieć w sobie, np. elementu losowego. Funkcja nie może mieć efektów ubocznych (ang. side-effects), czyli wykonywać jakiegoś działania w tle, jak np. wyświetlanie czy zapisywanie na dysk. Powyższa funkcja konwersja_f_to_c() działa poprawnie na wektorach wartości, ale niestety nie jest w stanie zwrócić wyniku w przypadku listy, co obrazuje komunikat błędu. konwersja_f_to_c(pomiary_f_lista) #&gt; Error in temperatura_f - 32: non-numeric argument to binary operator Języki obsługujące programowanie funkcyjne posiadają jednak szereg narzędzi do przetwarzania funkcji, które zbiorczo są nazywane funkcjonałami (ang. functional). Funkcjonały to funkcje, które przyjmują inne funkcje jako argumenty. W R istnieje cała rodzina funkcji poświęcona programowaniu funkcyjnemu. Oprócz najczęściej używanych, lapply() i apply(), istnieją również takie funkcje jak sapply(), vapply(), tapply(), mapply() i inne. Jednym z podstawowych funkcjonałów w R jest lapply(). Funkcjonał lapply() przyjmuje jako pierwszy arugment wektor atomowy lub listę, a następnie przetwarza go używając funkcji podanej jako drugi argument FUN. Poniżej, lapply() wykonuje funkcję konwersja_f_to_c() na kolejnych elementach listy pomiary_f_lista i zwraca nową listę zawierającą wyniki pomiary_c_lista = lapply(pomiary_f_lista, FUN = konwersja_f_to_c) pomiary_c_lista #&gt; $miastoA #&gt; [1] 16.11 -10.00 -6.11 #&gt; #&gt; $miastoB #&gt; [1] 6.11 11.11 -1.11 #&gt; #&gt; $miastoC #&gt; [1] 5.000 5.556 0.556 Programowanie funkcyjne można też stosować do innych klas obiektów. Poniższa ramka danych pomiary zawiera trzy kolumny z pomiarami temperatury dla kolejnych miast. Dla każdego miasta wykonano jeden pomiar dziennie. pomiary = data.frame( miastoA = c(6.1, 1.4, -2.1), miastoB = c(4.3, 5.2, 3.0), miastoC = c(4.1, 4.2, 3.3) ) pomiary #&gt; miastoA miastoB miastoC #&gt; 1 6.1 4.3 4.1 #&gt; 2 1.4 5.2 4.2 #&gt; 3 -2.1 3.0 3.3 Naszym celem jest wyliczenie średnich - zarówno średniej wartości dla każdego miasta (kolumny) oraz średniej wartości dla każdego dnia (wiersze). Możemy to zrobić używając pętli for. Najpierw tworzymy pusty wektor sr_miasto o długości oczekiwanego wyniku, a następnie wyliczamy średnią dla kolejnych kolumn i dodajemy ją do tego wektora. sr_miasto = vector(&quot;numeric&quot;, length = ncol(pomiary)) for(i in seq_len(ncol(pomiary))){ sr_miasto[i] = mean(pomiary[, i]) } sr_miasto #&gt; [1] 1.80 4.17 3.87 W kolejnym kroku tworzymy pusty wektor sr_dzien również o długości oczekiwanego wyniku, a następnie wyliczamy średnią dla kolejnych wierszy i dodajemy ją do tego wektora. sr_dzien = vector(&quot;numeric&quot;, length = nrow(pomiary)) for(i in seq_len(nrow(pomiary))){ sr_dzien[i] = mean(unlist(pomiary[i, ])) } sr_dzien #&gt; [1] 4.83 3.60 1.40 Alternatywą w takich przypadkach jest użycie programowania funkcyjnego, a w szczególności funkcjonału apply(). Oczekuje on co najmniej trzech argumentów, X - obiektu wejściowego którym mogą być między innymi ramki danych czy macierze, MARGIN określającego czy wartości będą grupowane po wierszach czy kolumnach, oraz FUN zawierającego używaną funkcję. W poniższym przypadku obiektem wejściowym jest ramka danych pomiary, MARGIN = 2 oznacza wyliczanie oddzielnie dla kolejnych kolumn przy użyciu zdefiniowanej funkcji mean(). apply(pomiary, MARGIN = 2, FUN = mean) #&gt; miastoA miastoB miastoC #&gt; 1.80 4.17 3.87 Podobne obliczenie, ale dla kolejnych wierszy można uzyskać zamieniając argument MARGIN na 1. apply(pomiary, MARGIN = 1, FUN = mean) #&gt; [1] 4.83 3.60 1.40 Pakiet purrr oferuje ulepszone i rozszerzone narzędzia do programowania funkcyjnego (Henry and Wickham 2019). Przykładowo, odpowiednikiem funkcji lapply() w pakiecie purrr jest funkcja map(). Ma ona dodatkowo kilka kolejnych wariantów, np. map_df() - która przyjmuje jako wejście listy, ale zwraca ramki danych, czy map_dbl() - która również przyjmuje listy, ale zwraca wartości zmiennoprzecinkowe. 8.4 Zadania Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ if (i &lt; 2 | i &gt;= 5) print(&quot;Działa!&quot;) } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 | i &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 &amp; j &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 | j &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 3)){ for (j in 6:3){ i = i + j if (i &lt; 4 | i &gt;= 9) print(&quot;Działa!&quot;) } } Bibliografia "],
["io.html", "9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy 9.2 Działania na plikach i folderach 9.3 Dane internetowe 9.4 Wczytywanie plików tekstowych 9.5 Zapisywanie plików tekstowych 9.6 Formaty R 9.7 Arkusze kalkulacyjne 9.8 Inne formaty 9.9 Zadania", " 9 Wczytywanie i zapisywanie plików Języki programowania mają na celu wykonywanie wielu złożnych operacji w relatywnie krótkim czasie. Często te działania oparte są o dane zewnętrzne, np. stworzone przez człowieka, automatyczny sensor, czy jako efekt działania innego programu. Czasem też konieczne jest przekazanie lub udostępnienie wyników obliczeń dla innych osób. Celem tego rozdziału jest wprowadzenie do zagadnień związanych z określaniem położenia plików na dysku komputera, wykonywaniu działań na plikach i folderach oraz pobieraniu danych z internetu. Posiadając taką więdzę możliwe jest wczytywanie i zapisywanie danych, takich jak dane tekstowe, dane w formatach R, czy dane z arkuszy kalkulacyjnych. 9.1 Folder roboczy Folder roboczy (ang. working directory) to miejsce na dysku, w którym aktualnie pracujemy. Folder roboczy można sprawdzić korzystając z funkcji getwd(): getwd() #&gt; [1] &quot;/home/travis/build/Nowosad/elp&quot; Zmienić folder roboczy można za pomocą skrótu Ctrl+Shift+H w RStudio (inaczej Session -&gt; Set Working Directory -&gt; Choose Directory..) lub też funkcji setwd(): setwd(&quot;home/jakub/Documents/elp/&quot;) #unix setwd(&quot;C:/Users/jakub/Documenty/elp/&quot;) #windows Ustawienie folderu roboczego ma też miejsce przy tworzeniu nowego lub otwieraniu istniejącego projektu RStudio. Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki. Ścieżka względna oznacza określanie ścieżki pliku w odniesieniu do istniejącego folderu roboczego, podczas, gdy ścieżka bezwzględna opisuje pełne położenie pliku. Przykładowo, mamy plik dane_meteo.csv, którego pełna ścieżka to home/jakub/Documents/elp/pliki/dane_meteo.csv. Z poziomu R ten plik jest widoczny zarówno jako home/jakub/Documents/elp/pliki/dane_meteo.csv, ale też w postaci pliki/dane_meteo.csv39. Używanie ścieżek względnych jest rekomendowane, ponieważ znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami. Ścieżki względne są też używane w połączeniu z systemami kontroli wersji (rozdział 15). Ścieżki folderów w systemach Windows są domyślnie rozdzielane ukośnikiem wstecznym (\\, ang. backslash), jednak R pozwala także na użycie prawego ukośnika (/, ang. slash). Prawy ukośnik jest rekomendowany, ponieważ działa on zarówno na Windowsach, jak i komputerach z systemami MacOS czy Linux. 9.2 Działania na plikach i folderach Z poziomu R możliwe jest również zarządzanie folderami i plikami na dysku. Do tworzenia nowych folderów służy funkcja dir.create(), np. dir.create(&quot;dane&quot;) stworzy nowy podfolder o nazwie &quot;dane&quot;. Sprawdzenie czy folder już istnieje możliwe jest używając funkcji dir.exists(), np. dir.exists(&quot;dane&quot;), która zwraca wartość TRUE gdy folder o tej nazwie istnieje lub FALSE gdy takiego folderu nie ma. Do usuwania istniejących folderów służy funkcja unlink(). W jej przypadku konieczne jest podanie, oprócz nazwy folder do usunięcia, argumentu recursive = TRUE. Przykładowo, aby usunąć folder &quot;dane&quot; należy wpisać unlink(&quot;dane&quot;, recursive = TRUE). Sprawdzenie czy plik istnieje na dysku można wykonać używając file.exist(), a usunąć go za pomocą file.remove(). Obie funkcje przyjmują jako wejście wektor znakowy zawierający nazwy plików do sprawdzenia czy usunięcia. W przypadkach, gdy konieczne jest stworzenie nowego archiwum ZIP lub rozpakowanie istniejącego pliku w tym formacie można użyć funkcji zip() oraz unzip()40. 9.3 Dane internetowe Pliki, które chcemy otworzyć nie muszą od razu znajdować się na dysku naszego komputera. Możliwe jest, między innymi, pobranie ich z poziomu R za pomocą funkcji download.file()41. Należy w niej podać adres URL pliku do pobrania, oraz nazwę pliku do zapisania. download.file(&quot;https://raw.githubusercontent.com/Nowosad/elp/master/pliki/dane_meteo.csv&quot;, destfile = &quot;pliki/dane_meteo_url.csv&quot;) W efekcie plik dane_meteo_url.csv zostanie zapisany w folderze pliki. Funkcja download.file() ma też szereg dodatkowych argumentów, między innymi method określającą metodę pobierania danych oraz mode określający sposób zapisu pliku. 9.4 Wczytywanie plików tekstowych Podstawowymi sposobami przechowywania informacji są pliki tekstowe i binarne. Przykładowo, pliki tekstowe mogą przechowywać dane w postaci tabelarycznej, a jednym z najczęściej używanych formatów tekstowych jest CSV (ang. comma-separated values). Wyobraźmy sobie, że otrzymaliśmy plik tekstowy zawierający wybrane pomiary meteorologiczne dla Poznania oraz Zakopanego w roku 2017. #&gt; [1] &quot;kod_stacji,nazwa_stacji,rok,miesiac,dzien,tavg,precip,humidity,pressure&quot; #&gt; [2] &quot;352160330,POZNAŃ,2017,1,1,1.4,0,78,1017.9&quot; #&gt; [3] &quot;352160330,POZNAŃ,2017,1,2,0.1,0,84,1013.1&quot; #&gt; [4] &quot;352160330,POZNAŃ,2017,1,3,0.5,4.8,91.1,1012.1&quot; #&gt; [5] &quot;352160330,POZNAŃ,2017,1,4,1.5,2.3,84.9,996.1&quot; Zapisaliśmy ten plik jako dane_meteo.csv w podfolderze pliki, więc jego ścieżka względna to &quot;pliki/dane_meteo.csv&quot;. Po otworzeniu tego pliku w edytorze tekstu widzimy, że pierwszy jego wiersz zawiera nazwy kolumn, a następne wiersze to kolejne obserwacje. Dodatkowo można zobaczyć, że kolumny rozdzielane są przecinkami (,), natomiast wartości zmiennoprzecinkowe kropkami (.). Do wczytania tego pliku możemy użyć wbudowanej w R funkcji read.csv(), podając w niej bezwzględną lub względną ścieżkę do pliku. W poniższych przykładzie dodatkowo ustalono argument stringsAsFactors na FALSE, dzięki czemu kolumny z tekstem nie będą zamieniane na klasę czynnikową42. meteo = read.csv(&quot;pliki/dane_meteo.csv&quot;, stringsAsFactors = FALSE) str(meteo) #&gt; &#39;data.frame&#39;: 730 obs. of 9 variables: #&gt; $ kod_stacji : int 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ... #&gt; $ nazwa_stacji: chr &quot;POZNAŃ&quot; &quot;POZNAŃ&quot; &quot;POZNAŃ&quot; &quot;POZNAŃ&quot; ... #&gt; $ rok : int 2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ... #&gt; $ miesiac : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ dzien : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ tavg : num 1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ... #&gt; $ precip : num 0 0 4.8 2.3 0 0 2.1 0 0 0 ... #&gt; $ humidity : num 78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ... #&gt; $ pressure : num 1018 1013 1012 996 1021 ... Oprócz funkcji read.csv() istnieje również funkcja o nazwie read.csv2(). Pierwsza z nich jest przystosowana do wczytania danych dla których separator kolumn to , a separator dziesiętny to ., druga natomiast jest używana gdy wejściowe dane mają ; jak separator kolumn i , jako separator dziesiętny. Czasem dane tekstowe posiadają inne znaki służące jako separatory, czy też nie posiadają nazw kolumn. W takich sytuacjach można użyć funkcji read.table(), która zawiera cały szereg argumentów, które można dopasować, aby poprawnie wczytać dane tekstowe. meteo = read.table(&quot;pliki/dane_meteo.csv&quot;, sep = &quot;,&quot;, header = TRUE) str(meteo) #&gt; &#39;data.frame&#39;: 730 obs. of 9 variables: #&gt; $ kod_stacji : int 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ... #&gt; $ nazwa_stacji: Factor w/ 2 levels &quot;POZNAŃ&quot;,&quot;ZAKOPANE&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ rok : int 2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ... #&gt; $ miesiac : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ dzien : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ tavg : num 1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ... #&gt; $ precip : num 0 0 4.8 2.3 0 0 2.1 0 0 0 ... #&gt; $ humidity : num 78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ... #&gt; $ pressure : num 1018 1013 1012 996 1021 ... R posiada kilka dodatkowych funkcji pozwalających na odczytywanie plików tekstowych, tj. read.delim(), read.delim2(), read.fwf(), czy readLines(). Funkcje read.delim() oraz read.delim2() są odpowiednikami read.csv() i read.csv2() dla plików, gdzie kolejne zmienne są oddzielane tabulatorami. Funkcja read.fwf() służy do odczytywania danych o ustalonej długości kolejnych zmiennych. Funkcja readLines() wczytuje kolejne linie z pliku tekstowego. Efektem jej działania w przeciwieństwie do poprzednich funkcji nie jest ramka danych, ale wektor tekstowy, gdzie każdy kolejny element wektora to tekst z kolejnych linii. 9.5 Zapisywanie plików tekstowych Plik pliki/dane_meteo.csv zawiera pomiary ze stacji Poznań oraz Zakopane. W przypadku, gdy interesują nas tylko informacje dla Poznania możemy wydzielić odpowiednie wiersze używając funkcji subset() (sekcja 7.2.3). meteo_pzn = subset(meteo, nazwa_stacji == &quot;POZNAŃ&quot;) str(meteo_pzn) #&gt; &#39;data.frame&#39;: 365 obs. of 9 variables: #&gt; $ kod_stacji : int 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ... #&gt; $ nazwa_stacji: Factor w/ 2 levels &quot;POZNAŃ&quot;,&quot;ZAKOPANE&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ rok : int 2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ... #&gt; $ miesiac : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ dzien : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ tavg : num 1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ... #&gt; $ precip : num 0 0 4.8 2.3 0 0 2.1 0 0 0 ... #&gt; $ humidity : num 78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ... #&gt; $ pressure : num 1018 1013 1012 996 1021 ... Następnie możemy zapisać obiekt meteo_pzn do nowego pliku używając funkcji write.csv()43, poprzez podanie nazwy obiektu do zapisania oraz ścieżki zapisu wynikowego pliku. Dodatkowo możliwe jest pominięcie zapisania nazw wierszy (row.names = FALSE). write.csv(meteo_pzn, file = &quot;pliki/dane_meteo_pzn.csv&quot;, row.names = FALSE) Funkcje read.csv() czy write.csv() są domyślnie dostępne w języku R. Ich wydajność nie jest niestety najlepsza w przypadku plików tekstowych o dużej wielkości. W takich przypadkach warto użyć alternatywnych funkcji, np. read_csv() i write_csv() z pakietu readr (Wickham, Hester, and Francois 2018) lub fread() i fwrite() z pakietu data.table (Dowle and Srinivasan 2019). 9.6 Formaty R Formaty tekstowe są bardzo uniwersalne pozwalając na odczyt, zapis czy przenoszenie danych pomiędzy różnymi komputerami, programami czy językami programowania. Mają one jednak pewne ograniczenia. Wielkość pliku tekstowego rośnie bardzo szybko wraz z liczbą elementów, a plik tekstowy nie przechowuje dodatkowych informacji specyficznych dla języków programowania. Wczytanie czy zapis dużego pliku tekstowego zabiera też relatywnie dużo czasu. Przykładowo, chcemy aby kolumna nazwa_stacji była reprezentowana jako wektor czynnikowy. meteo$nazwa_stacji = as.factor(meteo$nazwa_stacji) str(meteo) #&gt; &#39;data.frame&#39;: 730 obs. of 9 variables: #&gt; $ kod_stacji : int 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ... #&gt; $ nazwa_stacji: Factor w/ 2 levels &quot;POZNAŃ&quot;,&quot;ZAKOPANE&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ rok : int 2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ... #&gt; $ miesiac : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ dzien : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ tavg : num 1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ... #&gt; $ precip : num 0 0 4.8 2.3 0 0 2.1 0 0 0 ... #&gt; $ humidity : num 78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ... #&gt; $ pressure : num 1018 1013 1012 996 1021 ... W przypadku zapisania nowego obiektu do pliku tekstowego ta informacja zostanie utracona. Alternatywnie, jeżeli chcemy używać tych danych tylko w języku R możemy zapisać je do pliku w binarnym formacie RDS. Taki zapis można wykonać używając funkcji saveRDS() podając nazwę obiektu do zapisu oraz ścieżkę do nowego pliku. saveRDS(meteo, file = &quot;pliki/dane_meteo.rds&quot;) Taki plik będzie domyślnie mniejszy (nastąpi jego kompresja przy zapisie) niż tekstowy i będzie posiadał on wszelkie informacje o klasie tego obiektu. Ponowne wczytanie obiektu można wykonać używając funkcji readRDS(). meteo_rds = readRDS(&quot;pliki/dane_meteo.rds&quot;) str(meteo_rds) #&gt; &#39;data.frame&#39;: 730 obs. of 9 variables: #&gt; $ kod_stacji : int 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ... #&gt; $ nazwa_stacji: Factor w/ 2 levels &quot;POZNAŃ&quot;,&quot;ZAKOPANE&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ rok : int 2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ... #&gt; $ miesiac : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ dzien : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ tavg : num 1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ... #&gt; $ precip : num 0 0 4.8 2.3 0 0 2.1 0 0 0 ... #&gt; $ humidity : num 78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ... #&gt; $ pressure : num 1018 1013 1012 996 1021 ... Powyżej można zobaczyć, że została zachowana wcześniejsza zmiana - kolumna nazwa_stacji nadal jest reprezentowana poprzez wektor czynnikowy. Dodatkowo możliwe jest zapisywanie wielu obiektów do jednego pliku w formacie o rozszerzeniu .rda a następnie ich odczytanie używając wbudowanych funkcji save() i load(). Pakiety to zorganizowany zbiór funkcji rozszerzający możliwości R (sekcja 3.5). Istotnym elementem każdego pakietu jest jego dokumentacja, która ułatwia użytkownikom zrozumienie i wykorzystanie możliwości danego pakietu. Często, aby pokazać szczegółowo działanie danej funkcji wykorzystywane są przykładowe dane, które można dołączyć do pakietu. Przykładowo, wraz z R domyślnie instalowany jest pakiet o nazwie datasets. Aby wyświetlić listę zbiorów danych w tym pakiecie można użyć funkcji data() i podać w niej nazwę konkretnego pakietu. data(package = &quot;datasets&quot;) Wczytanie zbioru danych z wybranego pakietu odbywa się poprzez wybór nazwy zbioru (np. &quot;faithful&quot;) oraz nazwy pakietu &quot;datasets&quot;. data(&quot;faithful&quot;, package = &quot;datasets&quot;) Po wykonaniu tej funkcji zbiór danych jest dostępny z poziomu R. Zawiera on ramkę danych z dwoma kolumnami opisującymi gejzer Old Faithful (rycina 9.1): eruptions - czas erupcji oraz waiting - czas oczekiwania na kolejną erupcję. head(faithful) #&gt; eruptions waiting #&gt; 1 3.60 79 #&gt; 2 1.80 54 #&gt; 3 3.33 74 #&gt; 4 2.28 62 #&gt; 5 4.53 85 #&gt; 6 2.88 55 Rycina 9.1: Obraz Alberta Bierstadta przedstawiający gejzer Old Faithful około roku 1881. Źródło: Wikipedia. 9.7 Arkusze kalkulacyjne Powszechnym sposobem przechowywania danych tabelarycznych są arkusze kalkulacyjne tworzone w programie Microsoft Excel. Tego typu dane można wczytać do R używając pakietu readxl (Wickham and Bryan 2019). Główną funkcją tego pakietu jest read_excel(), przyjmująca ścieżkę pliku do wczytania. Dodatkowe argumenty tej funkcji pozwalają, np. na zdefiniowanie arkusza do wczytania (sheet) czy zasięgu komórek (range). library(readxl) meteo_z_xl = read_excel(&quot;pliki/dane_meteo.xlsx&quot;) head(meteo_z_xl) #&gt; # A tibble: 6 x 9 #&gt; kod_stacji nazwa_stacji rok miesiac dzien tavg precip humidity #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 352160330 POZNAŃ 2017 1 1 1.4 0 78 #&gt; 2 352160330 POZNAŃ 2017 1 2 0.1 0 84 #&gt; 3 352160330 POZNAŃ 2017 1 3 0.5 4.8 91.1 #&gt; 4 352160330 POZNAŃ 2017 1 4 1.5 2.3 84.9 #&gt; 5 352160330 POZNAŃ 2017 1 5 -3.5 0 68.3 #&gt; 6 352160330 POZNAŃ 2017 1 6 -8.4 0 78.6 #&gt; # … with 1 more variable: pressure &lt;dbl&gt; Do zapisania ramki danych do formatu Excel można użyć funkcji write_xlsx() z pakietu writexl (Ooms 2018)44. 9.8 Inne formaty Powyżej można było zobaczyć jaki sposób można wczytać dane z różnorodnych plików tekstowych, R, czy arkuszy kalkulacyjnych. R pozwala jednocześnie na otworzenie wielu innych formatów plików używając dodatkowych pakietów. Przykładowo, hierarchiczne formaty danych można wczytać używając pakietu jsonline (format .json) (Ooms, Temple Lang, and Hilaiel 2018) czy xml2 (format .xml) (Wickham, Hester, and Ooms 2018), a formaty danych przestrzennych używając pakietu sf (dane wektorowe) (Pebesma 2019) czy raster (dane rastrowe) (Hijmans 2019). Zestawienie zawierające dodatkowe przykłady można znaleźć pod adresem https://github.com/leeper/rio. Powszechną sytuacją jest przechowywanie danych w różnego rodzaju bazach danych. Ma to miejsce, kiedy dane są znacznej wielkości, mają złożone relacje, czy też muszą być jednocześnie dostępne dla wielu osób. Dostęp do baz danych w R możliwy jest używając pakietu DBI (R Special Interest Group on Databases (R-SIG-DB), Wickham, and Müller 2018) wraz z dodatkowym pakietem dla konkretnego systemu bazodanowego (np. RPostgreSQL dla baz PostgreSQL (Conway et al. 2017) czy RSQLite dla baz SQLite (Müller et al. 2018)).45 9.9 Zadania Bibliografia "],
["przykad-1.html", "10 Przykład 1", " 10 Przykład 1 "],
["zlozone-funkcje.html", "11 Złożone funkcje 11.1 API 11.2 Obsługa komunikatów 11.3 Programowanie obiektowe 11.4 Zadania", " 11 Złożone funkcje Funkcje są podstawą działania w językach programowania. Rozdział 3 wprowadził do podstawowych kwestii związanych z funkcjami - jak się używa wbudowanych funkcji oraz jak się tworzy proste nowe funkcje. Tworzenie bardziej złożnych funkcji czy też zbiorów funkcji wymaga przemyślenia tego nie tylko jak się będą one nazywać, ale też tego jak mogą one zostać użyte przez inne osoby. W tym rozdziale zostanie podanych kilka porad w jaki sposób budować funkcje przyjazne innym użytownikom oraz w jaki sposób tworzyć odpowiednie komunikaty błędów, ostrzeżeń czy wiadomości. Dodatkowo, nastąpi także wprowadzenie do kolejnego paradygmatu programowania - programowania obiektowego. 11.1 API Interfejs programistyczny aplikacji (ang. application programming interface, API) to zbiór sposobów komunikacji pomiędzy różnymi komponentami oprogramowania. Inaczej mówiąc API określa w jaki sposób następuje interakcja z kodem. Dobrze zaprojektowane API uławia zarówno rozwijanie oprogramowania, jak i jego używanie. Podstawowe elementy przemyślanego API w R obejmują nazwy funkcji, ich argumenty, oraz tzw. stabilność typu (ang. type stability. Funkcje wewnątrz pojedynczego pakietu powinny być nazywane konsekwentnie używając tylko jednej konwencji nazywania (sekcja 2.4.1). Sama nazwa powinna w zwięzły sposób przekazywać jakie jest działanie funkcji. Dodatkową możliwością jest używanie w jednym pakiecie funkcji rozpoczynających się od takiego samego prefiksu. Przykładowo, większość nazw funkcji w pakiecie landscapemetrics rozpoczyna się od liter lsm_, np. lsm_l_ent() (Hesselbarth et al. 2019). Podobnie należy stosować tylko jedną konwencję przy nazywaniu argumentów funkcji, a nazwy argumentów powinny być informacyjne, ale jednocześnie zwięzłe. W przypadku, gdy taki sam rodzaj danych wejściowych jest oczekiwany w różnych funkcjach, koniecznie jest aby zawsze ten argument był tak samo nazwany. Podobnie należy zadbać o spójną kolejność podobnych argumentów w funkcjach jednego pakietu. Stabilność typu oznacza, że używając jednej klasy danych wejściowych funkcja zawsze zwróci obiekt jednej klasy. tekst = c(&quot;kołdra&quot;, &quot;kordła&quot;, &quot;pościel&quot;) grep(&quot;^[k].&quot;, x = tekst) #&gt; [1] 1 2 grep(&quot;^[k].&quot;, x = tekst, value = TRUE) #&gt; [1] &quot;kołdra&quot; &quot;kordła&quot; Dodatkowym elementem API może być określenie domyślnych parametrów funkcji. Poniższa funkcja, potegowanie() ma na celu podnoszenie wartości wejściowego wektora (x) do wybranej potęgi (w). Domyślamy się jednak, że większość użytkowników jest zainteresowana używaniem tej funkcji do podnoszenia wartości do drugiej potęgi i dlatego też ustalamy, że domyślnie argument w przyjmuje wartość 2. potegowanie = function(x, w = 2){ x ^ w } W tej sytuacji, gdy użytkownik poda tylko jeden argument do funkcji potegowanie() to podany wektor zostanie podniesiony do kwadratu. potegowanie(2) #&gt; [1] 4 Będzie to identyczne z działaniem funkcji, gdy użytkownik ręcznie zdefinuje drugi argument jako dwa (w = 2). potegowanie(2, w = 2) #&gt; [1] 4 W sytuacji, gdy użytkownika interesuje inna wartość w niż domyślna, może on ją zmodyfikować i otrzyma odpowiedni wynik. potegowanie(2, w = 3) #&gt; [1] 8 11.2 Obsługa komunikatów W sekcji 3.9 omówiliśmy trzy podstawowe rodzaje komunikatów: błędy, ostrzeżenia i wiadomości. Teraz zobaczmy jak te zaimplementować we własnych funkcjach i kiedy powinny być one użyte. Obsługa błędów w funkcjach ma na celu ochronę użytkownika przed nieodpowiednim zachowaniem funkcji. Komunikat błędu powinien ułatwiać użytkownikowi zrozumienie problemu oraz jego rozwiązanie. Zazwyczaj komunikat błędu przyjmuje jedną z trzech form: (1) określenie problemu, np. Argument 'x' musi być zmienną numeryczną, a nie znakową., (2) lokalizacja błędu, np. Kolumna 'abc' nie istnieje w obiekcie 'y'., (3) porada, np. Did you mean 'Species == &quot;setosa&quot;'?. Oczywiście te wymienione formy można łączyć. Ważne jest też, aby funkcja kończyła swoje działanie jak najszybciej po napotkaniu, np. błędnych wartości wejściowych. Żadnej użytkownik nie chce czekać na zakończenie wykonywania długiej funkcji zanim dostanie komunikat błędu. Więcej informacji o strukturze komunikatów błędów można znaleźć na https://style.tidyverse.org/error-messages.html. Do zatrzymania działania funkcji i wyświetlenia komunikatu błędu służy stop(). stop(&quot;To jest komunikat błędu.&quot;) #&gt; Error in eval(expr, envir, enclos): To jest komunikat błędu. Ostrzeżenia mogą być używane w wielu różnorodnych sytuacjach, np. kiedy chcesz poinformować użytkowników o tym, że dana funkcja zostanie wygaszona lub przeniesiona do innego pakietu. Komunikaty ostrzeżenia tworzyć się używając funkcji warning(). warning(&quot;To jest komunikat ostrzeżenia.&quot;) #&gt; Warning: To jest komunikat ostrzeżenia. Wiadomości mają na celu poinformowanie użytkownika na temat działania pakietu lub funkcji. Są one wykorzystywane podczas wczytywania niektórych pakietów. Innym przykładem jest informowanie na temat działania funkcji w tle - pobierania danych, zapisywania do pliku, czy przeliczania cząstkowych parametrów. Do wyświetlenia wiadomości służy funkcja message(). message(&quot;To jest komunikat wiadomości.&quot;) #&gt; To jest komunikat wiadomości. Działanie funkcji message() jest zbliżone do funkcji cat() czy print(). Różni je jednak cel w jakim są użyte. Rolą funkcji message() jest przekazanie informacji od twórcy do użytkownika, natomiast celem funkcji tj. cat() jest zapytanie użytkownika w pewnej kwestii. Przykład użycia trzech podstawowych rodzajów komunikatów można zobaczyć w poniższej funkcji minus_1(). Ta funkcja przyjmuje wartość numeryczną, od której odejmuje jeden, a na końcu zwraca wartość bezwzględną (abs(x - 1)). minus_1 = function(x){ if(is.character(x)){ stop(&quot;Argument `x` musi być zmienną numeryczną, a nie znakową.&quot;) } else if(is.logical(x)){ warning(&quot;Argument `x` jest zmienną logiczną. Czy nie chcesz użyć zmiennej numerycznej?&quot;) } else { message(&quot;Wow. Argument `x` jest oczekiwaną zmienną numeryczną.&quot;) } abs(x - 1) } W przypadku, gdy użytkownik wprowadzi jako wejście wektor tekstowy (if(is.character(x))) to działanie funkcji zostanie przerwane i pojawi się odpowiedni komunikat błędu. minus_1(&quot;kot&quot;) #&gt; Error in minus_1(&quot;kot&quot;): Argument `x` musi być zmienną numeryczną, a nie znakową. Jeżeli jako argument x zostanie podany wektor logiczny (else if(is.logical(x))) to pojawi się komunikat ostrzeżenia, ale dalsze obliczanie zostanie wykonane. W tym przypadku wartość TRUE zostanie najpierw zamieniona na 1 a FALSE na zero, następnie od tych wartości zostanie odjęte jeden, a na końcu zostaną one zamienione na wartości bezwzględne. minus_1(c(TRUE, FALSE)) #&gt; Warning in minus_1(c(TRUE, FALSE)): Argument `x` jest zmienną logiczną. Czy #&gt; nie chcesz użyć zmiennej numerycznej? #&gt; [1] 0 1 Po wprowadzeniu wartości numerycznych do funkcji minus_1() pojawi się tekst wiadomości, po którym nastąpi wyliczenie kodu abs(x - 1). minus_1(c(1, 0, 6, -6)) #&gt; Wow. Argument `x` jest oczekiwaną zmienną numeryczną. #&gt; [1] 0 1 5 7 Złożone funkcje opierają się o inne istniejące funkcje. W powyższym przykładzie, minus_1() używał, między innymi funkcji - do odejmowania czy abs do wyliczania wartości bezwzględnej. Czasami spodziewamy się, że wartość wprowadzona przez użytkownika może spowodować wystąpienie wewnętrznego błędu i jednocześnie wiemy jak to naprawić. W takich sytuacjach przydaje się funkcja tryCatch(). R pozwala na ignorowanie wystąpienia błędu używając funkcji try(), ignorowanie ostrzeżeń z suppressWarnings() oraz wiadomości z suppressMessages(). tryCatch() stara się uruchomić jakiś wskazany kod, a w przypadku pojawienia się błędu wykonuje alternatywne obliczenia. Można to zobaczyć na poniższym przykładzie, gdzie najpierw sprawdzona zostałaby linia kod do uruchomienia i dopiero gdyby ona skutkowała błędem zostałaby uruchomiona linia wykonaj kod w przypadku wystąpienia błędu. tryCatch( error = function(e) { wykonaj kod w przypadku wystąpienia błędu }, kod do uruchomienia ) Działanie tryCatch w praktyce jest pokazane w funkcji log_safe(). Stara się ona wyliczyć logarytm naturalny (log()) z wartości argumentu x, a w przypadku gdyby napotkała błąd zwóci ona wartość NA. log_safe = function(x){ tryCatch( error = function(e) { NA }, log(x) ) } Sprawdźmy jej zachowanie na dwóch przykładach. W pierwszym oryginalna funkcja log() jak i nowa log_safe() otrzymają poprawne dane wejściowe - wektor numeryczny. log(10) #&gt; [1] 2.3 log_safe(10) #&gt; [1] 2.3 W tym przypadku obie zwracają dokładnie taki sam wynik. Jeżeli jednak jako dane wejściowe wprowadzimy wektor znakowy to oryginalna funkcja zwróci błąd, a nasza funkcja jedynie wartość NA. log(&quot;abecadło&quot;) #&gt; Error in log(&quot;abecadło&quot;): non-numeric argument to mathematical function log_safe(&quot;abecadło&quot;) #&gt; [1] NA Dodatkowo istnieje funkcja withCallingHandlers(), która jest używana w przypadku działania na ostrzeżeniach. 11.3 Programowanie obiektowe Programowanie obiektowe (ang. object-oriented programming, OOP) to jeden z najpopularniejszych paradygmatów programowania (sekcja 1.2). Polega on na definiowaniu obiektów danej klasy posiadających pewną określoną strukturę oraz zachowania. R pozwala również na stosowanie paradygmatu obiektowego. Co więcej, w tym języku istnieje kilka różnych systemów programowania obiektowego, między innymi S3, S4 czy R6. Każdy z nich charakteryzuje inny sposób tworzenia obiektów czy ich zachowań. W tym rozdziale skupimy się na najczęściej używanego systemu S3. Dwa najważniejsze elementy tego systemu to klasy i metody. Klasa obejmuje obiekty o podobnej strukturze, które posiadają specjalną informację o nazwie klasy. Metoda natomiast to sposób zachowania funkcji w przypadku napotkania obiektu danej klasy. Przykład metody był pokazany w sekcji 7.5, gdzie funkcja mean() zachowywała się różnie w zależności od klasy danych wejściowych. 11.3.1 Klasy Poniżej stworzono nową macierz x, która składa się z dwóch kolumn i dwóch wierszy oraz wartości 0, 0, 2 i 3. Ma ona na celu reprezentowanie figury geometrycznej - prostokąta. W najprostszej postaci prostokąt można opisać używając czterech współrzędnych - najmniejszej wartości położenia na osi x (np., 0), najmniejszej wartości położenia na osi y (np., 0), największej wartości położenia na osi x (np., 2), oraz największej wartości położenia na osi y (np., 3). x = matrix(c(0, 0, 2, 3), ncol = 2) x #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 0 3 Do sprawdzenia klasy obiektu w systemie S3 służy funkcja class(). class(x) #&gt; [1] &quot;matrix&quot; W efekcie upewniamy się, że klasa naszego obiektu x to matrix. System S3 pozwala na prostą zmianę lub dodanie nazwy klasy używając funkcji structure(). y = structure(x, class = &quot;prostokat&quot;) Wynikiem działania tej funkcji z argumentem class = &quot;prostokat&quot; jest nowy obiekt y. W momencie, gdy sprawdzimy jego klasę, okaże się że nie jest to już matrix ale prostokat. class(y) #&gt; [1] &quot;prostokat&quot; 11.3.2 Metody Posiadamy teraz nową klasę, prostokat, ale nie posiadamy do niej żadnych metod. Metoda w systemie S3 to funkcja, która działa w różny sposób w zależności od klasy danych wejściowych. Możliwe jest zarówno dodanie nowej metody do istniejącej funkcji, jak i stworzenie nowej funkcji. W tym wypadku interesuje nas możliwość policzenia powierzchni. Możemy do tego celu stworzyć nową funkcję w systemie S3 o nazwie powierzchnia. Pierwszym krokiem musi być określenie, że nasza funkcja ma być oparta o system S3 używając poniższej formy. powierzchnia = function(x) { UseMethod(&quot;powierzchnia&quot;) } Drugim krokiem jest zdefiniowanie funkcji do wyliczania powierzchni prostokąta. Określa ona najpierw długości boków a i b, a następnie wymnaża je w celu wyliczenia powierzchni. powierzchnia.prostokat = function(x){ a = x[1, 2] - x[1, 1] #wyliczenie długości boku a b = x[2, 2] - x[2, 1] #wyliczenie długości boku b a * b #wyliczenie powierzchni prostokąta } Nazwa powyższej funkcji wygląda jakby składała się z dwóch słów oddzielonych kropką - powierzchnia.prostokat. W rzeczywistości jednak nazwa funkcji to tylko powierzchnia, a kropka sugeruje że kolejny po niej wyraz to klasa obiektu jaki przyjmie funkcja. Jest to, innymi słowy, definicja metody. Nowa funkcja powierzchnia zadziała w powyższy sposób tylko w wypadku otrzymania jako dane wejściowe obiektu klasy prostokat. Sprawdżmy to na dwóch przykładach - obiektu y (klasa prostokat) i x (klasa matrix). y #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 0 3 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;prostokat&quot; powierzchnia(y) #&gt; [1] 6 W przypadku, gdy nasz obiekt wejściowy jest klasy prostokat to funkcja jest wykonywana zgodnie z metodą powierzchnia.prostokat(), x #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 0 3 powierzchnia(x) #&gt; Error in UseMethod(&quot;powierzchnia&quot;): no applicable method for &#39;powierzchnia&#39; applied to an object of class &quot;c(&#39;matrix&#39;, &#39;double&#39;, &#39;numeric&#39;)&quot; Natomiast, gdy obiekt wejściowy będzie innej klasy to pojawi się komunikat błędu sugerujący, że nie istnieje metoda dla tej klasy pozwalająca na otrzymanie wyniku. Dodatkowo, oprócz tworzenia metod dla każdej klasy oddzielnie możliwe jest stworzenie metody domyślnej poprzez nazwafunkcji.default. W przypadku, gdy dla obiektu wejściowego nie istnieje metoda to wówczas wykonywana jest metoda domyślna (default). Poniżej dodano metodę domyślną - w przypadku, gdy dla wejściowego obiektu nie ma metody to pojawi się poniższy komunikat błędu. powierzchnia.default = function(x) { stop(“Funkcja powierzchnia ma wsparcie tylko dla obieków o klasie prostokąt”) } Sprawdźmy działanie domyślnej metody podając macierz jako obiekt wejściowy. x #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 0 3 powierzchnia(x) #&gt; Error in UseMethod(&quot;powierzchnia&quot;): no applicable method for &#39;powierzchnia&#39; applied to an object of class &quot;c(&#39;matrix&#39;, &#39;double&#39;, &#39;numeric&#39;)&quot; 11.3.3 Konstruktory Trudno oczekiwać od użytkownika, że bez żadnych pomyłek stworzy obiekt klasy, który wymyśliliśmy, a następnie użyje funkcji structure(), aby dodać odpowiednią nazwę klasy. Dlatego też ważnym elementem jest stworzenie konstruktora - funkcji, której celem jest zbudowanie poprawnego obiektu naszej klasy, a w przypadku podania złych argumentów wejściowych poinformowanie użytkownika co jest nie tak. Poniżej znajduje się konstruktor o nazwie nowy_prostokąt(). Przyjmuje on wartości czterech współrzędnych, a następnie wykonuje szereg sprawdzeń ich poprawności: Czy wszyskie argumenty są typu numerycznego? Czy każdy argument ma tylko jeden element? Czy minimalna wartość współrzędnej x jest mniejsza od maksymalnej? Czy minimalna wartość współrzędnej y jest mniejsza od maksymalnej? Po tych sprawdzeniach następuje zbudowanie nowej macierzy oraz dodanie nazwy klasy. nowy_prostokat = function(xmin, ymin, xmax, ymax){ vals = c(xmin, ymin, xmax, ymax) if (!(is.numeric(vals))){ stop(&quot;Wszystkie argumenty muszą być typu numerycznego&quot;) } if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){ stop(&quot;Każdy z argumentów może przyjmować tylko jedną wartość&quot;) } x_range = vals[3] - vals[1] if (x_range &lt;= 0){ stop(&quot;`xmax` musi przyjmować wartość większą niż `xmin`&quot;) } y_range = vals[4] - vals[2] if (y_range &lt;= 0) { stop(&quot;`ymax` musi przyjmować wartość większą niż `ymin`&quot;) } x = matrix(vals, ncol = 2) structure(x, class = &quot;prostokat&quot;) } Sprawdźmy działanie tego konstruktora na dwóch przypadkach. W pierwszym podajmy poprawne, sprawdzone wcześniej wartości. nowy_p = nowy_prostokat(0, 0, 2, 3) nowy_p #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 0 3 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;prostokat&quot; Konstruktor nowy_prostokat() działa bez problemu, zwracając nowy obiekt nowy_p o klasie prostokat. Warto od razu zobaczyć, czy ten obiekt zadziała poprawnie w funkcji powierzchnia(). powierzchnia(nowy_p) #&gt; [1] 6 W przypadku, gdy do konstruktora zostaną podane niepoprawne wartości wejściowe pojawi się odpowiedni komunikat błędu. nowy_p2 = nowy_prostokat(7, 0, 6, 0) #&gt; Error in nowy_prostokat(7, 0, 6, 0): `xmax` musi przyjmować wartość większą niż `xmin` 11.4 Zadania Bibliografia "],
["analiza-kodu.html", "12 Analiza kodu 12.1 Testy jednostkowe 12.2 Benchmarking 12.3 Profiling 12.4 Zadania", " 12 Analiza kodu Programując naszym celem jest tworzenie funkcji, które są zarówno poprawne oraz wydajne (zwracają wynik szybko). W tym rozdziale przedstawione będą testy jednostkowe, które sprawdzają czy funkcje zwracają oczekiwany wynik oraz metody sprawdzające wydajność funkcji, takie jak, benchmarking i profiling. 12.1 Testy jednostkowe Testy jednostkowe (ang. unit tests) to sposób sprawdzania czy stworzona przez nas funkcja działa w sposób jaki oczekujemy. Tworzenie takich testów wymusza także myślenie na temat odpowiedniego działania funkcji i jej API. Testy jednostkowe są najczęściej stosowane w przypadku budowania pakietów (sekcja 16.5), gdzie możliwe jest automatyczne sprawdzenie wielu testów na raz. Przykładowo, napisaliśmy nową funkcję, która wykonuje złożone operacje i, po wielu sprawdzeniach, wiemy, że daje poprawne wyniki. Po kilku miesiącach wpadliśmy na pomysł jak zwiększyć wydajność naszej funkcji. W tym momencie wystarczy już tylko stworzyć nową implementację i użyć wcześniej zbudowanych testów. Dadzą one informację, czy efekt działania jest taki jaki oczekujemy, a w przciwnym razie wskażą gdzie pojawił się błąd. Istnieje też dodatkowa reguła - jeżeli znajdziesz błąd w kodzie od razu napisz test jednostkowy. Zobaczmy jak działają testy jednostkowe na przykładzie funkcji nowy_prostokat() oraz powierzchnia() stworzonych w sekcji 11.3. nowy_prostokat = function(xmin, ymin, xmax, ymax){ if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){ stop(&quot;Każdy z argumentów może przyjmować tylko jedną wartość&quot;) } vals = c(xmin, ymin, xmax, ymax) if (!(is.numeric(vals))){ stop(&quot;Wszystkie argumenty muszą być typu numerycznego&quot;) } x = matrix(vals, ncol = 2) structure(x, class = &quot;prostokat&quot;) } powierzchnia = function(x) { UseMethod(&quot;powierzchnia&quot;) } powierzchnia.prostokat = function(x){ a = x[1, 2] - x[1, 1] b = x[2, 2] - x[2, 1] a * b } Jednym z możliwych narzędzi do testów jednostkowych w R jest pakiet testthat (Wickham 2018). library(testthat) Zawiera on szereg funkcji sprawdzających czy działanie naszych funkcji jest zgodne z oczekiwaniem. Funkcje w tym pakiecie rozpoczynają się od prefiksu expect_ (oczekuj). W przypadku funkcji powierzchnia() oczekujemy, że wynik będzie zawierał tylko jeden element. Możemy to sprawdźić za pomocą funkcji expect_length(). nowy_p = nowy_prostokat(0, 0, 6, 5) expect_length(powierzchnia(nowy_p), 1) Jeżeli wynik ma długość jeden to wówczas nic się nie stane. W przeciwnym razie pojawi się komunikat błędu. Wiemy, że powierzchnia naszego przykładowego obiektu nowy_p to 30. Do sprawdzenia, czy nasza funkcja daje na tym obiekcie dokładnie taki wynik możemy użyć expect_equal(). expect_equal(powierzchnia(nowy_p), 30) W momencie, gdy wynik jest zgodny to nie nastąpi żadna reakcja, a w przeciwnym razie wystąpi błąd. W pakiecie testthat istnieją inne funkcje podobne do expect_equal(). Przykładowo, funkcja expect_identical() sprawdza nie tylko podobieństwo wartości, ale też to czy klasa wyników jest taka sama. Aby sprawdzić czy nasza funkcja na pewno zwróci błąd w przypadku podania niepoprawnych danych wejściowych możemy użyć funkcji expect_error(). Jej działanie jest przedstawione poniżej. expect_error(nowy_prostokat(3, 5, 2, &quot;a&quot;)) expect_error(nowy_prostokat(1, 2, 3, 6)) #&gt; Error: `nowy_prostokat(1, 2, 3, 6)` did not throw an error. W przypadku, gdy wywołanie funkcji zwróci błąd, expect_error() nic nie zwróci. Natomiast, jeżeli wywołania funkcji nie zwróci błędu, expect_error() zatrzyma swoje działanie i zwóci komunikat. Odpowiednikami expect_error() dla ostrzeżeń jest expect_warning(), a dla wiadomości expect_message(). Pozostałe funkcje z tego pakietu są wymienione i opisane na stronie https://testthat.r-lib.org/reference/index.html. 12.2 Benchmarking Benchmarking oznacza określanie wydajności danej operacji czy funkcji. Wydajność może być określona na wiele różnych sposobów, w tym najprostszym jest czas wykonania pewnego kodu. Do określenia ile czasu zajmuje działanie operacji można użyć wbudowanej funkcji system.time(). system.time(kod_do_wykonania) Przykładowo, poniżej nastąpi sprawdzenie czasu jaki zajmie wyliczenie średniej wartości z sekwencji od 1 do 100000000. system.time(mean(1:100000000)) #&gt; user system elapsed #&gt; 0.572 0.000 0.569 W efekcie dostajemy trzy wartości - user, system i elapsed. Pierwsza z nich określa czas obliczenia po stronie użytkownika (sesji R), druga opisuje czas obliczenia po stronie systemu operacyjnego (np. otwieranie plików), a trzecia to sumaryczny czas wykonywania operacji. Benchmarking jest często używany w sytuacji, gdy istnieje kilka funkcji służących do tego samego celu (np. w różnych pakietach) i chcemy znaleźć tę, która ma najwyższą wydajność. Jest on też stosowany, gdy sami napisaliśmy kilka implementacji rozwiązania tego samego problemu i chcemy sprawdzić, które z nich jest najszybsze. W sekcji 8.1.2 stworzyliśmy kilka wersji pętli for pozwalającej na przeliczanie wartości z mil lądowych na kilometry. Pierwsza z nich, tutaj zdefiniowana jako funkcja mi_do_km1, tworzy pusty wektor o długości 0, do którego następie doklejane są kolejne przeliczone wartości. mi_do_km1 = function(odl_mile){ odl_km = vector(&quot;list&quot;, length = 0) for (i in seq_along(odl_mile)) { odl_km = c(odl_km, odl_mile[[i]] * 1.609) } odl_km } Druga, tutaj zdefiniowana jako funkcja mi_do_km2, tworzy pusty wektor o oczekiwanej długości wyniku. Następnie kolejne przeliczone wartości są wstawiane w odpowiednie miejsca wektora wynikowego. mi_do_km2 = function(odl_mile){ odl_km = vector(&quot;list&quot;, length = length(odl_mile)) for (i in seq_along(odl_mile)) { odl_km[[i]] = odl_mile[[i]] * 1.609 } odl_km } Dwie powyższe funkcje można porównać używając system.time(). Nie zawsze jednak to wystarczy - ta sama funkcja wykonana dwa razy może mieć różny czas obliczeń. Dodatkowo, oprócz czasu wykonywania funkcji może nas interesować zużycie zasobów, takich jak pamięc operacyjna. Do takiego celu powstała funkcja mark() z pakietu bench (Hester 2018), która wykonuje funkcje wiele razy przed zwróceniem wyniku. Przyjmuje ona wywołania funkcji, które chcemy porównać. Poniżej nastąpi porównanie funkcji mi_do_km1 i mi_do_km2, w przypadku gdy jako dane wejściowe zostanie podana lista z wartościami 142, 63, 121. library(bench) odl_mile = list(142, 63, 121) wynik_1 = mark( mi_do_km1(odl_mile), mi_do_km2(odl_mile) ) wynik_1 #&gt; # A tibble: 2 x 10 #&gt; expression min mean median max `itr/sec` mem_alloc n_gc n_itr #&gt; &lt;chr&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 mi_do_km1… 1.45µs 2.07µs 1.74µs 26.6µs 483609. 117KB 0 10000 #&gt; 2 mi_do_km2… 1.05µs 1.3µs 1.19µs 13.5µs 771119. 222KB 0 10000 #&gt; # … with 1 more variable: total_time &lt;bch:tm&gt; Efektem porównania jest ramka danych, w której każdy wiersz oznacza inną porównywaną funkcję. Zawiera ona szereg charakterystyk, w tym: min - minimalny czas wykonania funkcji mean - średni czas wykonania funkcji median - mediana czasu wykonania funkcji max - maksymalny czas wykonania funkcji itr/sec - liczba wykonań funkcji na sekundę mem_alloc - pamięć użyta przez wywołanie funkcji n_itr - liczba powtórzeń wywołania funkcji Wynik działania funkcji mark() pozwala na zauważnie, że na tym przykładzie funkcja mi_do_km2 jest ok. 30% szybsza od mi_do_km1. Czasami możliwe jest, że jakaś funkcja działa relatywnie szybko na małych danych, ale dużo wolniej na większych danych wejściowych. Warto jest więc sprawdzić, jak będzie wyglądało nasze porównanie na większej liście, np. z wartościami od 0 do 10000 co 1. odl_mile2 = as.list(0:10000) wynik_2 = mark( mi_do_km1(odl_mile2), mi_do_km2(odl_mile2) ) #&gt; Warning: Some expressions had a GC in every iteration; so filtering is #&gt; disabled. wynik_2 #&gt; # A tibble: 2 x 10 #&gt; expression min mean median max `itr/sec` mem_alloc n_gc n_itr #&gt; &lt;chr&gt; &lt;bch&gt; &lt;bch:t&gt; &lt;bch:&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 mi_do_km1… 477ms 485.8ms 486ms 494.52ms 2.06 382MB 16 2 #&gt; 2 mi_do_km2… 901µs 1.1ms 944µs 9.54ms 911. 78.2KB 9 456 #&gt; # … with 1 more variable: total_time &lt;bch:tm&gt; W tym przypadku róznica pomiędzy mi_do_km1 a mi_do_km2 staje się dużo większa. Funkcja mi_do_km1 jest w stanie wykonać tylko 2.06 operacji na sekundę, przy aż 911.27 operacji na sekundę funkcji mi_do_km2. Dodatkowo, funkcja mi_do_km1 potrzebowała aż kilka tysięcy (!) razy więcej pamięci operacyjnej niż mi_do_km2. #&gt; Running with: #&gt; x #&gt; 1 10 #&gt; 2 100 #&gt; 3 1000 #&gt; 4 10000 #&gt; Warning: Some expressions had a GC in every iteration; so filtering is #&gt; disabled. #&gt; # A tibble: 8 x 11 #&gt; expression x min mean median max `itr/sec` mem_alloc #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; #&gt; 1 mi_do_km1… 10 3.92µs 5.12µs 4.66µs 110.63µs 195363. 0B #&gt; 2 mi_do_km2… 10 1.75µs 2.09µs 1.95µs 19.81µs 477924. 0B #&gt; 3 mi_do_km1… 100 67.56µs 77.11µs 74.35µs 201.56µs 12968. 43.16KB #&gt; 4 mi_do_km2… 100 9.16µs 10.82µs 10µs 3.49ms 92393. 856B #&gt; 5 mi_do_km1… 1000 4.5ms 4.75ms 4.75ms 5.03ms 210. 3.87MB #&gt; 6 mi_do_km2… 1000 86.29µs 98.5µs 93.44µs 2.98ms 10152. 7.87KB #&gt; 7 mi_do_km1… 10000 558.7ms 558.7ms 558.7ms 558.7ms 1.79 382.04MB #&gt; 8 mi_do_km2… 10000 881.02µs 1.04ms 935.56µs 5.94ms 965. 78.18KB #&gt; # … with 3 more variables: n_gc &lt;dbl&gt;, n_itr &lt;int&gt;, total_time &lt;bch:tm&gt; 12.3 Profiling Istnieją trzy podstawowe reguły optymalizacji kodu46: Nie. Jeszcze nie. Profiluj przed optymalizowaniem. Czym jest profilowanie i dlaczego powinno być wykonywane przed optymalizowaniem kodu? Profilowanie mierzy wydajność działania każdej linii kodu w celu sprawdzenia, która linia zabiera najwięcej czasu lub zasobów. Dzięki profilowaniu można określić fragmenty kodu, które można poprawić w celu zwiększenia czasu wykonywania skryptu czy funkcji. Poniżej znajduje się zawartość pliku R/moja_funkcja.R. Jego działanie polega na stworzeniu wektora od 1 do 9999999 (obiekt x), wektora od 1 do 19999998 co 2 (obiekt y), połączenie tych wektorów do ramki danych (obiekt df), wyliczenie sumy wartości dla każdego wiersza (obiekt z), a na końcu wyliczenie średniej z obiektu z. Która z tych linii zabiera najwięcej czasu a która najmniej? # plik R/moja_funkcja.R x = 1:9999999 y = seq(1, 19999998, by = 2) df = data.frame(x = x, y = y) z = rowSums(df) mean(z) Profilowanie kodu R można wykonać używając funkcji profvis() z pakietu profvis (Chang and Luraschi 2018). Przyjmuje ona kod lub funkcję, która ma zostać profilowana. library(profvis) profvis(source(&quot;R/moja_funkcja.R&quot;)) W powyższym przypadku nastąpiło profilowanie kodu zawartego w skrypcie R/moja_funkcja.R. Efektem działania jest interaktywne podsumowanie pokazujące zużycie pamięci oraz czas poświęcony dla kolejnych linii kodu (rycina 12.1). Rycina 12.1: Zrzut ekranu przedstawiający wynik działania funkcji profvis(). Czas wykonania tego przykładu wyniósł sumarycznie 690ms. Pierwsza linia tworząca obiekt x została wykonana bardzo szybko - poniżej mierzalnego progu. Stworzenie obiektu y w drugiej linii zajęło ok. 280ms. Trzecia linia została wykonana również w czasie poniżej mierzalnego progu. Wynika to z kwestii, że tworzenie tam ramki danych nie powoduje wykonania nowych, złożonych obliczeń. Powstała ona jedynie poprzez przekazanie odpowiednich adresów w pamięci do obiektów x i y. Najbardziej czasochłonną okazała się linia czwarta. Wyliczenie sum wierszy i stworzenie obiektu z zabrało ok. 400ms. Ostatnia linia, wyliczająca średnią, zabrała ok. 10ms. 12.4 Zadania Bibliografia "],
["debugging.html", "13 Debugowanie 13.1 Zadania", " 13 Debugowanie 13.1 Zadania "],
["lacznik.html", "14 Łącznik 14.1 C++ 14.2 Python 14.3 Zadania", " 14 Łącznik 14.1 C++ 14.2 Python 14.3 Zadania "],
["kontrola-wersji.html", "15 Kontrola wersji 15.1 Git 15.2 GitHub 15.3 Kontrola wersji w RStudio {(???)} 15.4 Sposób pracy 15.5 Zadania", " 15 Kontrola wersji Systemy kontroli wersji to narzędzia pozwalające na zapamiętywaniu zmian zachodzących w plikach. Dzięki nim możemy sprawdzić nie tylko kiedy zmieniliśmy dany plik i kto go zmienił, ale co najważniejsze - możemy linia po linii prześledzić zmiany wewnątrz tego pliku. Dodatkowo, mamy możliwość przywracania wersji pliku z wybranego czasu w całej historii jego zmian. Systemy kontroli wersji są bardzo powszechnie wykorzystywane przy tworzeniu wszelakiego rodzaju oprogramowania. Wynika to nie tylko z ich zalet wymienionych powyżej, ale również rozbudowanych możliwości pozwalających na współpracę wielu osób nad jednym projektem. Istnieje wiele systemów kontroli wersji różniących się zarówno używaną terminologią, sposobem działania czy możliwościami.47 Współcześnie najbardziej popularnym systemem kontroli jest Git, któremu będzie poświęcona reszta tego rozdziału. Inne popularne systemy kontroli wersji to Concurrent Versions System (CVS), Mercurial czy Subversion (SVN). 15.1 Git System Git jest niezależny od języka (lub języków) programowania, które używamy. Jego działanie oparte jest o system komend rozpoczynających się od słowa git, które należy wykonać w systemowym oknie konsoli.48 Zrozumienie działania systemu Git wymaga także poznania kilku nowych terminów. Git składa się z kilkudziesięciu komend, których działanie jest dalej uzależnione od podanych argumentów. Tutaj przedstawiony zostanie tylko podzbiór najczęściej używanych. Pełniejszy opis komend systemu Git można znaleźć pod adresem https://education.github.com/git-cheat-sheet-education.pdf lub http://rogerdudler.github.io/git-guide/index.pl.html. 15.1.1 Konfiguracja systemu Git Kolejnym krokiem po instalacji systemu Git49 jest jego konfiguracja. Można ją wykonać używając wbudowanego terminala (Mac OS i Linux) lub terminala dodanego podczas instalacji systemu Git (Windows). Polega ona na podaniu nazwy użytkownika (np. &quot;Imie Nazwisko&quot;) oraz jego adresu email (&quot;email@portal.com&quot;). git config --global user.name &quot;imie nazwisko&quot; git config --global user.email &quot;email&quot; 15.1.2 Repozytorium Podstawowym z nich jest repozytorium (ang. repository, często określane skrótowo jako repo). Jest to folder, który przechowuje wszystkie pliki i foldery w ramach jednego projektu.50 Dodatkowo wewnątrz repozytorium znajduje się ukryty folder .git, który zawiera informację o historii i zmianach każdego z naszych plików. Repozytorium może znajdować się na dysku naszego komputera (wtedy jest nazywane repozytorium lokalnym) lub też na serwerze w internecie (określane jako repozytorium zdalne (ang. remote)). Istnieje wiele serwisów internetowych pozwalających na tworzenie, przechowywanie i edycję repozytoriów zdalnych, między innymi GitHub (przybliżony w sekcji 15.2), GitLab, czy BitBucket. # określenie obecnego katalogu jako repozytorium Git git init 15.1.3 Dodawanie zmian W nowoutworzonym repozytorium możemy tworzyć nowe pliki oraz edytować już istniejące. Po pewnym czasie możemy stwierdzić, że dodaliśmy nową funkcjonalność do funkcji lub naprawiliśmy bład w kodzie. Wtedy należy (po zapisaniu również pliku na dysku) dodać te zmiany do systemu Git. Po dodaniu zmian są one przechowywane w miejscu określanym jako Index. Działa ono jak poczekalnia - w tym momencie zmiany jeszcze nie są potwierdzone, ale możemy sprawdzić co zmieniło się od ostatniego zatwierdzenia zmian. # dodanie pojedynczego pliku git add sciezka_do_pliku # dodanie wszystkich plików git add --all 15.1.4 Sprawdzanie zmian Zanim zatwierdzimy zmiany można je sprawdzić. W ten sposób dla każdej linii tekstu (kodu) otrzymuje się informacje co zostało dodane lub usunięte. # sprawdzenie dodanych zmian git diff 15.1.5 Zatwierdzanie zmian Zatwierdzanie zmian (ang. commit) powoduje ich zapisanie na stałe w systemie Git. Wymaga to dodania wiadomości, która opisuje wprowadzone zmiany. # zawierdzenie dodanych zmian git commit -m &quot;opis wprowadzonych zmian&quot; 15.1.6 Rozgałęzienia Częstą sytuacją jest posiadanie stabilnego, działającego kodu, ale co do którego mamy pomysły jak go ulepszyć, np. zwiększyć jego wydajność. Wtedy edycja poprawnego kodu może nie przynieść najlepszych wyników - co jeżeli nasz pomysł się jednak nie sprawdzi? Lepszą możliwością jest użycie rozgałęzień (ang. branches) w systemie Git. Domyślnie nowe repozytorium posiada już jedną gałąź nazwaną master. # wypisanie wszystkich rozgałęzień git branch Kolejnym krokiem jest utworzeie nowego rozgałęzienia. W efekcie tego działania nowa gałąź staje się odniesieniem do istniejącego stanu obecnej gałęzi. # utworzenienie nowego rozgałęzienia git branch nazwa_nowej_galezi Co ważne utworzenie nowego rozgałęzienia nie powoduje przejście do niego - należy to samodzielnie wykonać. # przejście do innego rozgałęzienia git checkout nazwa_nowej_galezi W tym momencie możliwe jest testowanie różnych możliwości ulepszenia istniejącego kodu bez obawy, że wpłynie to na jego działającą wersję. Po stwierdzeniu, że nasze zmiany są odpowiednie należy je dodać (sekcja 15.1.3) i zatwierdzić (sekcja 15.1.5). Teraz można powrócić do głównej gałęzi (master) i dołączyć zmiany stworzone w innej gałęzi. # powrót do głównej gałęzi git checkout master # połączenie wybranego rozgałęzienia z obecnym git merge nazwa_nowej_galezi 15.1.7 Repozytorium zdalne System Git ma wiele zalet w przypadku samodzielnej pracy na własnym komputerze, zyski z jego używania są jednak znacznie większe, gdy nasze repozytoria mają też zdalne odpowiedniki. Łączenie się ze zdalnymi repozytoriami może nastąpić na dwa sposoby. W pierwszym z nich repozytorium zdane już istnieje, a my chcemy się do niego podłączyć i je pobrać. # pobranie kopii istniejącego zdalnego repo git clone sciezka_do_zdalnego_repo Drugim sposobem jest posiadanie istniejącego, lokalnego repozytorium, a następnie dodanie do niego adresu zdalnego repozytorium. # dodanie ścieżki do zdalnego repo git remote add origin sciezka_do_zdalnego_repo 15.1.8 Wysyłanie zmian Obecne dodane i zatwierdzone zmiany znajdują się jedynie w repozytorium lokalnym. Konieczne jest ich wysłanie do zdalnego repozytorium. # wysyłanie zmian do zdalnego repo git push 15.1.9 Aktualizowanie Zdalne repozytoria mogą pozwalać na nadawanie różnych uprawnień użytkownikom. Możliwe jest określenie, że inne osoby mogą nanosić zmiany w zdalnych repozytoriach. Dodatkowo, jedna osoba może zmieniać zdalne repozytoria używając różnych komputerów. Konieczne jest więc aktualizowanie zmian, które zaszły w zdalnym repozytorium na lokalnym komputerze. # aktualizowanie zmian ze zdalnego repo git pull 15.2 GitHub GitHub jest serwisem internetowym pozwalającym na przechowywanie i interakcję z repozytoriami w systemie kontroli wersji Git. Posiada on dwa rodzaje repozytorów - publiczne (ang. public), które może każdy zobaczyć oraz prywatne (ang. private) dostępne tylko dla osób z odpowiednimi uprawnieniami. Repozytoria połączone są z kontami użytkowników (np. https://github.com/Nowosad to moje konto, gdzie “Nowosad” oznacza nazwę użytkownika) lub organizacjami (np. https://github.com/r-spatialecology to konto organizacji “r-spatialecology”). Pod adresem https://github.com/join można założyć nowe konto użytkownika. Posiadanie konta użytkownika pozwala na, między innymi, tworzenie nowych repozytoriów i zarządzanie nimi. Stworzenie nowego repozytorium odbywa się poprzez naciśnięcie zielonej ikony (rycina 15.1). Rycina 15.1: Ikona tworzenia nowego repozytorium GitHub. W kolejnym oknie (rycina 15.2) należy podać nazwę nowego repozytorium oraz wybrać czy będzie ono publiczne czy prywatne. Dodatkowo możliwe jest dodanie opisu repozytorium (ang. description), pliku README, czy licencji. Rycina 15.2: Okno tworzenia nowego repozytorium GitHub. Po wybraniu potwierdzenia (Create repository) utworzone zostanie nowe, puste repozytorium (rycina 15.3). Rycina 15.3: Nowe, puste repozytorium GitHub. Okno pustego repozytorium przedstawia cztery główne drogi pozwalające na dodanie zawartości: Szybka konfiguracja - tutaj podane są dwie możliwe ścieżki do zdalnego repozytorium. Pierwsza z nich to adres HTTPS a druga to adres SSH. W sekcji ?? zostanie wyjaśnione jak korzystać z szybkiej konfiguracji. Stworzenie nowego repozytorium używając linii komend. Jest to używane w sytuacjach, gdy lokalna wersja repozytorium jeszcze nie istnieje. W tej sytuacji (1) tworzony jest nowy plik tekstowy README.md, (2) obecny katalog jest określany jako repozytorium Git, (3) plik README.md jest dodawany do repozytorium, (4) dodanie tego pliku jest zatwierdzone wraz z wiadomością `“first commit”, (5) dodana jest ścieżka do zdalnego repozytorium, (6) następuje wysłanie zmian z lokalnego do zdalnego repozytorium. Wysłanie zmian z istniejącego repozytorium. Ta opcja przydaje się, gdy mamy już istniejące lokalne repozytorium, ale do którego nie ma jeszcze zdalnego repozytorium. Tutaj następuje tylko (1) dodanie ścieżki do zdalnego repozytorium oraz (2) wysłanie zmian z lokalnego do zdalnego repozytorium. Import kodu z innego systemu kontroli wersji niż Git. Oprócz dostępu do kodu i jego zmian, GitHub oferuje także szereg dodatkowych możliwości. Obejmuje to, między innymi, automatyczne wyświetlanie plików README, śledzenie spraw (ang. issue tracking), zapytania aktualizacyjne (ang. pull request), wizualizacje zmian, czy nawet tworzenie stron internetowych. 15.3 Kontrola wersji w RStudio {(???)} 15.4 Sposób pracy 15.5 Zadania https://en.wikipedia.org/wiki/Comparison_of_version-control_software#History_and_adoption↩ Nie w oknie konsoli R.↩ Instrukcje dotyczące instalacji Gita znajdują się we wstępie książki.↩ W kontekście R, warto o tym myśleć jako o projekcie RStudio.↩ "],
["tworzenie-pakietow.html", "16 Tworzenie pakietów 16.1 Rozwijanie pakietu 16.2 Dokumentacja funkcji 16.3 Zależności 16.4 Dokumentacja pakietu 16.5 Wbudowane testy 16.6 Licencje 16.7 Publikowanie pakietów 16.8 Zadania", " 16 Tworzenie pakietów (Wickham and Bryan 2018) Funkcja create_packages() tworzy cztery pliki: .Rproj R/ DESCRIPTION NAMESPACE 16.1 Rozwijanie pakietu 16.2 Dokumentacja funkcji 16.3 Zależności 16.4 Dokumentacja pakietu 16.5 Wbudowane testy 16.6 Licencje 16.7 Publikowanie pakietów software documentation software promotion Continuous Integration 16.8 Zadania Bibliografia "],
["podsumowanie.html", "17 Podsumowanie", " 17 Podsumowanie "],
["bibliografia.html", "Bibliografia", " Bibliografia "]
]
