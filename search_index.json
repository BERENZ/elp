[
["index.html", "Elementarz programisty Wstęp do programowania używając R O książce Wymagania wstępne Styl książki Podziękowania", " Elementarz programisty Wstęp do programowania używając R Jakub Nowosad 2019-03-06 O książce Aktualna wersja książki znajduje się pod adresem https://nowosad.github.io/elp/. Jeżeli używasz tej książki, zacytuj ją jako: Nowosad, J., (2019). Elementarz programisty: wstęp do programowania używając R. Poznań: Space A. Online: https://nowosad.github.io/elp/ Zachęcam również do zgłaszania wszelkich uwag, błędów, pomysłów oraz komentarzy na stronie https://github.com/nowosad/elp/issues. Ta książka jest dostępna na licencji Creative Commons Uznanie autorstwa - Użycie niekomercyjne - Bez utworów zależnych 4.0 Międzynarodowe. Wymagania wstępne Do odtworzenia przykładów oraz do wykonania zadań zawartych w tej książce konieczne jest posiadanie aktualnej wersji R. Pod adresem https://cloud.r-project.org/ można znaleźć instrukcje instalacji R dla systemów Windows, Mac OS i Linux. W niektórych rodziałach użyte zostanie zintegrowane środowisko programistyczne RStudio. Można je zainstalować korzystając ze strony https://www.rstudio.com/products/rstudio/download/#download. Aspekty dotyczące kontroli wersji zostaną omówione używając oprogramowania Git. Zalecanym sposobem installacji Git na Windows jest wersja ze strony https://gitforwindows.org/. Instrukcja instalacji na system Mac OS znajduje się pod adresem https://happygitwithr.com/install-git.html#macos. Wersję Linuxową można zainstalować używając poniższej linii kodu: # Ubuntu sudo apt install git # Fedora sudo dnf install git Dodatkowo, warto stworzyć konto na stronie GitHub poprzez adres https://github.com/join. GitHub jest serwisem internetowym wspierającym tworzenie oraz współpracę przy tworzeniu programów komputerowych. Styl książki W całej książce stosowana jest konwencja, w której fun() oznacza funkcje, obi oznacza nazwy obiektów, nazwy zmiennych oraz argumentów funkcji, a sci/ oznacza ścieżki do plików. Wszystkie pakiety użyte w tej książce oznaczane są pogrubioną czcionką - pak. Tekst na szarym tle przedstawia blok kodu. Może on zawierać komentarze (rozpoczynające się of znaku #), kod oraz wynik jego użycia (rozpoczynające się od znaków #&gt;). # komentarz kod #&gt; wynik użycia kodu Dodatkowo, ikona kompasu na szarym tle przedstawia dodatkowe informacje, alternatywne sposoby użycia funkcji, czy też wskazówki. Tutaj może znaleźć się dodatkowa informacja, alternatywny sposób użycia funkcji, czy też wskazówka. Podziękowania Książka została stworzona w R (R Core Team 2017) z wykorzystaniem pakietów bookdown (Xie 2018a), rmarkdown (Allaire et al. 2018), knitr (Xie 2018b) oraz programu Pandoc. Użyte ikony zostały stworzone przez Freepik z www.flaticon.com na licencji CC 3.0 BY. Bibliografia "],
["wprowadzenie.html", "1 Wprowadzenie 1.1 Mity programistyczne 1.2 Języki programowania 1.3 R 1.4 Zadania", " 1 Wprowadzenie Żyjemy obecnie w epoce trzeciej rewolucji przemysłowej1, zwanej inaczej rewolucją cyfrową. Jest ona powiązana z przejściem z technologii mechanicznych i analogowych na technologie elektroniczne i cyfrowe. W tej epoce nastąpiło stworzenie i rozpowszechnieniem się komputerów, co w efekcie spowodowało szerokie zmiany społeczno-ekonomiczne. Wiele z tych zmian jest pozytywnych, ale istnieją również zmiany negatywne, bądź też takie które trudno jednoznacznie ocenić. Przykładowo, wyraźną korzyścią społeczną jest znacznie ułatwiony dostęp do informacji. Jednocześnie taki dostęp powoduje sytuację określaną jako przeciążenie informacją (ang. information overload), w której występuje zbyt wielka ilość informacji aby podjąć właściwą decyzję lub zrozumieć sens danego tematu. Rozwój technologiczny spowodował też transformację produkcji przemysłowej i zmiany gospodarcze. Firmy zajmujące się technologiami informacyjnymi, tj. Microsoft, Apple, czy Google, są obecnie jednymi z najbardziej dochodowych przedsiębiorstw, a twórca platformy Amazon, Jeff Bezos, jest najbogatszym człowiekiem świata2. Wiele z tych technologii nie byłoby możliwych bez programowania. Programowanie, w znacznym uproszczeniu, to proces tworzenia serii instrukcji, które informują komputer jak wykonać pewne zadanie. Ta seria instrukcji jest zazwyczaj zapisywana na komputerze w postaci tekstu w wybranym języku programowania. Co w takim razie powoduje, że programowanie ma tak istotny wpływ na wiele elementów codziennego życia? Programowanie cechuje kilka unikatowych możliwości. Po pierwsze, programowanie i jego efekty można w prosty sposób powielać niemal w nieskończoność. Wcześniej stworzenie pewnego towaru opierało się o ograniczone zasoby, np. ziemia czy surowce naturalne. Nie możliwe było wykucie zbroi raz, a następnie natychmiastowe powielenie jej wiele razy i sprzedanie jej wielu kopii. We współczesnym świecie, jedna aplikacja może być sprzedana (lub rozpowszechniona) wiele razy, a często większy nacisk kładzie się na rozbudowę i ulepszanie istniejących popularnych aplikacji niż tworzenie nowych3. Ułatwia to też budowę nowych rozwiązań na podstawie już istniejących4. Współcześnie programowanie pozwala na wykonywanie trylionów (1018) operacji arytmetycznych na sekundę5. Pozwala to na znaczne zwiększenie wydajności dostępnych rozwiązań, otwiera możliwość praktycznego wykorzystania istniejących idei, lub też tworzenia nowych pomysłów. Inną cechą programowania jest też jego prosta możliwość automatyzacji powtarzanych czynnośći oraz ułatwiona powtarzalność (ang. reproducibility) Posiadając kod źródłowy danego oprogramowania lub skrypt wykonujący analizę danych, możliwe jest odtworzenie tego wyniku przez inną osobę na drugim końcu świata, lub też przez siebie samego po paru miesiącach. Ostatnią cechą programowania jest jego uniwersalność. Jest ono wykorzystywane w transporcie, przemyśle, nauce, rozrywce i wielu innych strefach życia. W efekcie zrozumienie i znajomość języków programowania jest cenną umiejętnością we współczesnym świecie. 1.1 Mity programistyczne Programowanie komputerowe ma obecnie już długą historię - pierwszy język programowania Plankalkül powstał w latach 1943-19456. Fortran, stworzony w roku 1957, jest nadal używany współcześnie do wielu celów, między innymi wymagających dużej wydajności obliczeń hydrologicznych, prognozowania pogody czy modelowania klimatu. Programowanie ewoluowało i nadal ewoluuje wraz z rozwojem dostępności i możliwości komputerów. Pojawiły się nowe pradygmaty programowania oraz wiele nowych języków. W tym samym czasie narosło również wiele mitów dotyczących programowania7. Jednym z mitów jest to, że programowanie polega tylko siedzeniu przed ekranem komputera i wpisywaniu do niego kolejnych linii kodu. Jest to oczywiście istotna część pracy programistycznej, ale prawdopodobnie nie jest ona nawet dominująca w przeciętym dniu programisty. Wcześniej konieczne jest zastanowienie się jaki problem rozwiązujemy oraz zaprojektowanie możliwego rozwiązania tego problemu. Stworzony kod może okazać się być nieprzystępny dla użytkownika, słabo zoptymalizowany, lub nawet błędny. Dlatego też innym ważnym elementem jest testowanie kodu w celu wyłapania potencjalnych problemów. Innym aspektem programowania jest tworzenie dokumentacji. Żaden program nie może zachęcić do siebie użytkowników, jeżeli nie będą oni w stanie zrozumieć jak on działa. Dokumentacja jest też cenna dla twórców programu, szczególnie kiedy konieczne jest użycie czy modyfikacja programu kilka miesięcy po jego ostatnim użyciu. Programy komputerowe są też zazwyczaj w dużej sieci powiązań z już istniejącymi bibliotekami czy oprogramowaniem. Zmiana w tych bibliotekach czy oprogramowaniu może skutkować nie zawsze oczekiwanymi zmianami w stworzonym programie. Częścią programowania jest też utrzymywanie istniejącego kodu źródłowego oraz jego ulepszanie. Programiści do swojej pracy wykorzystują też odpowiednie wspierające ich narzędzia, takie jak edytory kodu źródłowego, debugery, zintegrowane środowiska programistyczne czy systemy kontroli wersji. Mitem również jest przekonanie, że programowanie to męskie zajęcie. Bierze się ono z obecnej na rynku pracy struktury, w której około 75% programistów to mężczyźni a tylko 25% to kobiety. Ta struktura jednak nie jest odzwierciedleniem jakichś wrodzonych umiejętności. Za pierwszego programistę często uważa się Adę Lovelace, angielskiego matematyka i poetkę8. To ona w 1843 opublikowała pierwszy program komputerowy. Jej algorytm do obliczenia liczb Bernoulliego nie został jednak przetestowany, ponieważ urządzenie do tych obliczeń (zwane maszyną analityczną9) nie zostało skonstruowane. Ponad wiek później, gdy istniały już techniczne możliwości tworzenia komputerów, programowanie było uważane za kobiecy zawód10 (Rycina 1.1). Z uwagi na szereg czynników społecznych i historycznych11, w latach 1970 nastąpiło odwrócenie proporcji w tym zawodzie. Obecnie podejmowanych jest szereg inicjatyw, które mają na celu zachęcić kobiety do programowania. Wsród nich można wymienić działania organizacji R-Ladies, PyLadies, czy girls.js. Mit programisty mężczyzny jest też powiązany z wymienionym kilka akapitów niżej mitem samotnego programisty. Rycina 1.1: Margaret Hamilton stojąca w 1969 roku obok wydruków oprogramowania, które on i jej zespół stworzył na potrzeby misji Apollo. Źródło: Wikipedia. Kolejny jest mit wielkiego produktu. Oznacza on, że po nauczeniu się podstaw danego języka programowanie, jest się od razu w stanie stworzyć bardzo złożony program, np. nowy system operacyjny, skomplikowaną aplikację na telefon, czy grę komputerową. W rzeczywistości takie produkty opierają się o tysiące godzin pracy wielu programistów. Dodatkowo, nie są one tworzone od podstaw, ale używając szeregu dostępnych narzędzi, bibliotek i innych rozwiązań. Celem pisania kodu, więc nie powinno być stworzenie od zera bardzo złożonej aplikacji, lecz odpowiednie użycie istniejących rozwiązań. Jednocześnie pisanie złożonego oprogramowania wymaga uzyskania niezbędnego doświadczenia. Mit wielkiego produktu wiąże się również z wymienionym w kolejnym akapicie mitem samotnego programisty. W popkulturze osoba, która potrafi programować spędza czas samotnie, gwałtownie wpisując kolejne linie kodu do komputera w ciemnym pokoju. W rzeczywistości jednak większość profesjonalnych programistów pracuje w zespołach, których członkowie pracują nad różnymi aspektami tego samego problemu. Pisanie programów często wymaga współpracy różnych osób, dlatego też umiejętność pracy w grupie jest coraz istotniejsza. Warto dodać, że współpraca nad pisaniem programów nie musi odbywać się w jednym pokoju czy budynku. Ze względu na charakter takiej pracy i możliwości technologiczne, wiele formalnych i nieformalnych grup pracuje zdalnie nad projektami. Wiele przykładów takich zachowań można znaleźć przyglądając się otwartemu oprogramowaniu (ang. open-source software) na platformie GitHub (np. https://github.com/trending/r). W poprzednim akapicie celowo użyłem stwierdzenia “osoba, która potrafi programować” zamiast “programista”. Jest to kolejny powszechny mit, że każda osoba która potrafi stworzyć program musi od razu zostać pełnoetatowym programistą. Pisanie programów jest narzędziem, które ma wspomóc twórcę w pewnym celu. Jednym z celów może być zostanie profesjonalnym deweloperem stron internetowych, aplikacji mobilnych, gier komputerowych, itd. Nie jest to jednak jedyny cel - programowanie może być, na przykład przydatnym narzędziem w analizie danych12. Umiejętności programistyczne są wykorzystywane przez ekonomistów, biologów, geografów i osób z wielu innych dziedzin. Dodatkowo, podstawowe aspekty programowania są bardzo cenne w zawodach, w których ważna jest częsta współpraca z programistami. Kolejny mitem jest mit programisty geniusza. W tym micie programują tylko osoby, która ma nadludzką pamięć oraz wyróżniającą wiedzę matematyczną. Oczywiście, takie cechy przydają się w programowaniu, ale nie są one wymagane do programowania. W programowaniu częściej od dobrej pamięci przydaje się umiejętność szybkiego znalezienia rozwiązania czy odpowiedzi na problem w internecie. Programista nie musi znać na pamięć setek różnych poleceń i funkcji, ważne że umie je zidentyfikować. Natomiast zamiast głębokiej wiedzy matematycznej do większości zadań programistycznych wystarczy podstawowa znajomość algebry. Z tym mitem wiąże się też inna kwestia - założenia że ten programista geniusz posiadł całą wiedzę programistyczną. Podobnie jak nauka języka obcego, nauka języka programowania wymaga dużo pracy i czasu. Dodatkowo, języki programowania czy techniki programowania zmieniają się znacznie częściej niż języki naturalne, dlatego też częścią programowania jest ciągłe uczenie się. Ostatni mit natomiast mówi o tym, że dla każdego problemu programistycznego istnieje tylko jedno najlepsze rozwiązanie. Jeden problem można zazwyczaj rozwiązać na dziesiątki różnych sposobów. Wynika to z tego, że wiele aspektów programowania opiera się o personalne preferencje, np. wybór danego języka programowania, używanych bibliotek, czy stylu pisania kodu. W efekcie zazwyczaj nie możliwe jest jednoznaczne określenie, które rozwiązanie jest lepsze, szczególnie jeżeli wiele rozwiązań ma podobną wydajność. Istnieje jednak kilka reguł, z którymi zgadza się większość programistów. Pierwsza z nich mówi, że wolny działający kod jest lepszy niż szybki niedziałający kod13. Kolejna opiera się o zasadę DRY (nie powtarzaj się, ang. Don’t Repeat Yourself), zalecającą unikanie różnego rodzaju powtórzeń wykonywanych przy programowaniu, np. używania tych samych fragmentów kodu w wielu miejscach. Ostatnia reguła mówi, żeby tworzyć pisać programy w sposób modularny, czyli taki w którym każda funkcja spełnia tylko jedno i nie więcej zadanie, a złożone funkcje składają się z szeregu prostych funkcji. 1.2 Języki programowania Głównym sposobem przekazywania instrukcji do komputera jest użycie języków programowania. Pozwalają one na precyzyjny zapis zadań, które następnie mają zostać wykonane przez komputer. Języki programowania składają się ze zbioru reguł syntaktycznych (składni) oraz semantyki. Składnia (forma) mówi o tym jakie symbole są dostępne w danym języku oraz jak te symbole mogą być łączone w większe struktury. Semantyka (treść) natomiast definiuje znaczenie poszczególnych symboli. W przeciwieństwie do języków naturalnych, języki programowania wymagają wysokiej precyzji. Mówiąc w języku naturalnym możemy popełnić jakiś błąd (np. gramatyczny czy składniowy) i nadal być łatwo zrozumianym przez otoczenie. Języki programowania nie akceptują takich błędów i nie są w stanie wykonać danego polecenia. Obecnie istnieją tysiące14 języków programowania i każdego roku powstają nowe. Nie ma wśród nich jednego najlepszego, uniwersalnego języka programowania i w najbliższej przyszłości ten stan się nie zmieni. Jest to związane z bardzo szerokim zastosowaniem programowania w wielu dziedzinach czy problemach, które mają od siebie zupełnie różne wymagania. Przykładowe wymagania mogą dotyczyć np. szybkości wykonywanych obliczeń, łatwości pisania kodu, stabilności języka programowania, czy celu obliczeń. Do tego dochodzą również rożne kwestie historyczne i społeczne, jak na przykład preferowanie danego języka programowania przez osoby w danej branży. Obecnie wśród najpopularniejszych języków programowania można wymienić takie języki jak Java, C, Python, C++, Visual Basic .NET, JavaScript, C#, PHP, SQL, Objective-C, język asemblera, Perl, czy R. Języki programowania można podzielić na wiele różnych grup w zależności od przyjętych kryteriów. Poniżej wyjaśnionych jest kilka możliwych podziałów języków programowania. Jednym z nich jest sposób wykonywania kodu - to czy kod w danym języku jest kompilowany czy też interpretowany. Kompilacja kodu (np. C czy Java) polega na jego tłumaczeniu do postaci języka maszynowego. W efekcie zapewnia to wysoką wydajność programu, ale za to kod jest ściśle powiązany z daną platformą sprzętową. Programowanie w językach kompilowanych jest zazwyczaj bardziej złożone i trudniejsze w nich jest odnajdywanie błędów (tzw. debugging). Interpretowane języki programowania, często również nazywane językami skryptowymi, (np. R czy Python) charakteryzuje to, że w momencie uruchomienia kod jest zamieniany na postać zrozumiałą dla komputera i od razu wykonywany. W efekcie można szybko zobaczyć efekt zmian. Wadą tego typu języków jest ich zmniejszona wydajność w porównany do języków kompilowanych. Innym powszechnym podziałem języków programowania jest ich rozróżnianie na podstawie poziomu. Tutaj można wyróżnić języki od niskiego poziomu do wysokiego poziomu. Na najniższym poziomie jest język maszynowy, czyli taki w którym zapis programu wyrażony jest w postaci liczb binarnych. Powyżej są umieszczony jest język asemblera, w którym program jest zapisany poprzez serię instrukcji. Na najwyższym poziomie stawia się języki, które są wspomagane przez kompilator albo interpreter. Języki programowania można też rozróżnić ze względu na paradygmat programowania. Definiuje on w jaki sposób w danym języku wykonywany jest przepływ sterowania czy też jak kod jest organizowany. Dwa podstawowe paradygmaty programowania to programowanie imperatywne i deklaratywne. Programowanie imperatywne (np. Fortran, C) opisuje proces wykonywania kodu jako sekwencję instrukcji zmieniających stan programu. Obejmuje ono inne paradygmaty, jak na przykład programowanie proceduralne czy obiektowe . Programowanie deklaratywne skupia się natomiast na warunkach jakie musi spełniać końcowe rozwiązanie, a nie na sekwencji kroków do jego stworzenia. W skład tej grupy wchodzi, między innymi, programowanie funkcyjne czy matematyczne. Niektóre języki mogą być zaklasyfikowane do kilku paradygmatów. Przykładowo R wspiera zarówno paradygmat funkcyjny, ale zawiera też możliwości programowania obiektowego. 1.3 R W tej książce wprowadzenie do programowania opiera się o język R (Rycina 1.2). Rycina 1.2: Logo języka programowania R. Wynika to z szeregu zalet tego języka: R jest bezpłatnym, otwartym oprogramowaniem, który można uruchomić na różnych systemach operacyjnych (Windows, Mac OS i Linux), zarówno na komputerach osobistych jak i na dużych klastrach obliczeniowych. W efekcie nie ma on finansowej bariery rozpoczęcia pracy, a kod napisany na jednym komputerze można również przenieść i uruchomić na innym sprzęcie. R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. Ten aspekt ułatwia szybsze zrozumienie działania tego języka. R posiada wiele wbudowanych narzędzi analizy i wizualizacji danych. Pozwala to na relatywnie szybkie osiąganie wymiernych efektów z korzystania z tego języka. R posiada tysiące dodatkowych rozszerzeń (zwanych pakietami) pozwalających na, między innymi, przetwarzanie różnorodnych danych, ich wizualizację, czy zaawansowane modelowanie. Oficjalnym portalem zawierającym dodatkowe pakiety R jest CRAN. R ma przyjazną społeczność użytkowników tego języka, zarówno online jak i spotykających się na żywo na tzw. meetupach. W celu ułatwienia pracy z R powstało również zintegrowane środowisko programistyczne RStudio, które wspomaga pisanie i analizę kodu w R. R został zaprojektowany jako narzędzie ułatwiające komunikację między różnymi językami programowania, głównie C oraz Fortran15. Obecnie R pozwala na łatwe łączenie kodu pochodzącego również z takich języków jak C++, Python, JavaScript, itd. R jest używany przez wiele małych firm, jak i wielkich korporacji, wliczając w to BBC, Facebook, Google, Microsoft, Mozilla, Netflix, T-Mobile, czy Uber16. Oczywiście, uniwersalny i idealny język nie istnieje: R jest językiem interpretowalnym, czyli wykonanie w nim komend nie wymaga kompilacji. W efekcie R nie jest najszybszym językiem programowania. Podobnie jak wiele innych języków, również R zawiera wiele niekonsekwencji, wynikających z wieloletniej ewolucji tego języka. W efekcie istnieje wiele specjalnych przypadków czy wyjątków, które warto znać (Burns 2012). Ta książka skupia się na prezentacji głównym konceptów programistycznych używając języka R. W sekcji 2.4 można znaleźć listę różnorodnych materiałów, książek, blogów, kursów, czy serwisów ułatwiających i wspomagających naukę R. Istnieje także wiele wprowadzających materiałów do nauki innych języków. Przykładowo, osoby zainteresowane nauką Pythona mogą skorzystać z istniejących książek (Gries, Campbell, and Montojo (2017) oraz Guzdial and Ericson (2016)), czy też kursów Software Carpentry oraz Python Course. W pracy programistycznej przydaje się również często znajomość linii komend. Tutaj również można użyć materiałów z kursu Software Carpentry lub książki The Unix Workbench (Kross 2017). 1.4 Zadania Pomyśl do czego jesteś w stanie wykorzystać programowanie w swoim życiu zawodowym lub prywatnym? Zastanów się nad mitami związanymi z programowaniem. Czy jesteś w stanie wskazać jakieś mity nie wymienione powyżej? Wybierz trzy języki programowania z listy wymienionej w tym rozdziale i poszukaj informacji o nich. Do czego są one stosowane? Jakie mają wady i zalety? Bibliografia "],
["ergosum.html", "2 Start R 2.1 Wyrażenia 2.2 Obiekty 2.3 IDE 2.4 Dodatkowe materiały 2.5 Styl 2.6 Zadania", " 2 Start R Wykonywanie kodu w języku interpretowalnym, jakim jest R, może odbywać się poprzez wpisanie polecenia w oknie konsoli (zwanej też terminalem) i jego uruchomienie17. Komendy są najpierw sprawdzanie pod kontekstem ich poprawności. Polega to na określeniu, np. czy podana funkcja lub inny obiekt istnieje, czy nie zostały użyte niedozwolone znaki, lub czy wszystkie nazwiasy czy cudzysłowia zostały zamknięte. Języki programowania są w tym aspekcie bardziej bezwzględne niż języki naturalne - nie potrafią one zrozumieć wyrażeń zawierających nawet niewielkie błędy takie jak, np. użycie dużej litery zamiast małej. 2.1 Wyrażenia Podstawowe działania arytmetyczne, dodawanie, odejmowane, mnożenie i dzielenie, są również często używane w wielu językach programowania. Dla każdej z tych operacji istnieje odpowiedni operator w R. Operatorem dodawania jest +. 2 + 2 #&gt; [1] 4 Operatorem odejmowania jest -. 1 - 3 #&gt; [1] -2 Operatorem mnożenia jest *. 5 * 5 #&gt; [1] 25 Operatorem mnożenia jest /. 42 / 5 #&gt; [1] 8.4 Wszystkie powyższe operacje można wykonać poprzez ich wpisanie w oknie konsoli R i naciśnięcie klawisza Enter. 2.2 Obiekty “Dwa slogany są pomocne w zrozumieniu obliczeń w R: 1. Wszystko co istnieje jest obiektem. 2. Wszystko co się dzieje jest wywołaniem funkcji.” — John Chambers Powyższy cytat sugeruje dwa najważniejsze elementy języka R: obiekty i funkcje. Zrozumienie w jaki sposób się je tworzy i zmienia będzie w związku z tym, konieczną wiedzą osób piszących w tym języku. 2.2.1 Operator przypisania Nadanie wartości do obiektu wykonuje się używając operatora przypisania18. R posiada trzy operatory przypisania, które mają niemal identyczne działanie19: =, &lt;-, -&gt;. Warto wybrać jeden z tych operatorów i konsekwentnie używać go pisząc kod. W tej książce jako główny operator przypisania będzie używany znak =. W poniższej linii stworzony jest nowy obiekt, o nazwie x, który zawiera wartość 7. x = 7 Można to sprawdzić wpisując nazwę tego obiektu. x #&gt; [1] 7 Operatory przypisania może również posłużyć do nadania wartości z jednego obiektu do drugiego. Poniżej nowy obiekt y przyjmuje wartość od obiektu x. y = x y #&gt; [1] 7 Język R przechowuje i przetwarza wszystkie obiekty w pamięci komputera (RAM). Wpływa to na zwiększoną wydajność i elastyczność obliczeń, ale jednocześnie powoduje to ograniczenie wielkości obiektów na jakich można pracować. Istnieje równocześnie szereg strategii jak postępować z większymi zbiorami danych, które nie mieszczą się w RAMie (???). 2.2.2 Działania na obiektach Każdy stworzony obiekt w R może być następnie używany do kolejnych operacji, a w efekcie też tworzenia nowych obiektów. W poniższych czterech przypadkach obiekt x został przetworzony używając operatorów dodawania, odejmowania, mnożenia oraz dzielenia, a nowe obiekty powstały jako wyniki tych obliczeń. z1 = x + 3 z1 #&gt; [1] 10 z2 = x - 5 z2 #&gt; [1] 2 z3 = x * 2 z3 #&gt; [1] 14 z4 = x / 4 z4 #&gt; [1] 1.75 Część języków programowania, np. C, wymaga zadeklarowania zmiennej przed jej użyciem poprzez podanie jej nazwy i typu. Wybór typu zmiennej w tych językach może mieć widoczne konsekwencje. Przykładowo, jeżeli obiekt x zostanie zadeklarowany jako liczba całkowita (integer), wynikiem dzielenia x / 4 będzie 1 zamiast 1.75. Działania na obiektach mogą też się odbywać używając innych operatorów oraz różnorodnych funkcji. Przykładowo, operator zapisywany jako %% to modulo, którego celem jest określanie reszty z dzielenia. z5 = x %% 3 z5 #&gt; [1] 1 Operator %/% przestawia dzielenie całkowite. z6 = x %/% 3 z6 #&gt; [1] 2 Operator ^ natomiast wykonuje podniesienie wartości obiektu do wybranej potęgi. z7 = x^2 z7 #&gt; [1] 49 Odwrotnością potęgowania jest pierwiastkowanie. W R nie istnieje do tego celu specjalny operator, ale zawiera on specjalną funkcję sqrt(). z8 = sqrt(x) z8 #&gt; [1] 2.65 Często używaną funkcją w R jest też c(). Ta funkcja łączy krótsze wektory w dłuższe wektory. z9 = c(z2, z4, z8) z9 #&gt; [1] 2.00 1.75 2.65 Operatory użyte w tym rozdziale, np. +, *, ^, %% to też są funkcje, ale zapisane w skrótowej formie ułatwiającej z nimi pracę. Te operatory można też użyć jako normalne funkcje poprzez dodanie znaku zwanego grawisem - &quot;&quot;, np.2 + 2można też zapisać jako`+`(2, 2)`. 2.3 IDE RStudio to zintegrowane środowisko programistyczne (ang. Integrated Development Environment, IDE) dla R. Zawiera ono bardzo wiele użytecznych funkcjonalności, tj. wbudowany edytor, podświetlanie składni, automatyczne uzupełnianie kodu i wiele innych. RStudio to nie jest to samo co R. R jest językiem programowania, podczas gdy RStudio to aplikacja ułatwiająca pisanie kodu. Możliwe jest używanie R bez RStudio, ale RStudio bez R nie pełni już swojej roli. Częstą analogią jest porównanie samochodowe, w którym R jest opisywany jako silnik a RStudio jako deska rozdzielcza. Rycina 2.1: Okno RStudio z opisaną funkcjonalnością każdej z jego części. Typowa praca w RStudio często polega na wpisywaniu poleceń do pliku tekstowego widocznego w części skryptowej (Rycina 2.1), a następnie wykonywaniu kolejnych linii kodu w oknie konsoli używając skrótu klawiaturowego CTRL+ENTER (więcej przydatnych skrótów klawiaturowych można znaleźć w tabeli 2.1). Efektem wykonywania funkcji może być powstanie nowych obiektów, które można zobaczyć w oknie “środowiska” lub też wyświetlenie grafik, które można zobaczyć w oknie “wykresu”. Dobrą praktyką pracy z R w RStudio jest też używanie projektów RStudio (ang. RStudio projects). Projekt jest to folder zawierający wszystkie skrypty i pozostałe pliki powiązane z jakimś zadaniem (np. analizą danych, czy stworzeniem nowego pakietu R). Ułatwia on przenoszenie kodu pomiędzy różnymi komputerami, a także daje dostęp do szeregu dodatkowych możliwości w RStudio. Aby stworzyć pierwszy projekt RStudio, należy: Kliknąć File -&gt; New Project. Wybrać New Directory. Wybrać New Project. Podać nazwę nowego projektu, np. “programowanie1” oraz wybrać miejsce na dysku, gdzie ma się nowy projekt znajdować. Jeżeli możliwe, to wybrać też opcję Create a git repository. Kliknąć Create Project. Tabela 2.1: Podstawowe skróty klawiaturowe w RStudio Skrót Wyjaśnienie Ctrl+Enter wykonuje wybraną linię kodu w skrypcie R Tab uzupełnia kod (podaje pasujące możliwości) F1 wyświetla plik pomocy dla wybranej funkcji Ctrl+Shift+C ustawia wybrane linie jako komentarz/odkomentuj fragment kodu strzałka Góra/Dół (w oknie konsoli) wybiera wcześniej wpisany kod Esc przerywa niedokończoną operację Shift+Alt+K wyświetla listę skrótów klawiaturowych 2.4 Dodatkowe materiały Polskie książki: http://www.biecek.pl/R/ (Biecek 2014) http://www.gagolewski.com/publications/programowanier/ (Gagolewski 2016) https://helion.pl/ksiazki/jezyk-r-kompletny-zestaw-narzedzi-dla-analitykow-danych-hadley-wickham-garrett-grolemund,jezrko.htm#format/d (Wickham and Grolemund 2016) https://helion.pl/ksiazki/wydajne-programowanie-w-r-praktyczny-przewodnik-po-lepszym-programowaniu-gillespie-colin-lovelace-robin,a_0491.htm#format/d (Gillespie and Lovelace 2016) https://bookdown.org/nowosad/Geostatystyka/ (Nowosad 2019) http://www.enwo.pl/przetwarzanie/index.html (???) Angielskie książki: https://rstudio-education.github.io/hopr/ (Grolemund 2014) https://r4ds.had.co.nz/ (Wickham and Grolemund 2016) https://csgillespie.github.io/efficientR/ (Gillespie and Lovelace 2016) https://adv-r.hadley.nz (Wickham 2014) https://geocompr.robinlovelace.net/ (Lovelace, Nowosad, and Meunchow 2019) Blogi: Agregator blogów dotyczących R - https://www.r-bloggers.com/ Polski blog opisujący kwestie analizy danych w R, wizualizacji, oraz edukacji - http://smarterpoland.pl/ Polski blog pokazujący zastosowanie R do analizy i wizualizacji danych - http://szychtawdanych.pl/ Kursy: Lista kursów dotyczących R na platformie DataCamp (część z nich jest dostępna bezpłatnie) - https://www.datacamp.com/search?q=r Polskie tłumaczenie pakietu R służącego do nauki tego języka - https://github.com/dabrze/swirl Lista kursów dotyczących R na platformie Coursera - https://www.coursera.org/courses?query=r Lista kursów dotyczących R na platformie edX - https://www.edx.org/course?search_query=r Pisanie kodu oraz jego dokumentowanie opiera się w znacznym stopniu na wprowadzaniu znaków na klawiaturze do komputera. Warto jest więc aby robić to w sposób efektywny, czyli taki w którym używamy wszystkich palców u rąk a nasz wzrok nie jest skupiony na klawiaturze. Takie pisanie nazwa się pisaniem bezwzrokowym (ang. touch typing). Pisanie bezwzrokowe ma szereg reguł, które wymagają przestawienia się ze starych nawyków oraz pewnego treningu. Na szczęście istnieje wiele internetowych zasobów, które ułatwiają naukę takiego pisania, między innymi strona TypingClub. Serwisy internetowe: Wyszukiwarki internetowe są nieocenionym narzędziem wspierającym programowanie - https://rseek.org/, https://duckduckgo.com/, https://www.google.com/, https://www.bing.com/, itd. Serwis społecznościowy zawierający pytania i odpowiedzi dotyczące różnych języków programowania w tym R - https://stackoverflow.com. Pytania dotyczące R można znaleźć pod adresem https://stackoverflow.com/questions/tagged/r. Przed zadaniem nowego pytania warto wyszukać czy nie zostało ono zadane wcześniej a następnie przeczytać wątek dotyczący tworzenia nowych pytań - https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example Twitter jest miejscem, w którym można znaleźć zarówno nowości z języka R, jak również odpowiedzi na pytania dotyczące tego języka - https://twitter.com/. Kwestie związane z R są opatrzone hasztagiem #rstats, natomiast kwestie przestrzenne w R są opisywane hasztagami #rspatial oraz #geocompr Elektroniczny biuletyn R Weekly zbierający co tydzień nowości związane z r - https://rweekly.org/ Lista emailowa dotycząca R - https://stat.ethz.ch/mailman/listinfo/r-help Lista emailowa dotycząca kwestii przestrzennych w R - https://stat.ethz.ch/mailman/listinfo/r-sig-geo Forum dotyczące kwestii R i RStudio - https://community.rstudio.com/ Meetups (spotkania początkujących i zaawansowanych użytkowników R): Poznań - https://www.meetup.com/pl-PL/Poznan-R-User-Group-PAZUR/ Warszawa - https://www.meetup.com/pl-PL/Spotkania-Entuzjastow-R-Warsaw-R-Users-Group-Meetup/ Wrocław - https://www.meetup.com/Wroclaw-R-Users-Group/ Kraków - https://www.meetup.com/erkakrakow/ Trójmiasto - https://www.meetup.com/Trojmiejska-Grupa-Entuzjastow-R/ 2.5 Styl Poniżej znajdują się podstawowe porady dotyczące stylu pisania kodu. Więcej wskazówek można znaleźć na w poradniku stylu RStudio oraz poradniku stylu Google. Oba te poradniki nie są identyczne i czasami zawierają sprzeczne porady. Najważniejsze jest, aby wybrać jeden odpowiadający piszącemu kod styl i się go konsekwentnie trzymać. 2.5.1 Nazwy obiektów Istnieje wiele konwencji nazywania obiektów20. Najczęściej używaną konwencją w R jest tzw. “snake case”. Polega ona na tworzeniu nazw obiektów składających się ze słów połączonych znakiem podkreślenia (_). Ważne, żeby nazwy obiektów ułatwiały zrozumienie ich zawartości. # obiekt bok_a bok_b # funkcja pole_prostokata Nazwa obiektu nie może zaczynać się od liczby, ani nie może używać specjalnych symboli, tj. ^, !, $, @, +, -, /, czy *. Dodatkowo należy uważać, żeby nowa nazwa obiektu nie nadpisała istniejącego obiektu lub funkcji. Nie powinno nazywać się obiektów tak jak istniejące funkcje, np. c, t, table, itd. 2.5.2 Odstępy Odstępy pełnią bardzo ważną funkcję przy pisaniu kodu, podobnie jak odstępy przy pisaniu tekstu. Wyobraź sobie czytanie powieści, w której nie ma żadnych odstępów między słowami czy rozdziałami. Często mówi się, że “kod musi oddychać” - odstępy zwiększają czytelność kodu i pozwalają na jego szybsze zrozumienie oraz ułatwiają naprawienie występujących błędów. Odstępy można uzyskać poprzez użycie spacji. Spacje powinny być użyte po przecinkach, ale nigdy przed nimi. Dodatkowo, większość operatorów (np. =, +, -, ==) powinna być otoczona przez spacje. # Zalecane srednia = mean(wartosc, na.rm = TRUE) pole = bok_a * bok_b # Niewskazane srednia=mean ( wartosc,na.rm=TRUE ) pole=bok_a*bok_b Spacje należy również używać do tworzenia wcięć - każde z nich powinno się składać z dwóch spacji. # Zalecane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } # Niewskazane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Warto także ograniczać długość każdej linii kodu, żeby nie przekraczała ona ok. 80 znaków. Dzięki temu możliwe jest szybkie przeczytanie kodu czy też jego wydrukowanie. # Zalecane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, b = &quot;drugi argument&quot;, c = &quot;trzeci argument&quot;) # Niewskazane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, &quot;drugi argument&quot;, &quot;trzeci argument&quot;) 2.5.3 Komentarze Komentarze służą do wyjaśniania istotnych elementów kodu. Do komentowania w języku R służy operator #. # Mój komentarz 2.5.4 Nazwy plików Nazwy plików powinny spełniać trzy wymagania - być łatwe (i) do odczytania przez komputer, (ii) do odczytania przez człowieka, (iii) do posortowania. Nazwy plików nie powinny zawierać spacji, znaków specjalnych (np. !, %, *), znaków diakrytycznych (np. ć, Ł, ź). Warto też aby nazwy plików składały się tylko z małych liter. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane Obliczanie Średniej.R pomiaryTemperatury!.csv Podobnie jak nazwy obiektów, również nazwy plików powinny opisywać ich zawartość. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane kod.R dane.csv Dodatkowo wskazane jest dodanie wartości numerycznych przed nazwą pliku, jeżeli pliki mają jakąś kolejność. # Zalecane 01_przygotowanie-danych.R 02_obliczanie-sredniej.R # Niewskazane przygotowanie-danych.R obliczanie-sredniej.R Kodowanie znaków (ang. character encodings) jest to sposób sposób prezentacji znaków. Istnieje szereg różnych standardów kodowania znaków. Standard ASCII przyporządkowuje liczbom z zakresu 0−127 litery alfabetu angielskiego, cyfry, znaki przestankowe i inne symbole oraz polecenia. Firma Microsoft stworzyła dodatkowo cały szereg standardów dla różnych języków. Przykładowo do obsługi języków środkowoeuropejskich istnieje wersja oznaczona jako Windows-1250 (lub CP1250). Alternatywnie do systemu Microsoftu powstał też zbiór standardów ISO, przykładowo ISO-8859-2 dla języków środkowoeuropejskich. W efekcie oznacza to, że otworzenie tekstu z innego komputera, na komputerze z “polskim” kodowaniem znaków może spowodować pojawienie się tzw. “krzaczków”. Aby uniknąć takiej sytuacji powstał system kodowania UTF-8, który zawiera w sobie ponad milion różnych znaków. Jest on obecnie zalecanym standardem na całym świecie. 2.5.5 Daty Istnieje wiele sposobów zapisu dat21, co może powodować różnorodne problemy przy programowaniu oraz analizie danych. Z ratunkiem w tej kwestii przychodzi norma ISO 8601, która definiuje daty kalendarzowe jako YYYY-MM-DD, czyli ROK-MIESIĄC-DZIEŃ. # Zalecane 2019-06-02 # Niewskazane wszelkie inne 2.6 Zadania Rozwiązując poniższe zadania oraz pozostałe zadania z tej książki staraj się stosować do stylu podanego w sekcji 2.5. Przejrzyj poniższą listę poleceń. Spróbuj określić uzyskane wyniki bez wykonywania kodu w R. x = 7 y = -2 x + 3 y - 5 x * 2 y / 4 x %% 3 x %/% 3 y ^ 2 y ^ x Jedziesz na krótkie wakacje i planujesz na nie zabrać 500 EUR. Aktualny kurs kupna EUR wynosi 4,31. Ile PLN musisz wydać? Wylicz to w R. Masz trapez o długości podstaw a = 5 i b = 6 oraz wysokości h = 3. Stwórz nowy obiekt pole_trapezu, który zawiera obliczone pole tego trapezu. Wraz z grupą znajomych planujesz zamówić pizzę z dostawą i macie na to przeznaczonych 50 PLN. Pizza o średnicy 30 cm kosztuje 23,5 PLN, a pizza o średniczy 50 cm kosztuje 50 PLN. Wylicz w R, czy bardziej opłaca się kupno dwóch małych pizz czy jednej dużej. Bibliografia "],
["funkcje.html", "3 Funkcje 3.1 Struktura funkcji 3.2 Wbudowane funkcje 3.3 Kolejność wykonywania funkcji 3.4 Dokumentacja funkcji 3.5 Pakiety 3.6 Algorytmy 3.7 Tworzenie skryptów 3.8 Budowanie funkcji 3.9 Komunikaty 3.10 Zadania", " 3 Funkcje Funkcje to programy, który przyjmują pewne argumenty, przetwarzają je i zwracają jakiś wynik. Są one zbudowane z dostępnych elementów języka programowania jak i też z innych dostępnych funkcji. Funkcje mogą służyć do wielu celów, od prostych odliczeń arytmetycznych, poprzez przetwarzanie tekstu, tworzenie wykresów i map, aż do bardziej złożonych i specjalistycznych procedur. Ich celem jest ułatwienie pracy programistycznej i zwiększenie czytelności kodu. Zamiast wielokrotnie powtarzać te same linie kodu, możliwe jest napisanie funkcji raz, a następnie użycie jej wiele razy. 3.1 Struktura funkcji Funkcje są reprezentowane w R jako specjalne obiekty, które można uruchomić poprzez dodanie do ich nazwy nawiasów okrągłych. Przykładowo, funkcja mean() wylicza średnią. Może ona przyjąć kilka różnych argumentów, czyli pewnych obiektów lub parametrów wejściowych. W poniższym przykładzie do funkcji mean() zostały podane dwa argumenty. Pierwszy argument nazywa się x i przyjmuje on wektor numeryczny economics$pop, drugi argument nazywa się na.rm i został on ustalony na TRUE. W efekcie działania funkcji otrzymano wynik - 246348.9 - który jest średnią wartością w zadanym wektorze. 3.2 Wbudowane funkcje R posiada wiele wbudowanych funkcji, które znacznie ułatwiają wykonywanie bardziej złożonych operacji. Pierwsze z funkcji, w tym c() zostały już poznane w sekcji ??. Ta funkcja pozwala na łączenie kolejnych obiektów rozdzielonych przecinkami. Poniższy obiekt, x jest w efekcie wektorem zawierającym trzy wartości 8.2, 10.3 oraz 12.0. x = c(8.2, 10.3, 12.0) x #&gt; [1] 8.2 10.3 12.0 Wyliczenie średniej z tych trzech wartości wymaga ich zsumowania, a następnie podzielenia uzyskanej wartości przez liczbę wartości. (8.2 + 10.3 + 12.0) / 3 #&gt; [1] 10.2 W przypadku jednak, gdy chcemy dodać czwartą, piątą, itd. wartość należy zmieniać kod w co najmniej dwóch miejscach. Konieczne jest dodanie nowej wartości do zsumowania, a następnie zmianę wartości określającej liczbę elementów. Zamiast tych dwóch operacji, można wykonać tylko jedną zmianę w obiekcie x, a następnie przetworzyć go używając funkcji wbudowanych w R - sum() oraz length(). Pierwsza z nich sumuje wartości z wektora, druga natomiast zwraca liczbę elementów w wektorze. sum(x) / length(x) #&gt; [1] 10.2 Powyższy kod można też dalej uprościć, poprzez użycie wbudowanej w R funkcji do liczenia średniej - mean(). mean(x) #&gt; [1] 10.2 Jej użycie powoduje, że wystarczy wykonać tylko jedną zmianę w obiekcie x, aby uzyskać poprawny wynik, a dodatkowo napisanie tego obliczenia wymaga napisania znacznie krótszego kodu. Funkcje można używać w celu wyświetlenia oczekiwanego rezultatu, ale także, aby na podstawie wyniku funkcji tworzyć nowe obiekty, takie jak y poniżej. y = mean(x) y #&gt; [1] 10.2 3.3 Kolejność wykonywania funkcji Wykonywanie funkcji w R odbywa się linia po linii, od góry do dołu. a = 4 b = 5 a2 = a^2 b2 = b^2 R pozwala na dwa podstawowe sposoby łączenia działania wielu funkcji22. Pierwszy z nich polega na tworzeniu pośrednich obiektow jako wyników działania pojedynczych funkcji. suma_a2b2 = sum(a2, b2) przekatna = sqrt(suma_a2b2) przekatna #&gt; [1] 6.4 Drugi sposób opiera się o zagnieżdzanie funkcji. W tej sytuacji najpierw wykonywana jest funkcja w środku, na następnie kolejne funkcje coraz bliżej brzegu. przekatna = sqrt(sum(a2, b2)) przekatna #&gt; [1] 6.4 3.4 Dokumentacja funkcji Każda wbudowana funkcja w R posiada swoją dokumentację23. Można ją wyświetlić poprzez dodanie znaku zapytania przed nazwą funkcji, a następnie wykonanie tej linii kodu. ?mean Alternatywnie, w RStudio możliwe jest użycie skrótu F1 gdy kursor znajduje się na nazwie funkcji. Dokumentacja każdej funkcji, zwana inaczej plikiem pomocy, ma zazwyczaj podobną strukturę. W lewym górnym rogu znajduje się nazwa funkcji (mean) oraz nazwa pakietu z którego dana funkcja pochodzi (base). Poniżej znajduje się tytuł funkcji oraz jej krótki opis. Kolejnym elementem jest budowa funkcji (Usage), która skrótowo opisuje z jakich argumentów składa się dana funkcja. Np. funkcja mean() przyjmuje argument x, trim, oraz na.rm. Dla argumentów trim oraz na.rm są także ustalone ich domyślne wartości. Dodatkowo, widoczny jest argument w postaci wielokropka (...). Argumenty funkcji są również wypisane oraz skrótowo wyjaśnione. Przykładowo, x musi być obiektem R o typie numerycznym (który łączy typ liczb całkowitych i zmiennoprzecinkowych), logicznym, date, date-time, lub time interval. Część Value (lub Details) opisuje szczegóły wykonywanej funkcji. Inne możliwe elementy to np. References odnoszący się do artykułu czy książki opisującej daną funkcję lub metodę, czy też See also zawierający odnośniki do innych, podobnych funkcji. Jeden z najważniejszych elementów pliku pomocy znajduje się na samym końcu - są to przykłady (Examples). Jeżeli nie jesteśmy pewni jak dana funkcja działa warto zacząć od skopiowania przykładów a następnie ich wykonania. Czytanie dokumentacji wymaga pewnej wprawy i doświadczenia. Nie bój się używać innych źródeł pomocy (zobacz sekcję 2.4), jeżli potrzebujesz zrozumieć działanie danej funkcji. 3.5 Pakiety Pakiet to zorganizowany zbiór funkcji, który rozszerza możliwości R. Pakiety oprócz kodu zawierają szereg dodatkowych istotnych elementów, takich jak: Informacja o wersji pakietu, jego twórcach, zależnościach, czy licencji Dokumentacja Przykładowe dane Testy kodu Pakiety R mogą być przechowywane i instalowane z wielu miejsc w internecie. Istnieje jednak jedno centralne repozytorium (CRAN, ang. the Comprehensive R Archive Network), które zawiera oficjalne wersje pakietów R. Wersje deweloperskie (rozwojowe) często można znaleźć na platformie GitHub. Do instalacji pakietu w R z repozytorium CRAN służy wbudowana funkcja install.packages(), np: install.packages(&quot;stringr&quot;) #instalacja pakietu stringr Zainstalowanie pakietu w R z platformy GitHub jest możliwe używając, np. funkcji install_github() z pakietu remotes. # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;tidyverse/stringr&quot;) W przypadku instalacji pakietu w R z platformy GitHub należy podać nazwę użytkownika lub organizacji, która tworzy ten pakiet (np. powyżej tidyverse) oraz nazwę pakietu (np. powyżej stringr) oddzielone znakiem /. Podobnie jak instalowanie programów na komputerze - zainstalowanie pakietu odbywa się tylko jeden raz. Istnieją dwa główne formy, w których rozpowszechniane są pakiety R - postać źródłowa (ang. source packages) i postać binarna (ang. binary packages). Postać źródłowa zawiera kod źródłowy pakietu, który musi zostać następnie skompilowany na komputerze użytkownika. Skompilowanie pakietu na podstawie kodu źródłowego może wymagać posiadania odpowiednich bibliotek na komputerze, np. Rtools dla systemu Windows czy też narzędzia Xcode dla Mac OS. Dodatkowo, instalacja w ten sposób zabiera więcej czasu. Postać binarna została już wcześniej skompilowana na zewnętrznym komputerze (np. w repozytorium CRAN) Jest ona dostępna dla systemów Windows i Mac OS. Niestety, nie wszystkie pakiety (lub ich wersje) posiadają postać binarną i wymagana jest ich kompilacja. Użycie wybranego pakietu wymaga dołączenia go do R za pomocą funkcji library(). Dołączenie wybranych pakietów do R robimy po każdym uruchomieniu R. library(stringr) W przypadku, gdy chcemy użyć zewnętrznej funkcji, ale nie dołączyliśmy odpowiedniego pakietu, pojawi się błąd o treści could not find function &quot;nazwa_funkcji&quot;. str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; Error in str_sub(&quot;chronologia&quot;, start = 1, end = 6) : #&gt; could not find function &quot;str_sub&quot; Istnieją dwa możliwe rozwiązania powyższego problemu. Po pierwsze możliwe jest dołączenie pakietu poprzez library(stringr). Po drugie można bezpośrednio zdefiniować z jakiego pakietu pochodzi konkretna funkcja używając nazwy pakietu i operatora ::. stringr::str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; [1] &quot;chrono&quot; Operator :: może być też pomocny w przypadku, gdy kilka pakietów ma funkcję o tej samej nazwie. Wówczas, aby kod został poprawnie wykonany, warto podać nie tylko nazwę funkcji ale też nazwę pakietu z jakiego ona pochodzi. 3.6 Algorytmy Algorytm to zbiór kroków powadzących do uzyskania określonego celu. Algorytmy można porównać do przepisu kucharskiego, w którym opisany jest szereg czynności aby uzyskać konkretną potrawę. Podobnie jak w przepisie kucharskim, algorytmy wymagają posiadania odpowiednich składników - danych wejściowych w o pewnej strukturze. Tworzenie nowych algorytmów często zaczyna się od narysowania schematu procedury działania lub też pseudokodu. Kolejnym krokiem jest zapisanie tego algorytmu w wybranym języku lub językach programowania24 w formie skryptu (sekcja 3.7) lub funkcji (sekcja 3.8). 3.7 Tworzenie skryptów Skrypt w R to plik testowy z rozszerzeniem .R, który zawiera szereg linii kodu w celu uzyskania konkretnego efektu. Może on zawierać zaledwie kilka jak i setki linii kodu w zależności od złożoności postawionego problemu. Zobaczmy jak wyglądają skrypty na prostym przykładzie - przeliczania wartości ze skali Fahrenheita na skalę Celsjusza. Otrzymaliśmy informację, że w “mieście A” temperatura w stopniach Fahrenheita wynosi 75. miasto_a = 75 Pierwszym naszym krokiem powinno być dowiedzenie się jaka jest relacja pomiędzy skalą Fahrenheita na skalą Celsjusza. \\[T_{Celsjusz} = \\frac{T_{Fahrenheit} - 32}{1.8}\\] Następnie powyższy wzór można przepisać do postaci kodu w języku R oraz podstawić do niego wartość temperatury w stopniach Fahrenheita w mieście A. Ostatnim etapem jest wyświetlenie uzyskanego wyniku - temperatura w mieście A wynosi ok. 24 stopnie Celsjusza. miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Powyższe kroki można również zapisać do pliku tekstowego. # plik przeliczanie-temp.R miasto_a = 75 miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c Co można zrobić jeżeli mamy więcej podobnych pomiarów, które chcemy wykonać? Najprostszą opcją jest użycie kopiuj/wklej i powielenie tego samego kodu, a później naniesienie małych zmian, np. nazw obiektów. miasto_a = 75 miasto_b = 110 miasto_c = 0 miasto_a_c = (miasto_a - 32) / 1.8 miasto_b_c = (miasto_b - 32) / 1.8 miasto_c_c = (miasto_c - 32) / 1.8 Powyższe podejście jest poprawne, ale ma ono kilka wad: Łatwo jest o popełnie jakiegoś prostego błędu lub literówki podczas adaptacji kodu (np. można zapomnieć zmienić nazwę jakiejś zmiennej). Jeżeli obliczenia zajmują więcej niż kilka linii kodu - wówczas kopiowanie go znacznie powiększa tworzony skrypt i utrudnia jego czytelność. Poprawienie kodu w przypadku zauważenia błędu w procedurze obliczeniowej jest czasochłonne. To podejście jest też niezgodne z jedną z najważniejszych reguł w programowaniu - regułą DRY (Nie powtarzaj się, ang. Don’t Repeat Yourself). Zamiast tworzenia skryptu w oparciu o kopiuj/wklej lepiej pomyśleć nad zbudowaniem odpowiedniej funkcji25. 3.8 Budowanie funkcji Funkcje pozwalają na automatyzację często używanych obliczeń. Formalnie funkcje składają się z trzech elementów: listy argumentów (ang. formals), ciała funkcji (ang. body) oraz środowiska (ang. environment). Pierwsze dwa elementy ustala twórca funkcji, natomiast środowisko jest określane na podstawie tego, gdzie dana funkcja została zdefiniowana. Dodatkowo każda funkcja ma swoją nazwę. moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Lista argumentów wymienia obiekty wejściowe funkcji. formals(moja_funkcja) #&gt; $x #&gt; #&gt; #&gt; $y #&gt; #&gt; #&gt; $z Ciało zawiera kod danej funkcji. body(moja_funkcja) #&gt; { #&gt; pod = y/z #&gt; wynik = x * pod #&gt; wynik #&gt; } Środowisko określa, gdzie dana funkcja jest zlokalizowana. environment(moja_funkcja) #&gt; &lt;environment: R_GlobalEnv&gt; Przykładowa funkcja odpowiadająca problemowi z poprzedniej sekcji może wyglądać w poniższy sposób: konwersja_temp = function(temperatura_f){ (temperatura_f - 32) / 1.8 } Nowa funkcja nazywa się konwersja_temp() oraz posiada tylko jeden argument temperatura_f. Ciało funkcji zawiera natomiast wzór potrzebny do obliczeń przepisany do R. Ważne jest to, że obiekt użyty wewnątrz funkcji (temperatura_f) jest taki sam jak wejściowy argument. Po stworzeniu funkcji warto sprawdzić czy jej działanie odpowiada naszym oczekiwaniom. konwersja_temp(75) #&gt; [1] 23.9 konwersja_temp(110) #&gt; [1] 43.3 konwersja_temp(0) #&gt; [1] -17.8 konwersja_temp(c(0, 75, 110)) #&gt; [1] -17.8 23.9 43.3 3.9 Komunikaty Oprócz wyniku danej operacji R może wyświetlić kilka rodzajów komunikatów. Trzy podstawowe z nich to: Błędy (ang. errors) Ostrzeżenia (ang. warnings) Wiadomości (ang. messages) Błedy oznaczają, że wykonanie danej funkcji nie może być kontynuowane i przerwane jest jej działanie. Przykładowo, w poniższym kodzie podjęta została próba wyliczenia logarytmu naturalnego z tekstu &quot;abecadło&quot;. Takie obliczenie nie jest możliwe, w efekcie pojawił się komunikat błędu a kod nie został wykonany. log(&quot;abecadło&quot;) #&gt; Error in log(&quot;abecadło&quot;): non-numeric argument to mathematical function Ostrzeżenia zazwyczaj występują kiedy nastąpił jakiś problem z wykonaniem funkcji, ale jej działanie mogło być dokończone. Często sugerują one użytkownikowi, aby dokładnie przyjrzał się wykonywanej funkcji i upewnił się czy na pewno ustala on odpowiednie wartości dla argumentów funkcji. Poniżej została podjęta próba wyliczenia logarytmu naturalnego dla wartości ujemnej. W efekcie pojawił się komunikat błędu, który mówi, że w wyniku zostały stworzone wartości NaN (ang. Not a Number). log(-1) #&gt; Warning in log(-1): NaNs produced #&gt; [1] NaN Wiadomości pojawiają się, aby przekazać użytkownikowi jakąś informację. inna_funkcja(15) #&gt; Chcę ciebie o czymś poinformować. #&gt; [1] 2.71 Opis tworzenia komunikatów błędu, ostrzeżenia i wiadomości można znaleźć w rozdziale 10. 3.10 Zadania Zobacz jak wygląda plik pomocy funkcji mean(). Wykonaj zawarte w nim przykłady. Co przedstawiają uzyskane wyniki? Zainstaluj pakiet magrittr. Spróbuj użyć operatora %&gt;% z tego pakietu na przykładzie z sekcji 3.3 dotyczącym wyliczania przekątnej prostokąta. Stwórz nowy plik skryptu R nazywający się 01_zadania-funkcje.R. W tym pliku, stwórz nowy obiekt poznan, który przyjmuje wartość 8.4, napisz przeliczenie wartości tego obiektu ze stopnii Celsjusza na stopnie Fahrenheita, a następnie wyświetl uzyskany wynik. Uwaga: pamiętaj o ustawieniu odpowiedniego kodowania znaków dla tego nowego pliku. Stwórz nową funkcję, która służy do przeliczania wartości ze stopnii Celsjusza na stopnie Fahrenheita. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z mil lądowych na kilometry. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z metrów na sekundę na kilometry na godzinę. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do przeliczania wartości z metrów na sekundę na mile lądowe na godzinę. Jak nazwiesz taką funkcję? Stwórz nową funkcję, która służy do wyliczania pola trapezu na podstawie długości podstaw oraz wysokości trapezu. Jak nazwiesz taką funkcję? Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean() Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean(&quot;abecadło&quot;) Wykonaj poniższy kod. Co oznacza uzyskany wynik? mean(sqrt()) Wykonaj poniższy kod. Co oznacza uzyskany wynik? str_length(&quot;abecadło&quot;) Wykonaj poniższy kod. Co oznacza uzyskany wynik? u = 2 z = 3 + v v = 7 Istnieje też szereg dodatkowych sposobów, wśród których najpopularniejszy polega na używaniu operatora %&gt;% z pakietu magrittr (Bache and Wickham 2014).↩ Niektóre zbiory danych również posiadają swoje pliki pomocy.↩ Łączenie różnych języków programowania jest wyjaśnione w rozdziale 14↩ Grolemund and Wickham (2016) radzą tworzyć nowe funkcje, gdy ten sam kod potwarza się co najmniej trzy razy.↩ "],
["warunki.html", "4 Wyrażenia warunkowe 4.1 Warunki 4.2 Warunki zagnieżdzone 4.3 Operatory porównania 4.4 Wyrażenia warunkowe w funkcjach 4.5 Zadania", " 4 Wyrażenia warunkowe Języki programowania opierają się o dwa podstawowe narzędzia pozwalające na sterowanie przepływem operacji. Są to wyrażenia warunkowe oraz pętle. Wyrażenia warunkowe są głównym tematem tego rozdziału, natomiast pętle oraz ich alternatywy są omówione w rozdziale 8. Celem wyrażeń warunkowych jest wykonywanie różnego zadania w zależności od danych wejściowych. 4.1 Warunki Wyrażenie if opiera się o spełnienie (lub niespełnienie) danego warunku. Jeżeli dany warunek jest spełniony, kod wewnątrz wyrażenia if() jest wykonywany. if (warunek){ jeżeli warunek spełniony to wykonaj operację } Wyrażenie if oczekuje, że warunek jest wektorem logicznym o długości jeden, tj. takim który przyjmuje wartość TRUE lub FALSE. Istnieje szereg sposób uzyskania wektora logicznego w R, jednym z nich jest zastosowanie porównania wartości. W poniższym przykładzie wyrażenie if() sprawdza czy wartość obiektu temperatura jest wyższa niż 0. W przypadku, gdy ten warunek jest spełniony (czyli jest TRUE), wyświetlany jest tekst &quot;Dodatnia&quot;. temperatura = 5.4 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } #&gt; [1] &quot;Dodatnia&quot; W przeciwnym razie, gdy warunek nie jest spełniony (czyli ma wartość FALSE), kod wewnątrz warunku nie jest wykonywany. temperatura = -11 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } Warunek if można też tworzyć w uproszczonej formie: if (warunek) spelniony else niespelniony 4.2 Warunki zagnieżdzone Działanie wyrażenia if może być połączone z dodatkowymi wyrażeniami else if oraz else. Te dwa wyrażenia wymagają najpierw wywołania wyrażenia if(). Jeżeli warunek w wyrażeniu if() jest równy TRUE to wykonywany jest kod w nim zawarty, a następnie obliczenie jest kończone. W przypadku, gdy wyrażenie if() otrzyma wartość FALSE, to kod w nim zawarty nie jest wykonywany, a następuje przejście do kolejnego wyrażenia, np. else if() w poniższym przypadku. temperatura = 8.8 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } else if (temperatura &lt; 0) { &quot;Ujemna&quot; } else { &quot;Zero&quot; } #&gt; [1] &quot;Dodatnia&quot; Wyrażenie else if() różni się od else tym, że wymaga ono określenia jaki warunek ma być spełniony. W przypadku else wyliczane są wszystkie przypadki, które nie spełniają wcześniejszych warunków. 4.3 Operatory porównania W tabeli 4.1 można znaleźć listę podstawowych operatorów porównania. Ich celem jest sprawdzanie pewnego warunku i zwrócenie wartości TRUE lub FALSE. Tabela 4.1: Operatory porównania. Operator Wyjaśnienie == Równy != Nie równy %in% Zawiera się w &gt;, &lt; Większy/Mniejszy niż &gt;=, &lt;= Większy/Mniejszy niż lub równy Wyrażenie if() oczekuje wektora logiczego o długości jeden. Często jednak efektem porównania może być wektor o większej długości. Przykładowo, porównanie operatorem == daje w wyniku wektor o długości trzy, a porówanie z użyciem %in% skutkuje wektorem o długości jeden. x = 1 y = c(1, 2, 3) x == y #&gt; [1] TRUE FALSE FALSE x %in% y #&gt; [1] TRUE Sterowanie tym, żeby uzyskany wynik miał oczekiwaną długość jeden może się odbywać też z pomocą operatorów logicznych i funkcji pomocniczych (tabela 4.2). Tabela 4.2: Operatory logiczne i funkcje pomocniczne. Operator Wyjaśnienie ! Negacja (nie) &amp;&amp; Koniunkcja (i) || Alternatywa (lub) all Wszystkie any Którykolwiek Pozwalają one na sprawdzenie czy wszystkie (all()) lub którykolwiek (any()) z elementów obiektu przyjmuje wartość TRUE. x = 1 y = c(1, 2, 3) all(x == y) #&gt; [1] FALSE any(x == y) #&gt; [1] TRUE Możliwe jest też łączenie bardziej złożonych zapytań używając operatora “i” (&amp;&amp;) oraz operatora “lub” (||). x = 1 y = c(1, 2, 3) z = 4 (x %in% y) || !(z %in% y) #&gt; [1] TRUE Powyżej nastąpiło sprawdzenie czy element z obiektu x znajduje się w obiekcie y, a następnie czy element z obiektu z nie znajduje się w obiekcie y. Po wykonaniu ich sprawdzeń nastąpiło ich połączenie używając operatora ||, który daje wartość TRUE, gdy chociaż jedno z zapytań jest prawdziwe. W R istnieją dwa dodatkowe operatory logiczne &amp; i |, które są zwektoryzowaną wersją operatorów &amp;&amp; i ||. Pierwsze dwa porównują wszystkie elementy zadanych wektorów i ich wynikiem może być wektor o długości większej niż 1. Operatory &amp;&amp; i || porównują tylko pierwszy element każdego wektora, a w efekcie zawsze zwracają tylko jedną wartość. Dodatkowo, to one są zazwyczaj używane w wyrażeniach warunkowych. 4.4 Wyrażenia warunkowe w funkcjach Wyrażenia warunkowe są często używanym elementem przy tworzeniu funkcji. Pozwalają one na nie tylko na określanie tego w jaki sposób dana funkcja zadziała, ale też pełnią rolę w sprawdzaniu czy do funkcji zostały wprowadzone poprawne argumenty. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.\\n&quot;)) if (temperatura &lt; 5){ cat(&quot;Ubierz się ciepło!&quot;) } } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. #&gt; Ubierz się ciepło! pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. 4.5 Zadania Spójrz na poniższe przykłady, ale ich nie wykonuj. Co będzie wynikiem działania każdego z tych przykładów? liczby = c(1, 2) liczby == 1 #1 liczby != 1 #2 liczby %in% 1 #3 all(liczby %in% 1) #4 any(liczby %in% 1) #5 Spójrz na cztery poniższe przykłady, ale ich nie wykonuj. Co będzie wynikiem działania każdego z tych przykładów? (c(1, 2) &gt; 0) &amp; (c(-1, 2) &gt; 0) #1 (c(1, 2) &gt; 0) &amp;&amp; (c(-1, 2) &gt; 0) #2 (c(1, 2) &gt; 0) | (c(-1, 2) &gt; 0) #3 (c(1, 2) &gt; 0) || (c(-1, 2) &gt; 0) #4 Napisz funkcję, która przyjmuje trzy zmienne logiczne x, y i z. Jeżeli tylko jedna lub trzy ze zmiennych ma wartość TRUE wyświetl tekst &quot;Nieparzysta liczba.&quot;, natomiast jeżeli dwie zmienne mają wartość TRUE wyświetl tekst &quot;Parzysta liczba.&quot; Napisz funkcję, która przyjmuje dwie zmienne numeryczne x i y. Jeżeli wszystkie wartości zmiennej x są większe od y wyświetl tekst &quot;Zwycięstwo.&quot;, a w przeciwnym razie wyświetl tekst &quot;Porażka.&quot;. Napisz funkcję, która przyjmuje dwie zmienne numeryczne populacja i powierzchnia. Jeżeli wartości gęstości zaludnienia (liczba osób na jednostkę powierchni) jest wyższa niż 123 wyświetl tekst &quot;Wartość powyżej średniej dla Polski.&quot; "],
["proste-obiekty.html", "5 Proste obiekty 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów 5.3 Wektory 5.4 Właściwości wektorów 5.5 Podstawowe funkcje 5.6 Brakujące wartości 5.7 Wydzielanie 5.8 Wydzielanie i przypisanie 5.9 Modyfikowanie obiektów 5.10 Łączenie podstawowych typów obiektów 5.11 … 5.12 Zmiana typów obiektów 5.13 Zadania", " 5 Proste obiekty Więcej informacji na temat podstawowych typów obiektów można znaleźć w rozdziale “Vectors” książki Advanced R (Wickham 2014). 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów Obiekty w R można podzielić na proste (homogeniczne) i złożone (heterogeniczne). Do podstawowych prostych obiektów należą wektory (ang. vector) i macierze (ang. matrix), natomiast listy (ang. list) i ramki danych (ang. data frame) to obiekty złożone. W tym rozdziale skupimy się na wektorach. Pozostałe podstawowe typy obiektów są omówione w rozdziale 7. 5.3 Wektory Wektor może przyjmować jeden z czterech podstawowych typów26: logiczny (ang. logical) wek_log = c(TRUE, FALSE) wek_log #&gt; [1] TRUE FALSE liczba całkowita (ang. interger) wek_cal = c(5L, -7L) wek_cal #&gt; [1] 5 -7 liczba zmiennoprzecinkowa (ang. double)27 wek_zmi = c(5.3, -7.1) wek_zmi #&gt; [1] 5.3 -7.1 znakowy (ang. character) wek_zna = c(&quot;kot&quot;, &quot;pies&quot;) wek_zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; Dodatkowo, istnieją dwa dodatkowe, rzadziej spotykane typy wektorów - czynnikowy (ang. factor) i dat (ang. date). 5.4 Właściwości wektorów Każdy wektor ma trzy właściwości - typ, długość i atrybuty. # typ typeof(wek_zmi) #&gt; [1] &quot;double&quot; # długość length(wek_zmi) #&gt; [1] 2 # atrybuty attributes(wek_zmi) #&gt; NULL 5.5 Podstawowe funkcje str(wek_zmi) #&gt; num [1:2] 5.3 -7.1 names(wek_zmi) #&gt; NULL names(wek_zmi) = c(&quot;a&quot;, &quot;b&quot;) wek_zmi #&gt; a b #&gt; 5.3 -7.1 names(wek_zmi) #&gt; [1] &quot;a&quot; &quot;b&quot; rep(wek_zmi, 4) #&gt; a b a b a b a b #&gt; 5.3 -7.1 5.3 -7.1 5.3 -7.1 5.3 -7.1 seq(1, 12, by = 2) #&gt; [1] 1 3 5 7 9 11 5.6 Brakujące wartości Wyobraź sobie, że wykonujesz codziennie o 12:00 pomiar temperatury. temperatura = c(8.2, 10.3, 12.0) Czwartego dnia twój termometr się popsuł i nie można było wykonać pomiaru. Co należałoby w takim razie zrobić? Możnaby pominąć ten pomiar, naprawić termometr i wykonać pomiar kolejnego dnia. Wówczas jednak mielibyśmy cztery wartości dla pięciu dni. Inną możliwą opcją byłoby użycie wartości, która stałaby się kodem wartości brakujących, np. 999. Problemem tego rozwiązania jest to w jaki sposób należałoby, np. wyliczyć średnią w tym obiekcie. temperatura = c(8.2, 10.3, 12.0, 999) Najlepszą opcją byłoby wykorzystanie wbudowanego oznaczenia wartości brakujących w R - NA. temperatura = c(8.2, 10.3, 12.0, NA) 5.7 Wydzielanie R posiada trzy podstawowe operatory wydzielania (ang. subsetting) - [], [[]] oraz $, które działają w różny sposób w zależności od tego czy wydzielamy wektory, macierze, ramki danych czy listy. W tym rozdziale skupimy się na wydzielaniu elementów z wektora przy użyciu operatora []. Więcej na temat wydzielania innych obiektów można znaleźć w rozdziale 7. Wydzielanie wektorów używając operatora [] może odbywać się używając jednego z poniższych zapytań: Na podstawie pozycji Na podstawie wektora logicznego Na podstawie nazwy Używając elementu pustego Używając zera temperatura[c(1, 3)] #&gt; [1] 8.2 12.0 temperatura[-c(2, 4)] #&gt; [1] 8.2 12.0 temperatura[c(TRUE, FALSE, TRUE, FALSE)] #&gt; [1] 8.2 12.0 temperatura[temperatura &gt; 10] #&gt; [1] 10.3 12.0 NA names(temperatura) = c(&quot;Poniedziałek&quot;, &quot;Wtorek&quot;, &quot;Środa&quot;, &quot;Czwartek&quot;) temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[c(&quot;Wtorek&quot;, &quot;Czwartek&quot;)] #&gt; Wtorek Czwartek #&gt; 10.3 NA temperatura[] #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[0] #&gt; named numeric(0) 5.8 Wydzielanie i przypisanie 5.9 Modyfikowanie obiektów 5.10 Łączenie podstawowych typów obiektów c(temperatura, temperatura) #&gt; Poniedziałek Wtorek Środa Czwartek Poniedziałek #&gt; 8.2 10.3 12.0 NA 8.2 #&gt; Wtorek Środa Czwartek #&gt; 10.3 12.0 NA Właściwością wektora jest to, że może on przyjmować tylko jeden typ. Próba stworzenia obiektu składającego się z wielu typów spowoduje wymuszenie (ang. coercion) do najbliższego możliwego typu. Odbywa się to zgodnie z zasadą: logiczny -&gt; liczba całkowita -&gt; liczba zmiennoprzecinkowa -&gt; znakowy. FALSE #&gt; [1] FALSE c(FALSE, 0L) #&gt; [1] 0 0 c(FALSE, 0L, 3.1) #&gt; [1] 0.0 0.0 3.1 c(FALSE, 0L, 3.1, &quot;kot&quot;) #&gt; [1] &quot;FALSE&quot; &quot;0&quot; &quot;3.1&quot; &quot;kot&quot; 5.11 … 5.12 Zmiana typów obiektów Do zmiany typu obiektu służą funkcje as.logical(), as.integer(), as.double(), oraz as.character()28. as.logical(c(&quot;FALSE&quot;, &quot;TRUE&quot;)) # znakowy na logiczny #&gt; [1] FALSE TRUE as.integer(c(&quot;3&quot;, &quot;2&quot;)) # znakowy na liczba całkowita #&gt; [1] 3 2 as.double(c(3L, 2L)) # liczba całkowita na liczba zmiennoprzecinkowa #&gt; [1] 3 2 as.character(c(3L, 2L)) # liczba całkowita na znakowy #&gt; [1] &quot;3&quot; &quot;2&quot; 5.13 Zadania Bibliografia "],
["tekst.html", "6 Tekst 6.1 Łączenie tekstu 6.2 Postawowe operacje na tekście 6.3 Wydzielanie tekstu 6.4 Wyrażenia regularne 6.5 Wyrażenia regularne (wydzielanie tekstu) 6.6 Wyrażenia regularne (zamiana tekstu) 6.7 Wyszukiwanie plików 6.8 Zadania", " 6 Tekst Więcej na temat przetwarzania tekstu można znaleźć w rozdziale “Strings” książki R for Data Science (Grolemund and Wickham 2016). Typ znakowy jest określany poprzez użycie cudzysłowia &quot; lub '. Ważne tutaj jest, aby rozpoczynać i kończyć tekst tym samym cudzysłowiem. t1 = &quot;kot&quot; t2 = &#39;pies&#39; t3 = &#39;&quot;W teorii, teoria i praktyka są tym samym. W praktyce, nie są.&quot; - Yogi Berra&#39; W momencie, gdy tekst nie będzie kończył się cudzysłowiem, wykonanie kodu jest niemożliwe. Wówczas zamiast znaku &gt;, oznaczającego nową linię wykonywanego kodu, pojawi się znak +. Oznacza on, że wykonanie kodu nie może zostać zakończone. &gt; &quot;Mój pierwszy alfabet + + W takiej sytuacji należy nacisnąć klawisz Esc, aby przerwać wykonywanie operacji, a następnie poprawić wpisany kod. 6.1 Łączenie tekstu paste(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;t o k o t&quot; paste0(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;to kot&quot; imie = &quot;Olek&quot; wiek = 7 tekst1 = paste(imie, &quot;ma&quot;, wiek, &quot;lat.&quot;) tekst1 #&gt; [1] &quot;Olek ma 7 lat.&quot; 6.2 Postawowe operacje na tekście (Wickham 2019) library(stringr) toupper(tekst1) #&gt; [1] &quot;OLEK MA 7 LAT.&quot; tolower(tekst1) #&gt; [1] &quot;olek ma 7 lat.&quot; tekst2 = c(&quot;chronologia&quot;, &quot;alfabet&quot;, &quot;hałas&quot;) str_sort(tekst2, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; str_sort(tekst2, locale = &quot;cs&quot;) #&gt; [1] &quot;alfabet&quot; &quot;hałas&quot; &quot;chronologia&quot; tekst3 = c(&quot;chronologia &quot;, &quot;alfabet&quot;, &quot; hałas&quot;) str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot; hałas&quot; &quot;alfabet&quot; &quot;chronologia &quot; tekst3 = str_trim(tekst3) tekst3 #&gt; [1] &quot;chronologia&quot; &quot;alfabet&quot; &quot;hałas&quot; str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; 6.3 Wydzielanie tekstu str_sub(tekst1, start = 1, end = 4) #&gt; [1] &quot;Olek&quot; str_sub(tekst1, start = 9, end = 14) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = 9, end = -1) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = -6, end = -1) #&gt; [1] &quot;7 lat.&quot; 6.4 Wyrażenia regularne Wyrażenia regularne (ang. regular expressions), często określane jako regex to sposób opisywanie wzorców tekstu. Używając wyrażeń regularnych możliwe jest, między innymi, znajdowanie tekstu lub zamienienie, który spełnia wymagane warunki. Wyrażenia regularne są powszechnie używane w wyszukiwarkach internetowych, edytorach tekstu, oraz wielu językach programowania. tekst4 = c(&quot;Magdalena&quot;, &quot;Lena&quot;, &quot;1Lena.csv&quot;, &quot;LLena&quot;, &quot;Helena&quot;, &quot;Anna&quot;, 99) str_detect(tekst4, &quot;Lena&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, &quot;lena&quot;) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE Tabela 6.1: Metaznaki w wyrażeniach regularnych Operator Wyjaśnienie ^ Określa początek tekstu/linii $ Określa koniec testu/linii () Grupowanie | Alternatywa (lub) [] Wymienia dozwolone znaki [^] Wymienia niedozwolone znaki * Poprzedni znak zostanie wybrany zero lub więcej razy + Poprzedni znak zostanie wybrany jeden lub więcej razy ? Poprzedni znak zostanie wybrany zero lub jeden raz {n} Poprzedni znak zostanie wybrany n razy . Jakikolwiek znak oprócz nowej linii () \\ Pozwala na użycie specjalnych znaków Wymienione powyżej znaki (np. ^ czy .) określane są jako metaznaki (ang. metacharacters) i mają one specjalne znaczenie. W związku z tym, jeżeli chcemy wyszukać tekstu zawierającego specjalny znak, musimy użyć ukośnik wsteczny (\\, ang. backslash). Istnieje wiele dodatkowych znaków specjalnych, np. \\n - nowa linia, \\t - tabulator, \\d - każdy znak numeryczny (stałoprzecinkowy), \\s - znak niedrukowalny, np. spacja, tabulator, nowa linia. str_detect(tekst4, pattern = &quot;^L&quot;) #&gt; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;ena$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE FALSE FALSE str_detect(tekst4, pattern = &quot;(ena|nna)$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[a-zA-Z]&quot;) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[0-9]&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE str_detect(tekst4, pattern = &quot;L+&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;^[^L]+&quot;) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE &gt;str_detect(tekst4, pattern = &quot;\\.&quot;) #&gt; Error: &#39;\\.&#39; is an unrecognized escape in character string starting &quot;&quot;\\.&quot; str_detect(tekst4, pattern = &quot;\\\\.&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE # str_detect(tekst4, pattern = &quot;&quot;) y = c(&quot;kołdra&quot;, &quot;kordła&quot;, &quot;pościel&quot;) str_detect(y, pattern = &quot;ko(łdr|rdł)a&quot;) 6.5 Wyrażenia regularne (wydzielanie tekstu) # str_extract() 6.6 Wyrażenia regularne (zamiana tekstu) # str_replace() Umiejętności używania wyrażeń regularnych można trenować używając różnych zasobów internetowych, np. strony https://regexr.com/ lub https://regex101.com/. 6.7 Wyszukiwanie plików 6.8 Zadania Bibliografia "],
["zlozone-obiekty.html", "7 Złożone obiekty 7.1 Macierze 7.2 Ramki danych 7.3 Listy 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania", " 7 Złożone obiekty 7.1 Macierze Macierze (ang. matrix), podobnie jak wektory, są obiektami homogenicznymi - jedna macierz może przyjmować dane tylko jednego typu. 7.1.1 Tworzenie macierz1 = matrix(1:12, ncol = 3, nrow = 4) macierz1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 macierz2 = matrix(1:12, ncol = 3, nrow = 4, byrow = TRUE) macierz2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 7.1.2 Podstawowe funkcje class(macierz2) #&gt; [1] &quot;matrix&quot; str(macierz2) #&gt; int [1:4, 1:3] 1 4 7 10 2 5 8 11 3 6 ... typeof(macierz2) #&gt; [1] &quot;integer&quot; ncol(macierz2) #&gt; [1] 3 nrow(macierz2) #&gt; [1] 4 colnames(macierz2) #&gt; NULL colnames(macierz2) = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) macierz2 #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 colnames(macierz2) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 7.1.3 Wydzielanie Podobnie jak w przypadku wektorów (5), macierze można wydzielać używając operatora []. W tym wypadku odbywa się to jednak na w oparciu o dwa indeksy - jeden dla wiersza, drugi dla kolumny - [wiersz, kolumna]. macierz2[c(1, 2), c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 macierz2[c(1, 2), ] #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 macierz2[, c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(TRUE, FALSE, TRUE)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(&quot;a&quot;, &quot;c&quot;)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 7.1.4 Łączenie macierz3 = cbind(macierz1, macierz2) macierz3 #&gt; a b c #&gt; [1,] 1 5 9 1 2 3 #&gt; [2,] 2 6 10 4 5 6 #&gt; [3,] 3 7 11 7 8 9 #&gt; [4,] 4 8 12 10 11 12 macierz4 = rbind(macierz1, macierz2) macierz4 #&gt; a b c #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [5,] 1 2 3 #&gt; [6,] 4 5 6 #&gt; [7,] 7 8 9 #&gt; [8,] 10 11 12 7.2 Ramki danych Ramki danych (ang. data frame) mają dużo podobieństw z macierzami. Są to obiekty dwuwymiarowe, składające się z kolumn i wierszy. Główną różnicą pomiędzy macierzą a ramką danych jest to, że pierwsza z nich przyjmuje tylko dane jednego typu, podczas gdy druga może się składać z danych róznych typów. Ramka danych jest zbudowana z kolumn (wektorów) o równej długości. 7.2.1 Tworzenie ramka1 = data.frame(wek_log = c(TRUE, FALSE, FALSE), wek_cal = c(5L, -7L, 12L), wek_zmi = c(5.3, -7.1, 1.1), wek_zna = c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;), stringsAsFactors = FALSE) ramka1 #&gt; wek_log wek_cal wek_zmi wek_zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.2 Podstawowe funkcje class(ramka1) #&gt; [1] &quot;data.frame&quot; str(ramka1) #&gt; &#39;data.frame&#39;: 3 obs. of 4 variables: #&gt; $ wek_log: logi TRUE FALSE FALSE #&gt; $ wek_cal: int 5 -7 12 #&gt; $ wek_zmi: num 5.3 -7.1 1.1 #&gt; $ wek_zna: chr &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; ncol(ramka1) #&gt; [1] 4 nrow(ramka1) #&gt; [1] 3 colnames(ramka1) #&gt; [1] &quot;wek_log&quot; &quot;wek_cal&quot; &quot;wek_zmi&quot; &quot;wek_zna&quot; colnames(ramka1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) ramka1 #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec colnames(ramka1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.2.3 Wydzielanie Do wydzielania elementów z ramki danych może służyć, między innymi, operator $, operator [] oraz funkcja subset(). Operator $ pozwala na wybranie zmiennej (kolumny) na podstawie jej nazwy. ramka1$zmi #&gt; [1] 5.3 -7.1 1.1 ramka1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; W przypadku ramek danych operator [] wymaga podania dwóch argumentów - jednego dla wierszy (obserwacji) oraz jednego dla kolumn (zmiennych) - [wiersze, kolumny]. ramka1[c(1, 3), c(1, 2)] #&gt; log cal #&gt; 1 TRUE 5 #&gt; 3 FALSE 12 Do wydzielania można też wykorzystać operatory logiczne: ==, %in%, !=, &gt;, &gt;=, &lt;, &lt;=, &amp;, |. ramka1[c(1, 3), ramka1$zmi &gt; 0] #&gt; log zmi zna #&gt; 1 TRUE 5.3 kot #&gt; 3 FALSE 1.1 nosorożec ramka1[ramka1$zna == &quot;kot&quot;, ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot ramka1[ramka1$zna %in% c(&quot;kot&quot;, &quot;pies&quot;), ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies ramka1[ramka1$cal &gt; 6 | ramka1$cal &lt; -6, ] #&gt; log cal zmi zna #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.4 Łączenie ramka2 = data.frame(zmi2 = c(4.3, 2.6, 7.4)) ramka2 #&gt; zmi2 #&gt; 1 4.3 #&gt; 2 2.6 #&gt; 3 7.4 cbind(ramka1, ramka2) #&gt; log cal zmi zna zmi2 #&gt; 1 TRUE 5 5.3 kot 4.3 #&gt; 2 FALSE -7 -7.1 pies 2.6 #&gt; 3 FALSE 12 1.1 nosorożec 7.4 ramka3 = data.frame(log = TRUE, cal = 2L, zmi = 2.3, zna = &quot;żółw&quot;) ramka3 #&gt; log cal zmi zna #&gt; 1 TRUE 2 2.3 żółw rbind(ramka1, ramka3) #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec #&gt; 4 TRUE 2 2.3 żółw 7.3 Listy 7.3.1 Tworzenie lista1 = list(c(TRUE, FALSE), c(5L, -7L), c(5.3), c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;)) lista1 #&gt; [[1]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]] #&gt; [1] 5 -7 #&gt; #&gt; [[3]] #&gt; [1] 5.3 #&gt; #&gt; [[4]] #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.2 Podstawowe funkcje class(lista1) #&gt; [1] &quot;list&quot; str(lista1) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:2] 5 -7 #&gt; $ : num 5.3 #&gt; $ : chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; length(lista1) #&gt; [1] 4 names(lista1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) lista1 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; names(lista1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.3.3 Łączenie lista2 = c(lista1, lista1) lista2 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista3 = list(lista1, lista1) lista3 #&gt; [[1]] #&gt; [[1]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[1]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[1]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[1]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[2]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[2]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.4 Wydzielanie lista4 = lista1[c(1, 2)] str(lista4) #&gt; List of 2 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 lista5 = lista1[[c(4)]] str(lista5) #&gt; chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista6 = lista3[[c(2)]] str(lista6) #&gt; List of 4 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1[c(&quot;zmi&quot;, &quot;zna&quot;)] #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania "],
["petle.html", "8 Powtarzanie 8.1 Wektoryzacja 8.2 Pętla for 8.3 Pętla while 8.4 Programowanie funkcyjne 8.5 Zadania", " 8 Powtarzanie 8.1 Wektoryzacja 8.2 Pętla for for (element in wektor) { przetwarzanie elementu } odl_mile = c(142, 63, 121) for (i in odl_mile) { print(i * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 for (i in 1:3) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_mile[i] = odl_mile[i] * 1.609 } odl_mile #&gt; [1] 228 101 195 odl_km = vector(&quot;numeric&quot;, length = 0) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km = c(odl_km, odl_mile[i] * 1.609) } odl_km #&gt; [1] 368 163 313 odl_mile = c(142, 63, 121) odl_km = vector(&quot;numeric&quot;, length = length(odl_mile)) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km[i] = odl_mile[i] * 1.609 } odl_km #&gt; [1] 228 101 195 8.3 Pętla while 8.4 Programowanie funkcyjne 8.5 Zadania Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ if (i &lt; 2 | i &gt;= 5) print(&quot;Działa!&quot;) } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 | i &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 &amp; j &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 4, 5, 6)){ for (j in 6:3){ if (i &lt; 2 | j &gt;= 5) print(&quot;Działa!&quot;) } } Spójrz na poniższy kod, ale nie wykonuj go. Ile razy zostanie wyświetlony tekst &quot;Działa!&quot;? for (i in c(1, 2, 3)){ for (j in 6:3){ i = i + j if (i &lt; 4 | i &gt;= 9) print(&quot;Działa!&quot;) } } "],
["io.html", "9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy 9.2 Zadania", " 9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy Folder roboczy (ang. working directory) to miejsce na dysku, w którym aktualnie pracujemy. Folder roboczy można sprawdzić korzystając z funkcji getwd(): getwd() #&gt; [1] &quot;/home/travis/build/Nowosad/elp&quot; Zmienić folder roboczy można za pomocą skrótu Ctrl+Shift+H w RStudio (inaczej Session -&gt; Set Working Directory -&gt; Choose Directory..) lub też funkcji setwd(): setwd(&quot;home/jakub/Documents/progr/&quot;) #unix setwd(&quot;C:/Users/jakub/Documenty/progr/&quot;) #windows Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki. Znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami. Ścieżka względna … Ścieżka bezwzględna … 9.2 Zadania "],
["zlozone-funkcje.html", "10 Złożone funkcje 10.1 API 10.2 Obsługa błędów 10.3 Zadania", " 10 Złożone funkcje 10.1 API 10.2 Obsługa błędów –&gt; 10.3 Zadania "],
["analiza-kodu.html", "11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie", " 11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie "],
["kontrola-wersji.html", "12 Kontrola wersji 12.1 Git 12.2 Git w RStudio 12.3 GitHub 12.4 Zadania", " 12 Kontrola wersji 12.1 Git 12.2 Git w RStudio 12.3 GitHub 12.4 Zadania "],
["tworzenie-pakietow.html", "13 Tworzenie pakietów 13.1 Rozwijanie pakietu 13.2 Dokumentacja funkcji 13.3 Zależności 13.4 Dokumentacja pakietu 13.5 Testy jednostkowe 13.6 Licencje 13.7 Publikowanie pakietów 13.8 Zadania", " 13 Tworzenie pakietów Funkcja create_packages() tworzy cztery pliki: .Rproj R/ DESCRIPTION NAMESPACE 13.1 Rozwijanie pakietu 13.2 Dokumentacja funkcji 13.3 Zależności 13.4 Dokumentacja pakietu 13.5 Testy jednostkowe 13.6 Licencje 13.7 Publikowanie pakietów software documentation software promotion Continuous Integration 13.8 Zadania "],
["lacznik.html", "14 Łącznik 14.1 Zadania", " 14 Łącznik 14.1 Zadania "],
["debugging.html", "15 Debugowanie 15.1 Zadania", " 15 Debugowanie 15.1 Zadania "],
["podsumowanie.html", "16 Podsumowanie", " 16 Podsumowanie "],
["bibliografia.html", "Bibliografia", " Bibliografia "]
]
