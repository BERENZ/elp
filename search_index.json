[
["index.html", "Elementarz programisty Wstęp do programowania używając R O książce Wymagania wstępne Styl książki Podziękowania", " Elementarz programisty Wstęp do programowania używając R Jakub Nowosad 2019-02-19 O książce Aktualna wersja książki znajduje się pod adresem https://nowosad.github.io/elp/. Jeżeli używasz tej książki, zacytuj ją jako: Nowosad, J., (2019). Elementarz programisty: wstęp do programowania używając R. Poznań: Space A. Online: https://nowosad.github.io/elp/ Zachęcam również do zgłaszania wszelkich uwag, błędów, pomysłów oraz komentarzy na stronie https://github.com/nowosad/elp/issues. Ta książka jest dostępna na licencji Creative Commons Uznanie autorstwa - Użycie niekomercyjne - Bez utworów zależnych 4.0 Międzynarodowe. Wymagania wstępne Do odtworzenia przykładów oraz do wykonania zadań zawartych w tej książce konieczne jest posiadanie aktualnej wersji R. Pod adresem https://cloud.r-project.org/ można znaleźć instrukcje instalacji R dla systemów Windows, Mac OS i Linux. W niektórych rodziałach użyte zostanie zintegrowane środowisko programistyczne RStudio. Można je zainstalować korzystając ze strony https://www.rstudio.com/products/rstudio/download/#download. Aspekty dotyczące kontroli wersji zostaną omówione używając oprogramowania Git. Zalecanym sposobem installacji Git na Windows jest wersja ze strony https://gitforwindows.org/. Instrukcja instalacji na system Mac OS znajduje się pod adresem https://happygitwithr.com/install-git.html#macos. Wersję Linuxową można zainstalować używając poniższej linii kodu: # Ubuntu sudo apt install git # Fedora sudo dnf install git Dodatkowo, warto stworzyć konto na stronie GitHub poprzez adres https://github.com/join. GitHub jest serwisem internetowym wspierającym tworzenie oraz współpracę przy tworzeniu programów komputerowych. Styl książki W całej książce stosowana jest konwencja, w której fun() oznacza funkcje, obi oznacza nazwy obiektów, nazwy zmiennych oraz argumentów funkcji, a sci/ oznacza ścieżki do plików. Wszystkie pakiety użyte w tej książce oznaczane są pogrubioną czcionką - pak. Tekst na szarym tle przedstawia blok kodu. Może on zawierać komentarze (rozpoczynające się of znaku #), kod oraz wynik jego użycia (rozpoczynające się od znaków #&gt;). # komentarz kod #&gt; wynik użycia kodu Dodatkowo, ikona kompasu na szarym tle przedstawia dodatkowe informacje, alternatywne sposoby użycia funkcji, czy też wskazówki. Tutaj może znaleźć się dodatkowa informacja, alternatywny sposób użycia funkcji, czy też wskazówka. Podziękowania Książka została stworzona w R (R Core Team 2017) z wykorzystaniem pakietów bookdown (Xie 2018a), rmarkdown (Allaire et al. 2018), knitr (Xie 2018b) oraz programu Pandoc. Użyte ikony zostały stworzone przez Freepik z www.flaticon.com na licencji CC 3.0 BY. Bibliografia "],
["wprowadzenie.html", "1 Wprowadzenie 1.1 Zadania", " 1 Wprowadzenie Programowanie komputerowe ma obecnie już długą historię - pierwszy język programowania Plankalkül powstał mniej więcej w latach 1943-1945. Fortran stworzony w roku 1957 jest nadal używany współcześnie do wielu celów, między innymi wymagających dużej wydajności obliczeń astronomicznych, hydrologicznych, prognozowania pogody czy modelowania klimatu. Programowanie ewoluowało (i nadal ewoluuje) wraz z rozwojem dostępności i możliwości komputerów. Pojawiły się nowe pradygmaty programowania oraz wiele nowych języków. W tym samym czasie narosło również wiele mitów dotyczących programowania1 Rycina 1.1: Logo języka programowania R. 1.1 Zadania Zobacz porównanie oczekiwań i rzeczywistej pracy programisty na https://www.youtube.com/watch?v=HluANRwPyNo.↩ "],
["ergosum.html", "2 R ergo sum 2.1 Wyrażenia 2.2 Obiekty 2.3 IDE 2.4 Pomoc 2.5 Styl 2.6 Zadania", " 2 R ergo sum 2.1 Wyrażenia 2 + 2 #&gt; [1] 4 1 - 3 #&gt; [1] -2 5 * 5 #&gt; [1] 25 42 / 5 #&gt; [1] 8.4 2.2 Obiekty 2.2.1 Operator przypisania Operator przypisania służy do nadania wartości do obiektu. R posiada trzy operatory przypisania, które mają niemal identyczne działanie2: =, &lt;-, -&gt;. x = 7 x #&gt; [1] 7 y = x y #&gt; [1] 7 2.2.2 Działania na obiektach z1 = x + 3 z1 #&gt; [1] 10 z2 = x - 5 z2 #&gt; [1] 2 z3 = x * 2 z3 #&gt; [1] 14 z4 = x / 4.4 z4 #&gt; [1] 1.59 z5 = x %% 3 z5 #&gt; [1] 1 z6 = x %/% 3 z6 #&gt; [1] 2 z7 = x ^ 2 z7 #&gt; [1] 49 z8 = sqrt(x) z8 #&gt; [1] 2.65 z9 = c(z2, z4, z8) z9 #&gt; [1] 2.00 1.59 2.65 2.3 IDE Rstudio to zintegorwane środowsko programistyczne (ang. Integrated Development Environment, IDE) dla R. Zawiera ono bardzo wiele użytecznych funkcjonalności, tj. wbudowany edytor, podświetlanie składni, automatyczne uzupełnianie kodu i wiele innych. Tabela 2.1: Podstawowe skróty klawiaturowe w RStudio Skrót Wyjaśnienie Ctrl+Enter wykonuje wybraną linię kodu w skrypcie R Tab uzupełnia kod (podaje pasujące mozliwości) F1 wyświetla plik pomocy dla wybranej funkcji Ctrl+Shift+C ustawia wybrane linie jako komentarz/odkomentuj fragment kodu strzałka Góra/Dół (w oknie konsoli) wybiera wcześniej wpisany kod Esc przerwya niedokończoną operację 2.4 Pomoc Polskie książki: http://www.biecek.pl/R/ (Biecek 2014) http://www.gagolewski.com/publications/programowanier/ (Gagolewski 2016) https://helion.pl/ksiazki/jezyk-r-kompletny-zestaw-narzedzi-dla-analitykow-danych-hadley-wickham-garrett-grolemund,jezrko.htm#format/d (Wickham and Grolemund 2016) https://helion.pl/ksiazki/wydajne-programowanie-w-r-praktyczny-przewodnik-po-lepszym-programowaniu-gillespie-colin-lovelace-robin,a_0491.htm#format/d (Gillespie and Lovelace 2016) https://bookdown.org/nowosad/Geostatystyka/ (Nowosad 2019) Angielskie książki: https://rstudio-education.github.io/hopr/ (Grolemund 2014) https://r4ds.had.co.nz/ (Wickham and Grolemund 2016) https://csgillespie.github.io/efficientR/ (Gillespie and Lovelace 2016) https://adv-r.hadley.nz (Wickham 2014) https://geocompr.robinlovelace.net/ (Lovelace, Nowosad, and Meunchow 2019) Blogi: Agregator blogów dotyczących R - https://www.r-bloggers.com/ Polski blog opisujący kwestie analizy danych w R, wizualizacji, oraz edukacji - http://smarterpoland.pl/ Polski blog pokazujący zastosowanie R do analizy i wizualizacji danych - http://szychtawdanych.pl/ Kursy: Lista kursów dotyczących R na platformie DataCamp (część z nich jest dostępna bezpłatnie) - https://www.datacamp.com/search?q=r Polskie tłumaczenie pakietu R służącego do nauki tego języka - https://github.com/dabrze/swirl Lista kursów dotyczących R na platformie Coursera - https://www.coursera.org/courses?query=r Lista kursów dotyczących R na platformie edX - https://www.edx.org/course?search_query=r Serwisy internetowe: Wyszukiwarki internetowe są nieocenionym narzędziem wspierającym programowanie - https://rseek.org/, https://duckduckgo.com/, https://www.google.com/, https://www.bing.com/, itd. Serwis społecznościowy zawierający pytania i odpowiedzi dotyczące różnych języków programowania w tym R - https://stackoverflow.com. Pytania dotyczące R można znaleźć pod adresem https://stackoverflow.com/questions/tagged/r. Przed zadaniem nowego pytania warto wyszukać czy nie zostało ono zadane wcześniej a następnie przeczytać wątek dotyczący tworzenia nowych pytań - https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example Twitter jest miejscem, w którym można znaleźć zarówno nowości z języka R, jak również odpowiedzi na pytania dotyczące tego języka - https://twitter.com/. Kwestie związane z R są opatrzone hasztagiem #rstats, natomiast kwestie przestrzenne w R są opisywane hasztagami #rspatial oraz #geocompr Lista emailowa dotycząca R - https://stat.ethz.ch/mailman/listinfo/r-help Lista emailowa dotycząca kwestii przestrzennych w R - https://stat.ethz.ch/mailman/listinfo/r-sig-geo Forum dotyczące kwestii R i RStudio - https://community.rstudio.com/ Meetups (spotkania początkujących i zaawansowanych użytkowników R): Poznań - https://www.meetup.com/pl-PL/Poznan-R-User-Group-PAZUR/ Warszawa - https://www.meetup.com/pl-PL/Spotkania-Entuzjastow-R-Warsaw-R-Users-Group-Meetup/ Wrocław - https://www.meetup.com/Wroclaw-R-Users-Group/ Kraków - https://www.meetup.com/erkakrakow/ Trójmiasto - https://www.meetup.com/Trojmiejska-Grupa-Entuzjastow-R/ 2.5 Styl Poniżej znajdują się podstawowe porady dotyczące stylu pisania kodu. Więcej wskazówek można znaleźć na w poradniku stylu RStudio oraz poradniku stylu Google. Oba te poradniki nie są identyczne i czasami zawierają sprzeczne porady. Najważniejsze jest, aby wybrać jeden odpowiadający piszącemu kod styl i się go konsekwentnie trzymać. 2.5.1 Nazwy obiektów Istnieje wiele konwencji nazywania obiektów3. Najczęściej używaną konwencją w R jest tzw. “snake case”. Polega ona na tworzeniu nazw obiektów składających się ze słów połączonych znakiem podkreślenia (_), np. Ważne, żeby nazwy obiektów ułatwiały zrozumienie ich zawartości. # obiekt bok_a bok_b # funkcja pole_prostokata Dodatkowo należy uważać, żeby nowa nazwa obiektu nie nadpisała istniejącego obiektu lub funkcji. Nie powinno nazywać się obiektów, np. c, t, table, itd. 2.5.2 Odstępy Odstępy pełnią bardzo ważną funkcję przy pisaniu kodu, podobnie jak odstępy przy pisaniu tekstu. Wyobraź sobie czytanie powieści, w której nie ma żadnych odstępów między słowami czy rozdziałami. Często mówi się, że “kod musi oddychać” - odstępy zwiększają czytelność kodu i pozwalają na jego szybsze zrozumienie oraz ułatwiają naprawienie występujących błędów. Odstępy można uzyskać poprzez użycie spacji. Spacje powinny być użyte po przecinkach, ale nigdy przed nimi. Dodatkowo, większość operatorów (np. =, +, -, ==) powinna być otoczona przez spacje. # Zalecane srednia = mean(wartosc, na.rm = TRUE) pole = bok_a * bok_b # Niewskazane srednia=mean ( wartosc,na.rm=TRUE ) pole=bok_a*bok_b Spacje należy również używać do tworzenia wcięć - każde z nich powinno się składać z dwóch spacji. # Zalecane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } # Niewskazane moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Warto także ograniczać długość każdej linii kodu, żeby nie przekraczała ona ok. 80 znaków. Dzięki temu możliwe jest szybkie przeczytanie kodu czy też jego wydrukowanie. # Zalecane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, b = &quot;drugi argument&quot;, c = &quot;trzeci argument&quot;) # Niewskazane bardzo_wazny_wynik = moja_bardzo_wazna_funkcja(&quot;pierwszy argument&quot;, &quot;drugi argument&quot;, &quot;trzeci argument&quot;) 2.5.3 Komentarze Komentarze służą do wyjaśniania istotnych elementów kodu. Do komentowania w języku R służy operator #. # Mój komentarz 2.5.4 Nazwy plików Podobnie jak nazwy obiektów, również nazwy plików powinny mieć nazwy opisujące ich zawartość. # Zalecane obliczanie-sredniej.R pomiary-temperatury.csv # Niewskazane kod.R dane.csv Dodatkowo nazwy plików nie powinny zawierać spacji, znaków specjalnych (np. !, %, *), znaków diakrytycznych (np. ć, Ł, ź). Warto też aby nazwy plików składały się tylko z małych liter. 2.6 Zadania Bibliografia "],
["funkcje.html", "3 Funkcje 3.1 Struktura funkcji 3.2 Wbudowane funkcje 3.3 Dokumentacja funkcji 3.4 Pakiety 3.5 Tworzenie skryptów 3.6 Budowanie funkcji 3.7 Zadania", " 3 Funkcje 3.1 Struktura funkcji 3.2 Wbudowane funkcje x = c(8.2, 10.3, 12.0) (8.2 + 10.3 + 12.0) / 3 #&gt; [1] 10.2 sum(x) / length(x) #&gt; [1] 10.2 mean(x) #&gt; [1] 10.2 y = mean(x) 3.3 Dokumentacja funkcji Każda wbudowana funkcja w R posiada swoją dokumentację4. Można ją wyświetlić poprzez dodanie znaku zapytania przed nazwą funkcji, a następnie wykonanie tej linii kodu. ?mean Alternatywnie, w RStudio możliwe jest użycie skrótu F1 gdy kursor znajduje się na nazwie funkcji. Dokumentacja każdej funkcji, zwana inaczej plikiem pomocy, ma zazwyczaj podobną strukturę. W lewym górnym rogu znajduje się nazwa funkcji (mean) oraz nazwa pakietu z którego dana funkcja pochodzi (base) Poniżej znajduje się tytuł funkcji oraz jej krótki opis Kolejnym elementem jest budowa funkcji (Usage), która skrótowo opisuje z jakich argumentów składa się dana funkcja. Np. funkcja mean() przyjmuje argument x, trim, oraz na.rm. Dla argumentów trim oraz na.rm są także ustalone ich domyślne wartości. Dodatkowo, widoczny jest argument w postaci wielokropka (...). Argumenty funkcji są również wypisane oraz skrótowo wyjaśnione. Przykładowo, x musi być obiektem R o typie numerycznym (który łączy typ liczb całkowitych i zmiennoprzecinkowych), logicznym, date, date-time, lub time interval. Część Value (lub Details) opisuje szczegóły wykonywanej funkcji Inne możliwe elementy to np. References odnoszący się do artykułu czy książki opisującej daną funkcję lub metodę, czy też See also zawierający odnośniki do innych, podobnych funkcji Jeden z najważniejszych elementów pliku pomocy znajduje się na samym końcu - są to przykłady (Examples). Jeżeli nie jesteśmy pewni jak dana funkcja działa warto zacząć od skopiowania przykładów a następnie ich wykonania. Czytanie dokumentacji wymaga pewnej wprawy i doświadczenia. Nie bój się używać innych źródeł pomocy (zobacz sekcję 2.4), jeżli potrzebujesz zrozumieć działanie danej funkcji. 3.4 Pakiety Pakiet to zorganizowany zbiór funkcji, który rozszerza możliwości R. Pakiety oprócz kodu zawierają szereg dodatkowych istotnych elementów, takich jak: Informacja o wersji pakietu, jego twórcach, zależnościach, czy licencji Dokumentacja Przykładowe dane Testy kodu Pakiety R mogą być przechowywane i instalowane z wielu miejsc w internecie. Istnieje jednak jedno centralne repozytorium (CRAN, ang. the Comprehensive R Archive Network), które zawiera oficjalne wersje pakietów R. Wersje deweloperskie (rozwojowe) często można znaleźć na platformie GitHub. Do instalacji pakietu w R z repozytorium CRAN służy wbudowana funkcja install.packages(), np: install.packages(&quot;stringr&quot;) #instalacja pakietu stringr Zainstalowanie pakietu w R z platformy GitHub jest możliwe używając, np. funkcji install_github() z pakietu remotes. # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;r-lib/remotes&quot;) Podobnie jak instalowanie programów na komputerze - zainstalowanie pakietu odbywa się tylko jeden raz. Użycie wybranego pakietu wymaga dołączenia go do R za pomocą funkcji library(). Dołączenie wybranych pakietów do R robimy po każdym uruchomieniu R. library(stringr) str_sub(&quot;chronologia&quot;, start = 1, end = 6) #&gt; Error in str_sub(&quot;chronologia&quot;, start = 1, end = 6) : #&gt; could not find function &quot;str_sub&quot; 3.5 Tworzenie skryptów Skrypt w R to plik testowy z rozszerzeniem .R, który zawiera szereg linii kodu w celu uzyskania konkretnego efektu. Może on zawierać zaledwie kilka jak i setki linii kodu w zależności od złożoności postawionego problemu. Zobaczmy jak wyglądają skrypty na prostym przykładzie - przeliczania wartości ze skali Fahrenheita na skalę Celsjusza. Otrzymaliśmy informację, że w “mieście A” temperatura w stopniach Fahrenheita wynosi 75. miasto_a = 75 Pierwszym naszym krokiem powinno być dowiedzenie się jaka jest relacja pomiędzy skalą Fahrenheita na skalą Celsjusza. \\[T_{Celsjusz} = \\frac{T_{Fahrenheit} - 32}{1.8}\\] Następnie powyższy wzór można przepisać do postaci kodu w języku R oraz podstawić do niego wartość temperatury w stopniach Fahrenheita w mieście A. Ostatnim etapem jest wyświetlenie uzyskanego wyniku - temperatura w mieście A wynosi ok. 24 stopnie Celsjusza. miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Powyższe kroki można również zapisać do pliku tekstowego. # plik przeliczanie-temp.R miasto_a = 75 miasto_a_c = (miasto_a - 32) / 1.8 miasto_a_c #&gt; [1] 23.9 Co można zrobić jeżeli mamy więcej podobnych pomiarów, które chcemy wykonać? Najprostszą opcją jest użycie kopiuj/wklej i powielenie tego samego kodu, a później naniesienie małych zmian, np. nazw obiektów. miasto_a = 75 miasto_b = 110 miasto_c = 0 miasto_a_c = (miasto_a - 32) / 1.8 miasto_b_c = (miasto_b - 32) / 1.8 miasto_c_c = (miasto_c - 32) / 1.8 Powyższe podejście jest poprawne, ale ma ono kilka wad: Łatwo jest o popełnie jakiegoś prostego błędu lub literówki podczas adaptacji kodu (np. można zapomnieć zmienić nazwę jakiejś zmiennej) Jeżeli obliczenia zajmują więcej niż kilka linii kodu - wówczas kopiowanie go znacznie powiększa tworzony skrypt i utrudnia jego czytelność Poprawienie kodu w przypadku zauważenia błędu w procedurze obliczeniowej jest czasochłonne To podejście jest też niezgodne z jedną z najważniejszych reguł w programowaniu - regułą DRY (Nie powtarzaj się, ang. Don’t Repeat Yourself). Zamiast tworzenia skryptu w oparciu o kopiuj/wklej lepiej pomyśleć nad zbudowaniem odpowiedniej funkcji5. 3.6 Budowanie funkcji Funkcje pozwalają na automatyzację często używanych obliczeń. Formalnie funkcje składają się z trzech elementów: listy argumentów (ang. formals), ciała funkcji (ang. body) oraz środowiska (ang. environment). Pierwsze dwa elementy ustala twórca funkcji, natomiast środowisko jest określane na podstawie tego, gdzie dana funkcja została zdefiniowana. Dodatkowo każda funkcja ma swoją nazwę. moja_funkcja = function(x, y, z){ pod = y / z wynik = x * pod wynik } Lista argumentów wymienia obiekty wejściowe funkcji. formals(moja_funkcja) #&gt; $x #&gt; #&gt; #&gt; $y #&gt; #&gt; #&gt; $z Ciało zawiera kod danej funkcji. body(moja_funkcja) #&gt; { #&gt; pod = y/z #&gt; wynik = x * pod #&gt; wynik #&gt; } Środowisko określa, gdzie dana funkcja jest zlokalizowana. environment(moja_funkcja) #&gt; &lt;environment: R_GlobalEnv&gt; Przykładowa funkcja odpowiadająca problemowi z poprzedniej sekcji może wyglądać w poniższy sposób: konwersja_temp = function(temperatura_f){ (temperatura_f - 32) / 1.8 } Nowa funkcja nazywa się konwersja_temp() oraz posiada tylko jeden argument temperatura_f. Ciało funkcji zawiera natomiast wzór potrzebny do obliczeń przepisany do R. Ważne jest to, że obiekt użyty wewnątrz funkcji (temperatura_f) jest taki sam jak wejściowy argument. Po stworzeniu funkcji warto sprawdzić czy jej działanie odpowiada naszym oczekiwaniom. konwersja_temp(75) #&gt; [1] 23.9 konwersja_temp(110) #&gt; [1] 43.3 konwersja_temp(0) #&gt; [1] -17.8 konwersja_temp(c(0, 75, 110)) #&gt; [1] -17.8 23.9 43.3 3.6.1 Komunikaty Oprócz wyniku danej operacji R może wyświetlić kilka rodzajów wiadomości. 3.7 Zadania Zobacz jak wygląda plik pomocy funkcji mean(). Wykonaj zawarte w nim przykłady. Co zostało w nich wykonane? Niektóre zbiory danych również posiadają swoje pliki pomocy.↩ Grolemund and Wickham (2016) radzą używać funkcje, gdy ten sam kod potwarza się co najmniej trzy razy.↩ "],
["warunki.html", "4 Wyrażenia warunkowe 4.1 Warunki 4.2 Warunki zagnieżdzone 4.3 Operatory porównania 4.4 Wyrażenia warunkowe w funkcjach 4.5 Zadania", " 4 Wyrażenia warunkowe Języki programowania opierają się o dwa podstawowe narzędzia pozwalające na sterowanie przepływem operacji. Są to wyrażenia warunkowe oraz pętle. Wyrażenia warunkowe są głównym tematem tego rozdziału, natomiast pętle są omówione w rozdziale 8. Celem wyrażeń warunkowych jest wykonywanie różnego kodu w zależności od danych wejściowych. 4.1 Warunki Wyrażenie if opiera się o spełnienie (lub niespełnienie) danego warunku. if (warunek){ jeżeli warunek spełniony to wykonaj operację } temperatura = 5.4 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } #&gt; [1] &quot;Dodatnia&quot; temperatura = -11 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } Warunek if można też tworzyć w uproszczonej formie: if (warunek) spelniony else niespelniony 4.2 Warunki zagnieżdzone Działanie wyrażenia if może być połączone z dodatkowymi wyrażeniami else if oraz else. temperatura = 8.8 if (temperatura &gt; 0) { &quot;Dodatnia&quot; } else if (temperatura &lt; 0) { &quot;Ujemna&quot; } else { &quot;Zero&quot; } #&gt; [1] &quot;Dodatnia&quot; 4.3 Operatory porównania Tabela 4.1: Operatory porównania Operator Wyjaśnienie == Równy != Nie równy %in% Zawiera się w &gt;, &lt; Większy/Mniejszy niż &gt;=, &lt;= Większy/Mniejszy niż lub równy Tabela 4.2: Operatory porównania Operator Wyjaśnienie ! Negacja (nie) &amp;&amp; Koniunkcja (i) || Alternatywa (lub) 4.4 Wyrażenia warunkowe w funkcjach pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.&quot;)) } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. pogoda = function(temperatura){ if (is.numeric(temperatura)){ cat(paste(&quot;Dzisiaj jest&quot;, temperatura, &quot;stopni Celsjusza.\\n&quot;)) if (temperatura &lt; 5){ cat(&quot;Ubierz się ciepło!&quot;) } } else { cat(&quot;Dzisiaj nie mamy pomiarów temperatury.&quot;) } } pogoda(10) #&gt; Dzisiaj jest 10 stopni Celsjusza. pogoda(-20) #&gt; Dzisiaj jest -20 stopni Celsjusza. #&gt; Ubierz się ciepło! pogoda(NA) #&gt; Dzisiaj nie mamy pomiarów temperatury. 4.5 Zadania "],
["proste-obiekty.html", "5 Proste obiekty 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów 5.3 Podstawowe funkcje 5.4 Brakujące wartości 5.5 Wydzielanie 5.6 Wydzielanie i przypisanie 5.7 Modyfikowanie obiektów 5.8 … 5.9 Zadania", " 5 Proste obiekty Więcej informacji na temat podstawowych typów obiektów można znaleźć w rozdziale “Vectors” książki Advanced R (Wickham 2014). 5.1 Działania na obiektach (wektoryzacja) 5.2 Typy obiektów Obiekty w R można podzielić na proste (homogeniczne) i złożone (heterogeniczne). Do podstawowych prostych obiektów należą wektory (ang. vector) i macierze (ang. matrix), natomiast listy (ang. list) i ramki danych (ang. data frame) to obiekty złożone. W tym rozdziale skupimy się na wektorach. Pozostałe podstawowe typy obiektów są omówione w rozdziale 7. Wektor może przyjmować jeden z czterech typów6: logiczny (ang. logical) wek_log = c(TRUE, FALSE) wek_log #&gt; [1] TRUE FALSE liczba całkowita (ang. interger) wek_cal = c(5L, -7L) wek_cal #&gt; [1] 5 -7 liczba zmiennoprzecinkowa (ang. double)7 wek_zmi = c(5.3, -7.1) wek_zmi #&gt; [1] 5.3 -7.1 znakowy (ang. character) wek_zna = c(&quot;kot&quot;, &quot;pies&quot;) wek_zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; 5.3 Podstawowe funkcje str(wek_zmi) #&gt; num [1:2] 5.3 -7.1 typeof(wek_zmi) #&gt; [1] &quot;double&quot; length(wek_zmi) #&gt; [1] 2 names(wek_zmi) #&gt; NULL names(wek_zmi) = c(&quot;a&quot;, &quot;b&quot;) wek_zmi #&gt; a b #&gt; 5.3 -7.1 names(wek_zmi) #&gt; [1] &quot;a&quot; &quot;b&quot; rep(wek_zmi, 4) #&gt; a b a b a b a b #&gt; 5.3 -7.1 5.3 -7.1 5.3 -7.1 5.3 -7.1 seq(1, 12, by = 2) #&gt; [1] 1 3 5 7 9 11 5.4 Brakujące wartości Wyobraź sobie, że wykonujesz codziennie o 12:00 pomiar temperatury. temperatura = c(8.2, 10.3, 12.0) Czwartego dnia twój termometr się popsuł i nie można było wykonać pomiaru. Co należałoby w takim razie zrobić? Możnaby pominąć ten pomiar, naprawić termometr i wykonać pomiar kolejnego dnia. Wówczas jednak mielibyśmy cztery wartości dla pięciu dni. Inną możliwą opcją byłoby użycie wartości, która stałaby się kodem wartości brakujących, np. 999. Problemem tego rozwiązania jest to w jaki sposób należałoby, np. wyliczyć średnią w tym obiekcie. temperatura = c(8.2, 10.3, 12.0, 999) Najlepszą opcją byłoby wykorzystanie wbudowanego oznaczenia wartości brakujących w R - NA. temperatura = c(8.2, 10.3, 12.0, NA) 5.5 Wydzielanie R posiada trzy podstawowe operatory wydzielania (ang. subsetting) - [], [[]] oraz $, które działają w różny sposób w zależności od tego czy wydzielamy wektory, macierze, ramki danych czy listy. W tym rozdziale skupimy się na wydzielaniu elementów z wektora przy użyciu operatora []. Więcej na temat wydzielania innych obiektów można znaleźć w rozdziale 7. Wydzielanie wektorów używając operatora [] może odbywać się używając jednego z poniższych zapytań: Na podstawie pozycji Na podstawie wektora logicznego Na podstawie nazwy Używając elementu pustego Używając zera temperatura[c(1, 3)] #&gt; [1] 8.2 12.0 temperatura[-c(2, 4)] #&gt; [1] 8.2 12.0 temperatura[c(TRUE, FALSE, TRUE, FALSE)] #&gt; [1] 8.2 12.0 temperatura[temperatura &gt; 10] #&gt; [1] 10.3 12.0 NA names(temperatura) = c(&quot;Poniedziałek&quot;, &quot;Wtorek&quot;, &quot;Środa&quot;, &quot;Czwartek&quot;) temperatura #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[c(&quot;Wtorek&quot;, &quot;Czwartek&quot;)] #&gt; Wtorek Czwartek #&gt; 10.3 NA temperatura[] #&gt; Poniedziałek Wtorek Środa Czwartek #&gt; 8.2 10.3 12.0 NA temperatura[0] #&gt; named numeric(0) 5.6 Wydzielanie i przypisanie 5.7 Modyfikowanie obiektów 5.7.1 Łączenie podstawowych typów obiektów c(temperatura, temperatura) #&gt; Poniedziałek Wtorek Środa Czwartek Poniedziałek #&gt; 8.2 10.3 12.0 NA 8.2 #&gt; Wtorek Środa Czwartek #&gt; 10.3 12.0 NA Właściwością wektora jest to, że może on przyjmować tylko jeden typ. Próba stworzenia obiektu składającego się z wielu typów spowoduje wymuszenie (ang. coercion) do najbliższego możliwego typu. Odbywa się to zgodnie z zasadą: logiczny -&gt; liczba całkowita -&gt; liczba zmiennoprzecinkowa -&gt; znakowy. FALSE #&gt; [1] FALSE c(FALSE, 0L) #&gt; [1] 0 0 c(FALSE, 0L, 3.1) #&gt; [1] 0.0 0.0 3.1 c(FALSE, 0L, 3.1, &quot;kot&quot;) #&gt; [1] &quot;FALSE&quot; &quot;0&quot; &quot;3.1&quot; &quot;kot&quot; 5.8 … 5.8.1 Zmiana typów obiektów Do zmiany typu obiektu służą funkcje as.logical(), as.integer(), as.double(), oraz as.character()8. as.logical(c(&quot;FALSE&quot;, &quot;TRUE&quot;)) # znakowy na logiczny #&gt; [1] FALSE TRUE as.integer(c(&quot;3&quot;, &quot;2&quot;)) # znakowy na liczba całkowita #&gt; [1] 3 2 as.double(c(3L, 2L)) # liczba całkowita na liczba zmiennoprzecinkowa #&gt; [1] 3 2 as.character(c(3L, 2L)) # liczba całkowita na znakowy #&gt; [1] &quot;3&quot; &quot;2&quot; 5.9 Zadania Bibliografia "],
["tekst.html", "6 Tekst 6.1 Łączenie tekstu 6.2 Postawowe operacje na tekście 6.3 Wydzielanie tekstu 6.4 Wyrażenia regularne 6.5 Wyrażenia regularne (wydzielanie tekstu) 6.6 Wyrażenia regularne (zamiana tekstu) 6.7 Wyszukiwanie plików 6.8 Zadania", " 6 Tekst Więcej na temat przetwarzania tekstu można znaleźć w rozdziale “Strings” książki R for Data Science (Grolemund and Wickham 2016). Typ znakowy jest określany poprzez użycie cudzysłowia &quot; lub '. Ważne tutaj jest, aby rozpoczynać i kończyć tekst tym samym cudzysłowiem. t1 = &quot;kot&quot; t2 = &#39;pies&#39; t3 = &#39;&quot;W teorii, teoria i praktyka są tym samym. W praktyce, nie są.&quot; - Yogi Berra&#39; W momencie, gdy tekst nie będzie kończył się cudzysłowiem, wykonanie kodu jest niemożliwe. Wówczas zamiast znaku &gt;, oznaczającego nową linię wykonywanego kodu, pojawi się znak +. Oznacza on, że wykonanie kodu nie może zostać zakończone. &gt; &quot;Mój pierwszy alfabet + + W takiej sytuacji należy nacisnąć klawisz Esc, aby przerwać wykonywanie operacji, a następnie poprawić wpisany kod. 6.1 Łączenie tekstu paste(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;t o k o t&quot; paste0(&quot;t&quot;, &quot;o&quot;, &quot; &quot;, &quot;k&quot;, &quot;o&quot;, &quot;t&quot;) #&gt; [1] &quot;to kot&quot; imie = &quot;Olek&quot; wiek = 7 tekst1 = paste(imie, &quot;ma&quot;, wiek, &quot;lat.&quot;) tekst1 #&gt; [1] &quot;Olek ma 7 lat.&quot; 6.2 Postawowe operacje na tekście library(stringr) toupper(tekst1) #&gt; [1] &quot;OLEK MA 7 LAT.&quot; tolower(tekst1) #&gt; [1] &quot;olek ma 7 lat.&quot; tekst2 = c(&quot;chronologia&quot;, &quot;alfabet&quot;, &quot;hałas&quot;) str_sort(tekst2, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; str_sort(tekst2, locale = &quot;cs&quot;) #&gt; [1] &quot;alfabet&quot; &quot;hałas&quot; &quot;chronologia&quot; tekst3 = c(&quot;chronologia &quot;, &quot;alfabet&quot;, &quot; hałas&quot;) str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot; hałas&quot; &quot;alfabet&quot; &quot;chronologia &quot; tekst3 = str_trim(tekst3) tekst3 #&gt; [1] &quot;chronologia&quot; &quot;alfabet&quot; &quot;hałas&quot; str_sort(tekst3, locale = &quot;pl&quot;) #&gt; [1] &quot;alfabet&quot; &quot;chronologia&quot; &quot;hałas&quot; 6.3 Wydzielanie tekstu str_sub(tekst1, start = 1, end = 4) #&gt; [1] &quot;Olek&quot; str_sub(tekst1, start = 9, end = 14) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = 9, end = -1) #&gt; [1] &quot;7 lat.&quot; str_sub(tekst1, start = -6, end = -1) #&gt; [1] &quot;7 lat.&quot; 6.4 Wyrażenia regularne Wyrażenia regularne (ang. regular expressions), często określane jako regex to sposób opisywanie wzorców tekstu. Używając wyrażeń regularnych możliwe jest, między innymi, znajdowanie tekstu lub zamienienie, który spełnia wymagane warunki. Wyrażenia regularne są powszechnie używane w wyszukiwarkach internetowych, edytorach tekstu, oraz wielu językach programowania. tekst4 = c(&quot;Magdalena&quot;, &quot;Lena&quot;, &quot;1Lena.csv&quot;, &quot;LLena&quot;, &quot;Helena&quot;, &quot;Anna&quot;, 99) str_detect(tekst4, &quot;Lena&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, &quot;lena&quot;) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE Tabela 6.1: Metaznaki w wyrażeniach regularnych Operator Wyjaśnienie ^ Określa początek tekstu/linii $ Określa koniec testu/linii () Grupowanie | Alternatywa (lub) [] Wymienia dozwolone znaki [^] Wymienia niedozwolone znaki * Poprzedni znak zostanie wybrany zero lub więcej razy + Poprzedni znak zostanie wybrany jeden lub więcej razy ? Poprzedni znak zostanie wybrany zero lub jeden raz {n} Poprzedni znak zostanie wybrany n razy . Jakikolwiek znak oprócz nowej linii () \\ Pozwala na użycie specjalnych znaków Wymienione powyżej znaki (np. ^ czy .) określane są jako metaznaki (ang. metacharacters) i mają one specjalne znaczenie. W związku z tym, jeżeli chcemy wyszukać tekstu zawierającego specjalny znak, musimy użyć ukośnik wsteczny (\\, ang. backslash). Istnieje wiele dodatkowych znaków specjalnych, np. \\n - nowa linia, \\t - tabulator, \\d - każdy znak numeryczny (stałoprzecinkowy), \\s - znak niedrukowalny, np. spacja, tabulator, nowa linia. str_detect(tekst4, pattern = &quot;^L&quot;) #&gt; [1] FALSE TRUE FALSE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;ena$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE FALSE FALSE str_detect(tekst4, pattern = &quot;(ena|nna)$&quot;) #&gt; [1] TRUE TRUE FALSE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[a-zA-Z]&quot;) #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE FALSE str_detect(tekst4, pattern = &quot;[0-9]&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE str_detect(tekst4, pattern = &quot;L+&quot;) #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE FALSE str_detect(tekst4, pattern = &quot;^[^L]+&quot;) #&gt; [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE &gt;str_detect(tekst4, pattern = &quot;\\.&quot;) #&gt; Error: &#39;\\.&#39; is an unrecognized escape in character string starting &quot;&quot;\\.&quot; str_detect(tekst4, pattern = &quot;\\\\.&quot;) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE # str_detect(tekst4, pattern = &quot;&quot;) y = c(&quot;kołdra&quot;, &quot;kordła&quot;, &quot;pościel&quot;) str_detect(y, pattern = &quot;ko(łdr|rdł)a&quot;) 6.5 Wyrażenia regularne (wydzielanie tekstu) # str_extract() 6.6 Wyrażenia regularne (zamiana tekstu) # str_replace() Umiejętności używania wyrażeń regularnych można trenować używając różnych zasobów internetowych, np. strony https://regexr.com/ lub https://regex101.com/. 6.7 Wyszukiwanie plików 6.8 Zadania Bibliografia "],
["zlozone-obiekty.html", "7 Złożone obiekty 7.1 Macierze 7.2 Ramki danych 7.3 Listy 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania", " 7 Złożone obiekty 7.1 Macierze Macierze (ang. matrix), podobnie jak wektory, są obiektami homogenicznymi - jedna macierz może przyjmować dane tylko jednego typu. 7.1.1 Tworzenie macierz1 = matrix(1:12, ncol = 3, nrow = 4) macierz1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 macierz2 = matrix(1:12, ncol = 3, nrow = 4, byrow = TRUE) macierz2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 7.1.2 Podstawowe funkcje class(macierz2) #&gt; [1] &quot;matrix&quot; str(macierz2) #&gt; int [1:4, 1:3] 1 4 7 10 2 5 8 11 3 6 ... typeof(macierz2) #&gt; [1] &quot;integer&quot; ncol(macierz2) #&gt; [1] 3 nrow(macierz2) #&gt; [1] 4 colnames(macierz2) #&gt; NULL colnames(macierz2) = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) macierz2 #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 colnames(macierz2) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 7.1.3 Wydzielanie Podobnie jak w przypadku wektorów (5), macierze można wydzielać używając operatora []. W tym wypadku odbywa się to jednak na w oparciu o dwa indeksy - jeden dla wiersza, drugi dla kolumny - [wiersz, kolumna]. macierz2[c(1, 2), c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 macierz2[c(1, 2), ] #&gt; a b c #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 macierz2[, c(1, 3)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(TRUE, FALSE, TRUE)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 macierz2[, c(&quot;a&quot;, &quot;c&quot;)] #&gt; a c #&gt; [1,] 1 3 #&gt; [2,] 4 6 #&gt; [3,] 7 9 #&gt; [4,] 10 12 7.1.4 Łączenie macierz3 = cbind(macierz1, macierz2) macierz3 #&gt; a b c #&gt; [1,] 1 5 9 1 2 3 #&gt; [2,] 2 6 10 4 5 6 #&gt; [3,] 3 7 11 7 8 9 #&gt; [4,] 4 8 12 10 11 12 macierz4 = rbind(macierz1, macierz2) macierz4 #&gt; a b c #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [5,] 1 2 3 #&gt; [6,] 4 5 6 #&gt; [7,] 7 8 9 #&gt; [8,] 10 11 12 7.2 Ramki danych Ramki danych (ang. data frame) mają dużo podobieństw z macierzami. Są to obiekty dwuwymiarowe, składające się z kolumn i wierszy. Główną różnicą pomiędzy macierzą a ramką danych jest to, że pierwsza z nich przyjmuje tylko dane jednego typu, podczas gdy druga może się składać z danych róznych typów. Ramka danych jest zbudowana z kolumn (wektorów) o równej długości. 7.2.1 Tworzenie ramka1 = data.frame(wek_log = c(TRUE, FALSE, FALSE), wek_cal = c(5L, -7L, 12L), wek_zmi = c(5.3, -7.1, 1.1), wek_zna = c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;), stringsAsFactors = FALSE) ramka1 #&gt; wek_log wek_cal wek_zmi wek_zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.2 Podstawowe funkcje class(ramka1) #&gt; [1] &quot;data.frame&quot; str(ramka1) #&gt; &#39;data.frame&#39;: 3 obs. of 4 variables: #&gt; $ wek_log: logi TRUE FALSE FALSE #&gt; $ wek_cal: int 5 -7 12 #&gt; $ wek_zmi: num 5.3 -7.1 1.1 #&gt; $ wek_zna: chr &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; ncol(ramka1) #&gt; [1] 4 nrow(ramka1) #&gt; [1] 3 colnames(ramka1) #&gt; [1] &quot;wek_log&quot; &quot;wek_cal&quot; &quot;wek_zmi&quot; &quot;wek_zna&quot; colnames(ramka1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) ramka1 #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec colnames(ramka1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.2.3 Wydzielanie Do wydzielania elementów z ramki danych może służyć, między innymi, operator $, operator [] oraz funkcja subset(). Operator $ pozwala na wybranie zmiennej (kolumny) na podstawie jej nazwy. ramka1$zmi #&gt; [1] 5.3 -7.1 1.1 ramka1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; W przypadku ramek danych operator [] wymaga podania dwóch argumentów - jednego dla wierszy (obserwacji) oraz jednego dla kolumn (zmiennych) - [wiersze, kolumny]. ramka1[c(1, 3), c(1, 2)] #&gt; log cal #&gt; 1 TRUE 5 #&gt; 3 FALSE 12 Do wydzielania można też wykorzystać operatory logiczne: ==, %in%, !=, &gt;, &gt;=, &lt;, &lt;=, &amp;, |. ramka1[c(1, 3), ramka1$zmi &gt; 0] #&gt; log zmi zna #&gt; 1 TRUE 5.3 kot #&gt; 3 FALSE 1.1 nosorożec ramka1[ramka1$zna == &quot;kot&quot;, ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot ramka1[ramka1$zna %in% c(&quot;kot&quot;, &quot;pies&quot;), ] #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies ramka1[ramka1$cal &gt; 6 | ramka1$cal &lt; -6, ] #&gt; log cal zmi zna #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec 7.2.4 Łączenie ramka2 = data.frame(zmi2 = c(4.3, 2.6, 7.4)) ramka2 #&gt; zmi2 #&gt; 1 4.3 #&gt; 2 2.6 #&gt; 3 7.4 cbind(ramka1, ramka2) #&gt; log cal zmi zna zmi2 #&gt; 1 TRUE 5 5.3 kot 4.3 #&gt; 2 FALSE -7 -7.1 pies 2.6 #&gt; 3 FALSE 12 1.1 nosorożec 7.4 ramka3 = data.frame(log = TRUE, cal = 2L, zmi = 2.3, zna = &quot;żółw&quot;) ramka3 #&gt; log cal zmi zna #&gt; 1 TRUE 2 2.3 żółw rbind(ramka1, ramka3) #&gt; log cal zmi zna #&gt; 1 TRUE 5 5.3 kot #&gt; 2 FALSE -7 -7.1 pies #&gt; 3 FALSE 12 1.1 nosorożec #&gt; 4 TRUE 2 2.3 żółw 7.3 Listy 7.3.1 Tworzenie lista1 = list(c(TRUE, FALSE), c(5L, -7L), c(5.3), c(&quot;kot&quot;, &quot;pies&quot;, &quot;nosorożec&quot;)) lista1 #&gt; [[1]] #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]] #&gt; [1] 5 -7 #&gt; #&gt; [[3]] #&gt; [1] 5.3 #&gt; #&gt; [[4]] #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.2 Podstawowe funkcje class(lista1) #&gt; [1] &quot;list&quot; str(lista1) #&gt; List of 4 #&gt; $ : logi [1:2] TRUE FALSE #&gt; $ : int [1:2] 5 -7 #&gt; $ : num 5.3 #&gt; $ : chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; length(lista1) #&gt; [1] 4 names(lista1) = c(&quot;log&quot;, &quot;cal&quot;, &quot;zmi&quot;, &quot;zna&quot;) lista1 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; names(lista1) #&gt; [1] &quot;log&quot; &quot;cal&quot; &quot;zmi&quot; &quot;zna&quot; 7.3.3 Łączenie lista2 = c(lista1, lista1) lista2 #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; $log #&gt; [1] TRUE FALSE #&gt; #&gt; $cal #&gt; [1] 5 -7 #&gt; #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista3 = list(lista1, lista1) lista3 #&gt; [[1]] #&gt; [[1]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[1]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[1]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[1]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$log #&gt; [1] TRUE FALSE #&gt; #&gt; [[2]]$cal #&gt; [1] 5 -7 #&gt; #&gt; [[2]]$zmi #&gt; [1] 5.3 #&gt; #&gt; [[2]]$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.3.4 Wydzielanie lista4 = lista1[c(1, 2)] str(lista4) #&gt; List of 2 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 lista5 = lista1[[c(4)]] str(lista5) #&gt; chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista6 = lista3[[c(2)]] str(lista6) #&gt; List of 4 #&gt; $ log: logi [1:2] TRUE FALSE #&gt; $ cal: int [1:2] 5 -7 #&gt; $ zmi: num 5.3 #&gt; $ zna: chr [1:3] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1[c(&quot;zmi&quot;, &quot;zna&quot;)] #&gt; $zmi #&gt; [1] 5.3 #&gt; #&gt; $zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; lista1$zna #&gt; [1] &quot;kot&quot; &quot;pies&quot; &quot;nosorożec&quot; 7.4 Zamiany klas 7.5 Własne klasy 7.6 Zadania "],
["petle.html", "8 Powtarzanie 8.1 Pętla for 8.2 Pętla while 8.3 Programowanie funkcyjne 8.4 Zadania", " 8 Powtarzanie 8.1 Pętla for for (element in wektor) { przetwarzanie elementu } odl_mile = c(142, 63, 121) for (i in odl_mile) { print(i * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 for (i in 1:3) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { print(odl_mile[i] * 1.609) } #&gt; [1] 228 #&gt; [1] 101 #&gt; [1] 195 odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_mile[i] = odl_mile[i] * 1.609 } odl_mile #&gt; [1] 228 101 195 odl_km = vector(&quot;numeric&quot;, length = 0) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km = c(odl_km, odl_mile[i] * 1.609) } odl_km #&gt; [1] 368 163 313 odl_mile = c(142, 63, 121) odl_km = vector(&quot;numeric&quot;, length = length(odl_mile)) odl_mile_l = seq_along(odl_mile) for (i in odl_mile_l) { odl_km[i] = odl_mile[i] * 1.609 } odl_km #&gt; [1] 228 101 195 8.2 Pętla while 8.3 Programowanie funkcyjne 8.4 Zadania "],
["io.html", "9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy 9.2 Zadania", " 9 Wczytywanie i zapisywanie plików 9.1 Folder roboczy Folder roboczy (ang. working directory) to miejsce na dysku, w którym aktualnie pracujemy. Folder roboczy można sprawdzić korzystając z funkcji getwd(): getwd() #&gt; [1] &quot;/home/travis/build/Nowosad/elp&quot; Zmienić folder roboczy można za pomocą skrótu Ctrl+Shift+H w RStudio (inaczej Session -&gt; Set Working Directory -&gt; Choose Directory..) lub też funkcji setwd(): setwd(&quot;home/jakub/Documents/progr/&quot;) #unix setwd(&quot;C:/Users/jakub/Documenty/progr/&quot;) #windows Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki. Znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami. Ścieżka względna … Ścieżka bezwzględna … 9.2 Zadania "],
["zlozone-funkcje.html", "10 Złożone funkcje 10.1 Zadania", " 10 Złożone funkcje 10.1 Zadania "],
["analiza-kodu.html", "11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie", " 11 Analiza kodu 11.1 Benchmarking 11.2 Profiling 11.3 Wektoryzacja kodu 11.4 Zadanie "],
["kontrola-wersji.html", "12 Kontrola wersji 12.1 Zadania", " 12 Kontrola wersji 12.1 Zadania "],
["tworzenie-pakietow.html", "13 Tworzenie pakietów 13.1 Zadania", " 13 Tworzenie pakietów 13.1 Zadania "],
["lacznik.html", "14 Łącznik 14.1 Zadania", " 14 Łącznik 14.1 Zadania "],
["debugging.html", "15 Debugowanie 15.1 Zadania", " 15 Debugowanie 15.1 Zadania "],
["podsumowanie.html", "16 Podsumowanie", " 16 Podsumowanie "],
["bibliografia.html", "Bibliografia", " Bibliografia "]
]
