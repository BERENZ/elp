# Złożone obiekty {#zlozone-obiekty}

W rozdziale \@ref(proste-obiekty) omówiono wektory atomowe, które są obiektami jednowymiarowymi zawierającymi tylko jeden typ danych.
Ten rozdział jest poświęcony pozostałymi trzema podstawowymi klasami obiektów w R - macierzami, ramkami danych i listami (sekcje \@ref(macierze), \@ref(df), i \@ref(listy)).

## Macierze

Macierze (ang. *matrix*), podobnie jak wektory, są obiektami homogenicznymi - jedna macierz może przyjmować dane tylko jednego typu.
Od wektorów różnią się jednak tym, że są dwuwymiarowe - wartości ułożone są w kolejnych wierszach i kolumnach.
Macierze są używane do różnorodnych obliczeń matematycznych i statystycznych.
W uproszczeniu można o nich myśleć jako o reprezentacji komputerowej zdjęcia lub mapy.

```{block2 type="rmdinfo"}
W R istnieją też wielowiarowe obiekty podobne do macierzy zwane matrycami (ang. *array*).
```

### Tworzenie

Tworzenie macierzy odbywa się poprzez użycie funkcji `matrix()`, która przyjmuje wartości wektora jako pierwszy argument, a następnie informacje o wymiarach w postaci liczby wierszy (`nrow`) i liczby kolumn (`ncol`).

```{r}
macierz1 = matrix(1:12, nrow = 4, ncol = 3)
macierz1
```

Domyślnie w R wartości wpisywane są do macierzy do kolejnych kolumn startując od lewej strony.
Możliwe jest jednak ustawienie argumentu `byrow = TRUE` co powoduje wpisywanie podanych wartości dla kolejnych wierszy zamiast kolejnych kolumn.

```{r}
macierz2 = matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE)
macierz2
```

### Podstawowe funkcje

Sprawdzenie jakiej klasy jest podany obiekt odbywa się używając funkcji `class()`.

```{r}
class(macierz2)
```

Więcej informacji na temat obiektu można poznać używając funkcji `str()`. 
Jej działanie na macierzy jest bardzo podobne do wyniku na wektorach (zobacz sekcję \@ref(pf-vector)) - wyświetlony zostaje typ obiektu (np. `int`), jego wymiary (np. `[1:4, 1:3]`) i kilka przykładowych wartości (np. `1 4 7 10 2 5 8 11 3 6`).

```{r}
str(macierz2)
```

Macierz może przyjmować tylko jeden typ obiektów, co można sprawdzić używając funkcji `typeof()`.

```{r}
typeof(macierz2)
```

Wektory atomowe mają tylko jeden wymiar więc ich długość oznacza liczbę elementów i może być sprawdzona używając funkcji `length()`.
W przypadku macierzy możliwe jest dodatowo sprawdzenie liczby występujących wierszy (`nrow`) i kolumn (`ncol`).

```{r}
nrow(macierz2)
ncol(macierz2)
```

Domyślnie macierze nie zawierają nazw kolumn ani wierszy.

```{r}
colnames(macierz2)
```

Sprawdzenie czy dodanie nazw kolumn jest jednak możliwe używając funkcji `colnames()`.
Może to pozwolić w przyszłości na wydzielanie konkretnych wartości na podstawie nazw kolumn.

```{r}
colnames(macierz2) = c("a", "b", "c")
macierz2
colnames(macierz2)
```

<!-- `rownames()` - info about problems with rownames (block) -->

### Wydzielanie

Podobnie jak w przypadku wektorów (rozdział \@ref(proste-obiekty)), macierze można wydzielać używając operatora `[]`.
W tym wypadku odbywa się to jednak w oparciu o dwa indeksy - jeden dla wiersza, drugi dla kolumny - `[wiersz, kolumna]`.

Przykładowo, poniżej zostaną wybrane tylko wartości znajdujące się w pierwszy i drugim wierszy oraz pierwszej i trzeciej kolumnie.

```{r}
macierz2[c(1, 2), c(1, 3)]
```

Do wydzielania macierzy czy ramek danych też często przydatne jest używanie elementu pustego.
Pozwala on na wybór wszystkich wartości w danym wymiarze.
Na poniższy przykładzie zostały wybrane wiersze jeden i dwa oraz, z uwagi na element pusty, wszystkie kolumny.

```{r}
macierz2[c(1, 2), ]
```

Element pusty można też zastosować do wybrania wszystkich wierszy.

```{r}
macierz2[, c(1, 3)]
```

Wszystkie pozostałe sposoby wydzielania opisane dla wektorów w sekcji \@ref() działają również na macierzach.
Możeliwe jest więc używanie wektora logicznego czy nazw kolumn.

```{r}
macierz2[, c(TRUE, FALSE, TRUE)]
macierz2[, c("a", "c")]
```

### Łączenie

Łączenie wektorów odbywa się używając jednej funkcji `c()`. 
W przypadku macierzy występują jednak dwa wymiary - możliwe jest połączenie macierzy wierszami lub kolumnami.
W efekcie istnieją do tego dwie oddzielne funkcje `rbind()` i `cbind()`.

Pierwsza z nich łączy macierze wierszami.

```{r}
macierz3 = rbind(macierz1, macierz2)
macierz3
```

Druga dokleja obiekty kolumnami.

```{r}
macierz4 = cbind(macierz1, macierz2)
macierz4
```

```{block2 type="rmdinfo"}
W przypadku, gdy chcemy połączyć kilka wektorów różnych typów działają dokładnie takie same reguły jak w przypadku wektorów atomowych (sekcja \@ref(lpto-vector)).
```

## Ramki danych {#df}

Ramki danych (ang. *data frame*) mają dużo podobieństw z macierzami. 
Są to obiekty dwuwymiarowe, składające się z kolumn i wierszy. 
Główną różnicą pomiędzy macierzą a ramką danych jest to, że pierwsza z nich przyjmuje tylko dane jednego typu, podczas gdy druga może się składać z danych róznych typów.

Ramka danych jest zbudowana z kolumn (wektorów) o równej długości.
<!-- a data frame is a list of equal-length vectors -->
Ten typ obiektu jest głównie wykorzystywany do różnorodnej analizy danych. 
Ramki danych przypominają w swojej strukturze arkusze kalkulacyjne czy bazy danych.
<!-- nested data frames footnote -->

### Tworzenie

Stworzenie nowej ramki danych możliwe jest używając funkcji `data.frame()`, w której podawane są nazwy kolejnych kolumn (np. `wek_log`) oraz ich wartości (np. `c(TRUE, FALSE, FALSE)`).

```{r}
ramka1 = data.frame(wek_log = c(TRUE, FALSE, FALSE),
                    wek_cal = c(5L, -7L, 12L), 
                    wek_zmi = c(5.3, -7.1, 1.1), 
                    wek_zna = c("kot", "pies", "nosorożec"),
                    stringsAsFactors = FALSE)
ramka1
```

W powyższym przykładzie, `ramka1` składa się z czterech kolumn o długości trzy. 
Każda z tych kolumn ma inny typ - logiczny, liczby całkowitej, liczby zmiennoprzecinkowej oraz znakowy.
Domyślnie funkcja `data.frame` wykonuje jeszcze jedną operację w tle - zamienia ona wszystkie dane o type znakowym na typ czynnikowy (sekcja \@ref(fac)).
W większości przypadków nie jest to porządane działanie - dlatego też warto wyłączyć tę konwersję używając argumentu `stringsAsFactors = FALSE`.

```{block2 type="rmdinfo"}
Obiekty klasy ramka danych są też zazwyczaj wynikiem wczytywania zewnętrznych plików do R, np. w formacie `.csv` czy `.xlsx`.
Więcej informacji na ten temat można znaleźć w rozdziale \@ref(io).
```

### Podstawowe funkcje

Oficjalnie klasa ramki danych jest określana jako `data.frame`.

```{r}
class(ramka1)
```

Sprawdzenie struktury ramki danych pozwala na szybkie poznanie kilku róznych cech wejściowego obiektu.
Pierwszą informacją jest klasa obiektu (`data.frame`), liczba wierszy (`3 obs.` - trzy obserwacje) i liczba kolumn (`4 variables` - cztery zmienne).
Następnie, dla kolejnych kolumn są określane ich nazwy, typy danych oraz przykładowe wartości.

```{r}
str(ramka1)
```

Podobnie jak w przypadku macierzy, ramki danych mają dwa wymiary, których długość można sprawdzić używając funkcji `nrow` i `ncol`.

```{r}
nrow(ramka1)
ncol(ramka1)
```

W przeciwieństwie jednak do macierzy, ramki danych zawsze posiadają nazwy kolumn.

```{r}
colnames(ramka1)
```

Ich zmiana również jest możliwa używając funkcji `colnames()`.

```{r}
colnames(ramka1) = c("log", "cal", "zmi", "zna")
ramka1
colnames(ramka1)
```

<!-- `rownames()` - info about problems with rownames (block) -->

### Wydzielanie

Do wydzielania elementów z ramki danych może służyć, między innymi, operator `$`, operator `[]`  oraz funkcja `subset()`.

Operator `$` pozwala na wybranie zmiennej (kolumny) na podstawie jej nazwy.

```{r}
ramka1$zmi
ramka1$zna
```

W przypadku ramek danych operator `[]` wymaga podania dwóch argumentów - jednego dla wierszy (obserwacji) oraz jednego dla kolumn (zmiennych) - `[wiersze, kolumny]`.

```{r}
ramka1[c(1, 3), c(1, 2)]
```

Do wydzielania można też wykorzystać operatory logiczne: `==`, `%in%`, `!=`, `>`, `>=`, `<`, `<=`, `&`, `|`.

```{r}
ramka1[c(1, 3), ramka1$zmi > 0]
```

```{r}
ramka1[ramka1$zna == "kot", ]
```

<!-- block == vs = -->

```{r}
ramka1[ramka1$zna %in% c("kot", "pies"), ]
```

```{r}
ramka1[ramka1$cal > 6 | ramka1$cal < -6, ]
```

<!-- ref to wektor and matrix -->
<!-- wydzielanie i tworzenie -->

### Łączenie

```{r}
ramka2 = data.frame(zmi2 = c(4.3, 2.6, 7.4))
ramka2
```

```{r}
cbind(ramka1, ramka2)
```

```{r}
ramka3 = data.frame(log = TRUE, cal = 2L, zmi = 2.3, zna = "żółw")
ramka3
```

```{r}
rbind(ramka1, ramka3)
```

<!-- info about joins -->
<!-- ref to joins -->

## Listy

### Tworzenie

```{r}
lista1 = list(c(TRUE, FALSE), 
             c(5L, -7L),
             c(5.3), 
             c("kot", "pies", "nosorożec"))
lista1
```

<!-- wielopoziomowe listy -->

### Podstawowe funkcje

```{r}
class(lista1)
```

```{r}
str(lista1)
```

```{r}
length(lista1)
```

```{r}
names(lista1) = c("log", "cal", "zmi", "zna")
lista1
names(lista1)
```

### Łączenie

```{r}
lista2 = c(lista1, lista1)
lista2
```

```{r}
lista3 = list(lista1, lista1)
lista3
```

### Wydzielanie

<!-- `[]` - zawsze lista -->

```{r}
lista4 = lista1[c(1, 2)]
str(lista4)
```

<!-- `[[]]` oraz `$` wyciąganie elementów -->

```{r}
lista5 = lista1[[c(4)]]
str(lista5)
```

```{r}
lista6 = lista3[[c(2)]]
str(lista6)
```

```{r}
lista1[c("zmi", "zna")]
```

```{r}
lista1$zna
```

<!-- https://adv-r.hadley.nz/subsetting.html#lists-1 -->

## Zamiany klas

```{r}
macierz1
```

```{r}
ramka_z_m1 = as.data.frame(macierz1)
ramka_z_m1
```

```{r}
class(macierz1)
```

```{r}
class(ramka_z_m1)
```

```{r}
lista_z_m1 = as.list(macierz1)
lista_z_m1
lista_z_r1 = as.list(ramka_z_m1)
lista_z_r1
```

`as.vector()`, `as.matrix()`, `as.data.frame()`, `as.list()`

## Inne klasy obiektów

```{r}
wek_num = c(4, 6, 8)
```

```{r}
wek_dat = as.Date(c("2019-04-10", "2019-04-12", "2019-04-14"))
```

```{r}
wek_tkt = c("kot", "pies", "nosorożec")
```

```{r}
mean(wek_num)
```

```{r}
mean(wek_dat)
```

```{r}
mean(wek_tkt)
```

```{r}
methods(mean)
```

<!-- https://www.njtierney.com/post/2016/11/06/simple-s3-post/ -->
<!-- ... -->
<!-- Istnieje ogromna liczba klas obiektów w R -->
<!-- Każdy może stworzyć swoją własną klasę! -->
<!-- Różne funkcje wymagają różnych klas obiektów -->
<!-- reference?? -->

## Zadania

1) Stwórz trzy nowe macierze - `ma1`, `ma2`, `ma3` - składające się z trzech wierszy i czterech kolumn.
Macierz `ma1` powinna zawierać wartości od 0 do 11, cała macierz `ma2` powinna składać się tylko z wartości 2, a macierz `ma3` powinna zawierać losowe wartości od 1 do 3 (w stworzeniu losowych wartości może pomóc funkcja `sample()`).
2) Wykonaj podstawowe operacje, takie jak dodawanie, odejmowanie, mnożenie i dzielenie używając macierzy `ma1` oraz `ma2`, a następnie macierzy `ma1` i `ma3`.
Co jest efektem tych obliczeń? 
W jaki sposób działania arytmetyczne są wykonywane na macierzach w R?
3) Wydziel tylko pierwszy wiersz i ostatnią kolumnę macierzy `ma1`.
4) Znajdź wartości macierzy `ma3`, które są większe niż 2.
5) Połącz kolumnami macierz `ma1` i macierz `ma3` tworząc nowy obiekt `ma4`
6) Stwórz nową ramkę danych, `ra1`, która składa się z dwóch kolumn i trzech wierszy.
Pierwsza kolumna `data` zawiera datę z dziś, wczoraj i przedwczoraj, a kolumna `miasto` zawiera nazwę miasta w którym się właśnie znajdujesz.
7) Stwórz nową ramkę danych, `ra2`, która również składa się z dwóch kolumn i trzech wierszy.
Kolumna `tmin` zawiera wartości `5.3`, `4.6`, `2.9`, a kolumna `tmax` zawiera wartości `11.1`, `14.6`, `9`.
8) Połącz dwie stworzone ramki danych `ra1` i `ra2` tworząc obiekt `ra3`. 
Używając obiektu `ra3` wylicz średnią temperaturę dla każdego wiersza i wpisz ją w nową kolumnę `tmean`.
9) Zmień nazwę drugiej kolumny w obiekcie `ra3` na `"tmaks"`, a trzeciej na `"tsr"`.
10) Wyświetl tylko te daty dla których średnia temperatura była wyższa niż 8.
11) Stwórz nową listę, `li1`, która zawiera trzy elementy.
Pierwszy element to wektor liczb od 10 do 0, drugi element to obiekt `ma4`, a trzeci element to obiekt `ra3`.
12) Wydziel z tej listy pierwszy element i nazwij go `wektor_l`.
13) Wylicz średnią wartość z kolumny `"tsr"` z trzeciego elementu listy.
14) Zamień obiekt `ramka1` utworzony w tym rozdziale na macierz. 
Co jest efektem zamiany klasy?
