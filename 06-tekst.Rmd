# Tekst {#tekst}


Więcej na temat przetwarzania tekstu można znaleźć w rozdziale ["Strings"](https://r4ds.had.co.nz/strings.html) książki R for Data Science [@wickham2016r].

Typ znakowy jest określany poprzez użycie cudzysłowia `"` lub `'`.
Ważne tutaj jest, aby rozpoczynać i kończyć tekst tym samym cudzysłowiem.

```{r}
t1 = "kot"
t2 = 'pies'
t3 = '"W teorii, teoria i praktyka są tym samym. W praktyce, nie są." - Yogi Berra'
```

W momencie, gdy tekst nie będzie kończył się cudzysłowiem, wykonanie kodu jest niemożliwe.
Wówczas zamiast znaku `>`, oznaczającego nową linię wykonywanego kodu, pojawi się znak `+`.
Oznacza on, że wykonanie kodu nie może zostać zakończone.

```{r, eval=FALSE}
> "Mój pierwszy alfabet
+
+
```

W takiej sytuacji należy nacisnąć klawisz Esc, aby przerwać wykonywanie operacji, a następnie poprawić wpisany kod.

## Podstawowe operacje na tekście

Jedną z podstawowych operacji na wektorach znakowych jest ich łączenie.
Do tego celu służy funkcja `paste()`^[Odpowiednikiem funkcji `paste()` w pakiecie **stringr** jest funkcja `str_c()`].

```{r}
paste("t", "o", " ", "k", "o", "t")
```

Efekt działania funkcji `paste()` jest jeden wektor tekstowy, który składa się z wejściowych wektorów oddzielonych domyślnie spacjami. 
Funkcja `paste()` ma jednak również dodatkowy argument `sep`, który pozwala na dowolne określanie separatora.
Ostatnim argumentem tej funkcji jest `collapse`, który łączy elementy jednego wektora tekstowego.

R oferuje też uproszczoną postać tej funkcji o nazwie `paste0()`, w której nie ma znaku seperatora.

```{r}
paste0("t", "o", " ", "k", "o", "t")
```

Te funkcje są używane w sytuacjach, gdy chcemy połączyć stały, znany tekst, wraz z tekstem wprowadzanym przez użytkownika lub pochodzącym z innego źródła.
Poniżej stworzono dwie nowe zmienne `imie` i `wiek`, których treść złączono ze słowami `"ma"` i `"lat."`.

```{r}
imie = "Olek"
wiek = 77
tekst1 = paste(imie, "ma", wiek, "lat.")
tekst1
```

Takie konstrukcje są często używane w funkcjach. 
Powyższy przykład możnaby przepisać jako:

```{r}
lata = function(imie, wiek){
  paste(imie, "ma", wiek, "lat.")
}
lata("Asia", 61)
```

Dodatkowo w R istnieje alternatywa dla `paste()` i `paste0()` w postaci funkcji `sprintf()`.



```{r}
toupper(tekst1)
```

```{r}
tolower(tekst1)
```


[@R-stringr]

```{r}
library(stringr)
```


```{r}
tekst2 = c("chronologia ", "alfabet", " hałas")
str_sort(tekst2)
```

```{r}
tekst2 = str_trim(tekst2)
str_sort(tekst2)
```

```{r}
tekst2
```

```{r}
str_sort(tekst2, locale = "pl")
str_sort(tekst2, locale = "cs")
```

## Wydzielanie tekstu

```{r}
str_sub(tekst1, start = 1, end = 4)
```

```{r}
str_sub(tekst1, start = 9, end = 15)
```

```{r}
str_sub(tekst1, start = 9, end = -1)
```

```{r}
str_sub(tekst1, start = -7, end = -1)
```

## Wyrażenia regularne 

<!-- https://github.com/VerbalExpressions/JSVerbalExpressions -->
<!-- https://github.com/richierocks/rebus/blob/master/README.md -->
<!-- https://www.garrickadenbuie.com/project/regexplain/ -->
<!-- https://github.com/kevinushey/rex -->

```{r, echo=FALSE, eval=FALSE}
x = c("Regular expression", "Regexp", "Regex")
str_detect(x, "^Reg(exp?|ular expression)$")
```

Wyrażenia regularne (ang. *regular expressions*), często określane jako *regex* to sposób opisywanie wzorców tekstu. 
Używając wyrażeń regularnych możliwe jest, między innymi, znajdowanie tekstu lub zamienienie, który spełnia wymagane warunki.
Wyrażenia regularne są powszechnie używane w wyszukiwarkach internetowych, edytorach tekstu, oraz wielu językach programowania.

<!-- basic stuff -->

```{r}
tekst4 = c("Magdalena", "Lena", "1Lena.csv", "LLena", "Helena", "Anna", 99)
```

```{r}
str_detect(tekst4, "Lena")
```

```{r}
str_detect(tekst4, "lena")
```

```{r regexoperators, echo=FALSE}
library(tibble)
roperators = c("^", 
               "$", "()", 
               "|", "[]", 
               "[^]",
               "*", "+", 
               "?", "{n}", 
               ".", "\\\\"
               )

roperators_exp = c("Określa początek tekstu/linii",
                   "Określa koniec testu/linii", "Grupowanie",
                   "Alternatywa (lub)", "Wymienia dozwolone znaki",
                   "Wymienia niedozwolone znaki",
                   "Poprzedni znak zostanie wybrany zero lub więcej razy", 
                   "Poprzedni znak zostanie wybrany jeden lub więcej razy", 
                   "Poprzedni znak zostanie wybrany zero lub jeden raz", 
                   "Poprzedni znak zostanie wybrany n razy", 
                   "Jakikolwiek znak oprócz nowej linii (\\n)",
                   "Pozwala na użycie specjalnych znaków")
knitr::kable(tibble(Operator = roperators, Wyjaśnienie = roperators_exp), 
             caption = "Metaznaki w wyrażeniach regularnych",
             booktabs = TRUE)
```

Wymienione powyżej znaki (np. `^`<!--Kareta--> czy `.`) określane są jako metaznaki (ang. *metacharacters*) i mają one specjalne znaczenie.
W związku z tym, jeżeli chcemy wyszukać tekstu zawierającego specjalny znak, musimy użyć ukośnik wsteczny (`\`, ang. *backslash*).
Istnieje wiele dodatkowych znaków specjalnych, np. `\n` - nowa linia, `\t` - tabulator, `\d` - każdy znak numeryczny (stałoprzecinkowy), `\s` - znak niedrukowalny, np. spacja, tabulator, nowa linia.

```{r}
str_detect(tekst4, pattern = "^L")
```

```{r}
str_detect(tekst4, pattern = "ena$")
```

```{r}
str_detect(tekst4, pattern = "(ena|nna)$")
```

```{r}
str_detect(tekst4, pattern = "[a-zA-Z]")
```

```{r}
str_detect(tekst4, pattern = "[0-9]")
```

```{r}
str_detect(tekst4, pattern = "L+")
```

```{r}
str_detect(tekst4, pattern = "^[^L]+")
```

```{r, eval=FALSE}
str_detect(tekst4, pattern = "\.")
#> Error: '\.' is an unrecognized escape in character string starting ""\."
```

```{r}
str_detect(tekst4, pattern = "\\.")
```

<!-- block z popularnymi regex -->

```{r, eval=FALSE}
y = c("kołdra", "kordła", "pościel")
str_detect(y, pattern = "ko(łdr|rdł)a")
```

<!-- https://stringr.tidyverse.org/articles/regular-expressions.html -->
Umiejętności używania wyrażeń regularnych można trenować używając różnych zasobów internetowych, np. strony https://regexr.com/, https://regex101.com/, czy https://regexcrossword.com/.
Pomocne w zrozumieniu bardziej zaawansowanych elementów wyrażeń regularncych może być też prezentacja [Best of Fluent 2012: /Reg(exp){2}lained/: Demystifying Regular Expressions](https://www.youtube.com/watch?v=EkluES9Rvak) oraz książka Mastering Regular Expressions [@friedl2006mastering].
<!-- https://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124/ref=sr_1_1?ie=UTF8&qid=1464113797&sr=8-1&keywords=mastering+regular+expressions -->
<!-- https://www.rstudio.com/resources/cheatsheets/#stringr -->

## Wydzielanie tekstu - regex

<!-- https://r4ds.had.co.nz/strings.html#extract-matches -->

```{r}
tekst_pomiary = "Wrocław: 23, Bydgoszcz: 12, Toruń: 11, Lublin: 14"
```

```{r}
str_extract(tekst_pomiary, pattern = "[a-zA-Z]*")
```

```{r}
str_extract(tekst_pomiary, pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*")
```

```{r}
str_extract_all(tekst_pomiary, pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*")
```

```{r}
str_extract_all(tekst_pomiary, pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+")
```

```{r}
tekst_pomiary2 = "Wrocław: 23, Bydgoszcz: 12, Toruń: 11, Lublin: 14, Gorzów Wielkopolski: 20, Zielona Góra: 19"
```

```{r}
str_extract_all(tekst_pomiary2, pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+")
```

```{r}
str_extract_all(tekst_pomiary2, pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+[\\s]?[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*")
```

```{r}
miasta_pomiary2 = str_extract_all(tekst_pomiary2,
                                  pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+[\\s]?[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*")
miasta_pomiary2
```

## Zamiana tekstu - regex

<!-- https://r4ds.had.co.nz/strings.html#replacing-matches -->

```{r}
tekst_pomiary3 = "Wrocław: 23.5, Bydgoszcz: 12.7, Toruń: 11.1, Lublin: 14.3"
```

```{r}
str_replace(tekst_pomiary3, 
            pattern = ".", 
            replacement = ",")
```

```{r}
str_replace(tekst_pomiary3, 
            pattern = "\\.", 
            replacement = "\\,")
```

```{r}
str_replace_all(tekst_pomiary3, 
                pattern = "\\.", 
                replacement = "\\,")
```

```{r}
tekst_pomiary4 = str_replace_all(tekst_pomiary3,
                                 pattern = "\\,",
                                 replacement = "\\;")
```

```{r}
str_replace_all(tekst_pomiary4, 
                pattern = "\\.", 
                replacement = "\\,")
```

```{r}
str_replace_all(tekst_pomiary4, 
                pattern = "[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]+",
                replacement = "")
```

## Wyszukiwanie plików

```{r}
dir("pliki")
```

```{r}
dir("pliki", pattern = "*\\.png$")
```

```{r}
dir("pliki", pattern = "*\\.(png|jpg)$")
```

```{r}
dir("pliki", pattern = "*\\.(png|jpg)$", full.names = TRUE)
```

```{r}
moje_pliki = dir("pliki", pattern = "*\\.(png|jpg)$", full.names = TRUE)
```

## Zadania

1) Plik tekstowy zawiera listę pomiarów, w której piąty i czwarty znak od końca oznacza symbol chemiczny pomierzonego pierwiastka, przykładowo:
```{r, eval=FALSE}
"TERYT 18; podkarpackie; Rzeszów; 0.2 He; A"
"TERYT 22; pomorskie;	Gdańsk; 12 C ; B"
```
Napisz kod, który będzie wydzielał symbole chemiczne pomierzonych pierwiastków.

2) Napisz funkcję nazywającą się `horoskop`, która przyjmuje dwa argumenty `imie` (pierwsze imię, tekst) oraz `miesiac` (miesiąc urodzin, liczba).
Funkcja ma zwrócić tekst "Osoba o imieniu 'imie' będzie miała jutro szczęście." w przypadku, gdy argument `miesiac` jest liczbą parzystą oraz "Osoba o imieniu 'imie' będzie miała jutro nieszczęście." jeżeli argument `miesiac` jest liczbą nieparzystą.
3) Rozbuduj funkcję `horoskop` poprzez sprawdzenie pierwszej litery podanego imienia. Jeżeli pierwsza litera imienia to `K`, `M`, lub `Z` wówczas wyświetli się zawsze tekst "Osoba o imieniu 'imie' będzie miała jutro szczęście.", bez względu na podany miesiąc.
4) Efektem zbierania pomiarów temperatury okazał być się plik tekstowy, który zawiera datę pomiaru oraz wartość.
W jaki sposób możliwe jest wydzielenie tylko dat w takiej sytuacji?
Poniżej znajduje się fragment przykładowych danych wejściowych.
```{r, eval=FALSE}
"2019-03-11: 23.5, 19/03/12: 12.7, 2019.03.13: 11.1, 2019-marzec-14: 14.3"
```

5) Co należałoby zrobić, aby wydzielić tylko wartości pomiarów w powyższym przypadku?
Stwórz nowy obiekt `wartosci` zawierający te pomiary.
Jakiej klasy powinien być wyjściowy obiekt?
6) Posiadasz wektor `wsp` zawierający współrzedne geograficzne szeregu miast w formacie DMS (Stopnie, Minuty, Sekundy).
Wydziel tylko wartości stopnii z tej reprezentacji.
Poniżej znajduje się fragment przykładowych danych wejściowych.
```{r, eval=FALSE}
wsp = c("52°24′N 16°55′E", "53°08′07″N 23°08′44″E", "39°6′N 84°31′W")
```

7) Stwórz funkcję, która przyjmując przykładowe dane z poprzedniego zadania zamieni współrzędne na format w postaci stopni dziesiętnych (np. `52°24′N` w formacie DMS to `52.4` w stopniach dziesiętnych). 
<!-- match hex colors, examples :#abs, #f0, #BADA55, #COFFEE https://www.youtube.com/watch?v=EkluES9Rvak -->

