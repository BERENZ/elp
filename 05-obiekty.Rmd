# Proste obiekty {#proste-obiekty}

Więcej informacji na temat podstawowych typów obiektów można znaleźć w rozdziale ["Vectors"](https://adv-r.hadley.nz/vectors-chap.html) książki Advanced R [@wickham2014advanced].

## Typy obiektów

Obiekty w R można podzielić na proste (homogeniczne) i złożone (heterogeniczne). 
Do podstawowych prostych obiektów należą wektory (ang. *vector*) i macierze (ang. *matrix*), natomiast listy (ang. *list*) i ramki danych (ang. *data frame*) to obiekty złożone.

W tym rozdziale skupimy się na wektorach.
Pozostałe podstawowe typy obiektów są omówione w rozdziale \@ref(zlozone-obiekty).

## Wektory

Wektor może przyjmować jeden z czterech podstawowych typów^[Do sprawdzania jakiego typu jest wektor służy funkcja `typeof()`.]:

1. logiczny (ang. *logical*)

```{r}
wek_log = c(TRUE, FALSE)
wek_log
```

2. liczba całkowita (ang. *interger*)

```{r}
wek_cal = c(5L, -7L)
wek_cal
```

3. liczba zmiennoprzecinkowa (ang. *double*)^[Liczby zmiennoprzecinkowe mogą być też reprezentowane poprzez notację naukową, np. 11111.2 może być zapisane jako 1.11112e4, a 0.00021 jako 2.1e-4.]

```{r}
wek_zmi = c(5.3, -7.1)
wek_zmi
```

4. znakowy (ang. *character*)

```{r}
wek_zna = c("kot", "pies")
wek_zna
```

<!--ref to style-->
Dodatkowo, istnieją dwa dodatkowe, rzadziej spotykane typy wektorów - czynnikowy (ang. *factor*) i dat (ang. *date*) (sekcja \@ref(facate)).
<!--ref-->


## Właściwości wektorów

Każdy wektor ma trzy właściwości - typ, długość i atrybuty.

```{r}
# typ
typeof(wek_zmi)

# długość
length(wek_zmi)

# atrybuty
attributes(wek_zmi)
```

## Podstawowe funkcje

<!-- metody -->

```{r}
str(wek_zmi)
```

```{r}
names(wek_zmi)
```

```{r}
names(wek_zmi) = c("a", "b")
wek_zmi
```

```{r}
names(wek_zmi)
```

```{r}
rep(wek_zmi, 4)
```

```{r}
seq(1, 12, by = 2)
```

<!-- block - nazwa tekstem -->

<!-- operatory statytyczne -->

## Działania na wektorach

Wiele podstawowych operacji w R jest zwektoryzowana. 
Przykładowo, możliwe jest pomnożenie kolejnych elementów jednego wektora przez kolejne elementy drugiego wektora.

```{r}
a = c(1, 2, 3)
b = c(3, 5, 10)
a * b
```

Kod zapisany w powyższy sposób zajmuje niewiele miejsca i jest łatwy do odczytania.
Alternatywnie możnaby ten problem rozbić na podelementy i je wymnożyć.

```{r}
a1 = 1
a2 = 2
a3 = 3
b1 = 3
b2 = 5
b3 = 10
a1 * b1
a2 * b2
a3 * b3
```

Jak można szybko zaobserwować, mnożenie kolejnych elementów w ten sposób wymaga zapisania znacznie więcej kodu i jest trudniejsze do odczytania.
Jest jeszcze trzecia możliwość użycie pętli (rozdział \@ref(petle)).

```{r}
y = numeric(length = 3)
for (i in 1:3){
  y[i] = a[i] * b[i]
}
y
```

Stworzony kod zajmuje mniej miejsca, ale nadal nie jest on bardzo łatwy do szybkiego zrozumienia.

Wektoryzacja ma też inną zaletę - obliczenia wykonywane w ten sposób są szybkie.
W przypadku stosowania niektórych operacji, np. mnożenia czy dodawania, R wykorzystuje w tle (bez wiedzy użytkownika) zoptymalizowane funkcje zapisane w języku C lub Fortran.
Więcej informacji na temat wektoryzowania kodu można znaleźć w rozdziale \@ref(petle).

## Brakujące wartości

Wyobraź sobie, że wykonujesz codziennie o 12:00 pomiar temperatury.

```{r}
temperatura = c(8.2, 10.3, 12.0)
```

Czwartego dnia twój termometr się popsuł i nie można było wykonać pomiaru.
Co należałoby w takim razie zrobić?

- Możnaby pominąć ten pomiar, naprawić termometr i wykonać pomiar kolejnego dnia. 
Wówczas jednak mielibyśmy cztery wartości dla pięciu dni.
- Inną możliwą opcją byłoby użycie wartości, która stałaby się kodem wartości brakujących, np. 999.
Problemem tego rozwiązania jest to w jaki sposób należałoby, np. wyliczyć średnią w tym obiekcie.

```{r}
temperatura = c(8.2, 10.3, 12.0, 999)
```

- Najlepszą opcją byłoby wykorzystanie wbudowanego oznaczenia wartości brakujących w R - `NA`.

```{r}
temperatura = c(8.2, 10.3, 12.0, NA)
```

<!-- operacje na NA -->
<!-- `is.na()` -->
<!-- na.rm -->
<!-- NULL -->

## Wydzielanie 

R posiada trzy podstawowe operatory wydzielania (ang. *subsetting*) - `[]`, `[[]]` oraz `$`, które działają w różny sposób w zależności od tego czy wydzielamy wektory, macierze, ramki danych czy listy.
W tym rozdziale skupimy się na wydzielaniu elementów z wektora przy użyciu operatora `[]`.
Więcej na temat wydzielania innych obiektów można znaleźć w rozdziale \@ref(zlozone-obiekty).

Wydzielanie wektorów używając operatora `[]` może odbywać się używając jednego z poniższych zapytań:

1. Na podstawie pozycji
2. Na podstawie wektora logicznego
3. Na podstawie nazwy
4. Używając elementu pustego
5. Używając zera

<!-- na podstawie pozycji -->

```{r}
temperatura[c(1, 3)]
```

```{r}
temperatura[-c(2, 4)]
```

<!-- na podstawie wektora logicznego -->

```{r}
temperatura[c(TRUE, FALSE, TRUE, FALSE)]
```

```{r}
temperatura[temperatura > 10]
```

<!-- na podstawie nazwy -->
```{r}
names(temperatura) = c("Poniedziałek", "Wtorek", "Środa", "Czwartek")
temperatura
```

```{r}
temperatura[c("Wtorek", "Czwartek")]
```

<!-- nic -->

```{r}
temperatura[]
```

<!-- zero -->

```{r}
temperatura[0]
```

## Wydzielanie i przypisanie

<!-- ... -->

## Modyfikowanie obiektów

<!-- ... -->

## Łączenie podstawowych typów obiektów

<!-- tekst -->

```{r}
c(temperatura, temperatura)
```

Właściwością wektora jest to, że może on przyjmować tylko jeden typ.
Próba stworzenia obiektu składającego się z wielu typów spowoduje wymuszenie (ang. *coercion*) do najbliższego możliwego typu.
Odbywa się to zgodnie z zasadą: logiczny -> liczba całkowita -> liczba zmiennoprzecinkowa -> znakowy.

```{r}
FALSE
```

```{r}
c(FALSE, 0L)
```

```{r}
c(FALSE, 0L, 3.1)
```

```{r}
c(FALSE, 0L, 3.1, "kot")
```

## ... {#facate}

<!-- factor i date -->
<!-- https://rstudio-education.github.io/hopr/r-objects.html -->

## Zmiana typów obiektów

<!--rzutowanie??-->

Do zmiany typu obiektu służą funkcje `as.logical()`, `as.integer()`, `as.double()`, oraz `as.character()`^[Do sprawdzenia czy dany obiekt należy do wybranego typu służą funkcje `is.logical()`, `is.integer()`,`is.double()`,  oraz `is.character()`.].

```{r}
as.logical(c("FALSE", "TRUE")) # znakowy na logiczny
```

```{r}
as.integer(c("3", "2")) # znakowy na liczba całkowita 
```

```{r}
as.double(c(3L, 2L)) # liczba całkowita na liczba zmiennoprzecinkowa
```

```{r}
as.character(c(3L, 2L)) # liczba całkowita na znakowy
```


## Zadania
