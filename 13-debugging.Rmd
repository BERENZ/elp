# Debugowanie {#debugging}

Używając pakietów i funkcji stworzonych przez inne osoby możemy czasem znaleźć się w sytuacji, gdy zamiast wyniku otrzymujemy komunikat błędu.
Warto wówczas upewnić się czy nie napisaliśmy żadnej literówki i podaliśmy odpowiednie argumenty funkcji.
Konieczne kolejne kroki mogą obejmować sprawdzenie pliku pomocy danej funkcji, czy też skopiowanie najważniejszego fragmentu błędu i wklejenie go do wyszukiwarki internetowej. 
Isnieje szansa, że ktoś już wcześniej napotkał ten problem, zadał pytanie i otrzymał na nie odpowiedź w internecie (np, na https://stackoverflow.com/).

Czasem się może jednak okazać, że odkryliśmy nowy problem - warto go wtedy zgłosić do twórców pakietu.
Wiele pakietów na platformie CRAN zawiera sekcję *BugReports*, gdzie można znaleźć link do zgłaszania błędów.
Przykładowo, pakiet **stringr** jest opisany pod adresem https://cran.r-project.org/package=stringr i w jego sekcji *BugReports* znajduje się odnośnik do https://github.com/tidyverse/stringr/issues.
W przypadku zgłaszania błędów zazwyczaj nie należy pisać bardzo długich opisów czy wklejać cały kod, który został napisany.
Konieczne jest natomiast przygotowanie powtarzalnego przykładu (ang. *reproducible example*), czyli minimalnego kodu możliwego do odtworzenia problemu na innym komputerze (sekcja \@ref(reprex)).
Warto jednak pamiętać, że sekcja *Issue* na platformie Github służy głównie do zgłaszania problemów, a nie do zadawania pytań.
W przypadku potrzeby zadania pytania, lepszym pomysłem jest opublikowanie go na https://stackoverflow.com/,

<!-- https://en.wikipedia.org/wiki/Debugging#/media/File:H96566k.jpg -->

Tworzenie kodu możliwego do odtworzenia problemu (powtarzalnych przykładów) jest też pomocne w przypadku, gdy my piszemy nowe skrypty i funkcje i napotkamy na błędy.
Jest to często część debugowania (ang. *debugging*) - procesu rozwiązywania problemów i błędów w oprogramowaniu.
Istnieje wiele potencjalnych taktyk debugowania kodu, w tym debugowanie używając funkcji takich jak print (sekcja \@ref(debuging-print)), czy też debugowanie interaktywne (sekcja \@ref(debuging-interactive)).

Więcej na temat debugowania kodu w R można dowiedzieć się więcej z prezentacji Jenny Bryan pt. [Object of type 'closure' is not subsettable](https://github.com/jennybc/debugging), [rozdziału Debugging R code] książki @rstatswtf, oraz [rozdziału Debugging] książki @wickham2016r.
Dodatkowo, na stronach [Debugging an R Package with C++](https://blog.davisvaughan.com/2019/04/05/debug-r-package-with-cpp/), [Debugging C/C++ code that interfaces with R](https://github.com/wch/r-debug/blob/master/debugging-r.md), oraz [Debugging with LLDB](http://kevinushey.github.io/blog/2015/04/13/debugging-with-lldb/) można przeczytać na temat debugowania kodu C++ łączącego się z R.

## Powtarzalne przykłady {#reprex}

Powtarzalny przykład oznacza fragment kodu, który może być odtworzony przez inną osobę na innym komputerze/przez siebie samego w przyszłości.
Może on służyć pokazaniu poprawnego rozwiązania, wskazaniu na błędy w funkcjach, lub też jako załącznik do prośby o pomoc z kodem.
Powtarzalny przykład powinien składać się przynajmniej z:

- Z małego zbioru danych wystarczającego do odtworzenia obliczeń.
- Krótkiego kodu, który może być uruchomiony na powyższym zbiorze danych.

Czasem ważne są też dodatkowe informacje o używanej wersji R, posiadanym systemie operacyjnym, wersjach używanych pakietów, etc. 
Można do tego użyć funkcji `sessionInfo()` 

### Pakiet **reprex**

Stworzenie powtarzalnego przykładu w R może zostać ułatwione używając pakietu **reprex**. 
Ten pakiet uruchamia wybraną część kodu, wykonuje kolejne operacje, a następnie zapisuje uzyskany wynik do schowka.

Pakiet **reprex** można zainstalować poprzez funkcję `install.packages()`:

```{r 17-appendix-reprex-1, eval = FALSE}
install.packages("reprex")
```

Główną funkcją w tym pakiecie jest `reprex()`.
Funkcję `reprex()` można też użyć poprzez wpisanie kodu wewnątrz tej funkcji lub też poprzez wybranie opcji `Reprex selection` z menu Addins w RStudio.
Możliwe jest również stworzenie powtarzalnego przykładu na podstawie skryptu R:

```{r 17-appendix-reprex-2, eval=FALSE}
reprex(input = "moj_skrypt.R")
```

### Tworzenie powtarzalnego przykładu

#### Prosty przykład

Sprawdźmy działanie pakietu **reprex** na prostym przykładzie - tworzymy dwa obiekty `x` i `y`, nadajemy im wartości a następnie mnożymy je przez siebie:

```{r 17-appendix-reprex-3, eval=FALSE}
library(reprex)
reprex({
        x = 1
        y = 5
        x * y
})
```

Po jego uruchomieniu otrzymujemy wynik zapisany w schowku jako Markdown oraz w postaci wyświetlonego HTMLa:

![](figs/reprex1.png)

#### Złożony przykład

Spróbujmy teraz trochę bardziej skomplikowanego przykładu.
Naszym celem jest stworzenie mapy punktowej temperatury na podstawie obiektu **punkty**.
Powtarzalny przykład może posłużyć do szybkiego określenia problemów z kodem:

```{r 17-appendix-reprex-4, eval=FALSE}
library(reprex)
reprex({
        library(sf)
        data(punkty)
        plot(punkty["temperatura"])
})
```

Powyższy kod ma dwa problemy - czy jesteś w stanie je wskazać?

![](figs/reprex2.png)

Odpowiedź - ten kod nie jest w pełni samowystarczalny - brakuje tam dołączenia pakietu **geostatbook**, który zawiera zbiór danych `punkty`.
Drugi problem to użyta zmienna do wizualizacji - `"temperatura"` nie istnieje w zbiorze danych `punkty`. 
Zamiast niej powinna być użyta poprawna nazwa zmiennej - `"temp"`.
Naprawiona wersja tego kodu znajduje się poniżej:

```{r 17-appendix-reprex-5, eval=FALSE}
library(reprex)
reprex({
        library(sf)
        library(geostatbook)
        data(punkty)
        plot(punkty["temp"])
})
```

![](figs/reprex3.png)

W efekcie otrzymujemy nie tylko kod użyty do obliczeń, ale również wynikową grafikę.

#### Więcej informacji

- [Oficjalna strona pakietu reprex](https://reprex.tidyverse.org/index.html)
- [So you’ve been asked to make a reprex](https://www.jessemaegan.com/post/so-you-ve-been-asked-to-make-a-reprex/)
- [How to make a great R reproducible example](https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example)
- [Magic reprex](https://www.njtierney.com/post/2017/01/11/magic-reprex/)
- [reprex: help me help you!](https://speakerdeck.com/jennybc/reprex-help-me-help-you)
- [Get help!](https://www.tidyverse.org/help/#reprex)

## Proces debugowania

Nie ma uniwersalnego procesu debugowania, który działa dla każdego napotkanego problemu programistycznego. 
Można jednak określić kilka kroków, które mogą znacząco ułatwić debugowanie:

1. Powtarzalność błędu
2. Identyfikacja przyczyny błędu
3. Usunięcie błędu
4. Weryfikacja naprawy błędu i jej konsekwencji

W pierwszym kroku warto się upewnić, że napotkany błąd nie jest spowodowany przez inne obiekty w środowisku R. 
Należy wyczyścić środowisko R używając `rm(list = ls())` a następnie zresetować sesję R (CTRL+SHIFT+F10 w RStudio).
Warto też wydzielić z kodu najmniejszy fragment, który pozwala na odtworzenie błędu. 
Teraz należy jeszcze raz spróbować użyć kodu zwracającego błąd, aby się upewnić, że dalej istnieje.

Drugi krok obejmuje zlokalizowanie dokładnego miejsca w którym błąd powstaje. 
Może to być konkretna linia kodu, miejsce w pętli, a czasem nawet wywołanie innej zewnętrznej funkcji.
Ten krok można wykonać na wiele sposobów. 
Dwa z nich, AAA i BBB, są opisane w tym rozdziale.

W trzecim kroku należy usunąć wcześniej zlokalizowany błąd.
Nie powinien to być jednak ostatni krok.

Należy jeszcze upewnić się, że nowa wersja kodu nie tylko przestaje zwracać błędy, ale też daje poprawne wyniki.
Często odbywa się to poprzez wykonanie wcześniej stworzony testów jednostkowych (sekcja \@ref(testy-jednostkowe)).

## Podstawowe podejście do debugowania {#debuging-print}



<!-- `print()`, `cat()` - small objects -->
<!-- `str()` - large object trunct -->
<!-- test values -->

<!-- `traceback()` - bottom to top -->

## Interaktywne debugowanie {#debuging-interactive}

<!-- ## inside R -->

<!-- `browser()` -->

<!-- `n` - next statement -->
<!-- `c` - continue -->
<!-- `s` step into function call -->
<!-- `f` finish loop/funciton -->
<!-- `where` previous calls -->
<!-- `Q` quit debugger -->

<!-- + RStudio gui -->
<!-- + brakepoints -->

<!-- ## inside R 2-->

<!-- `debug()`, `trace()`, `recover()` -->

## Zadania

<!-- create debugging examples - .R files -->
<!-- https://github.com/jimhester/wtf-debugging -->